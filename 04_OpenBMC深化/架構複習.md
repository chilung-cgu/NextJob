# 🖥️ OpenBMC 架構複習

> 這是你的優勢！面試時可以深入展示你的專業  
> 本文件針對 **Meta Yosemite 4 平台**（使用 entity-manager）

---

## 📌 從零開始：什麼是 BMC？

### 💡 生活化比喻

```
想像一台伺服器是一棟大樓：

┌─────────────────────────────────────────────────────────────┐
│                        伺服器 = 大樓                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   CPU = 辦公室的員工    RAM = 辦公桌空間   硬碟 = 檔案櫃      │
│   GPU = 專業設備        網路 = 電梯/走道                      │
│                                                             │
│   那誰是「大樓管理員」呢？                                    │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │  BMC = 大樓管理員（Baseboard Management Controller）  │   │
│   │                                                       │   │
│   │  負責：                                               │   │
│   │  ✅ 開關電源（開/關整棟大樓的電）                       │   │
│   │  ✅ 監控溫度（確保冷氣正常、不會過熱）                  │   │
│   │  ✅ 看誰進出（遠端連線管理）                           │   │
│   │  ✅ 處理緊急狀況（當機時遠端復原）                      │   │
│   │  ✅ 記錄事件（誰何時做了什麼）                          │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│   重點：即使大樓（伺服器）停電/當機，                         │
│         管理員（BMC）還是可以獨立運作！                       │
│         因為 BMC 有自己的電源、CPU、記憶體、網路              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🔧 BMC 的實際硬體

```
┌─────────────────────────────────────────────────────────────┐
│                       BMC 硬體組成                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   BMC 其實是一塊獨立的小電腦，焊在主機板上：                   │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │  BMC SoC（常見廠牌）：                                │   │
│   │  - ASPEED：AST2500、AST2600（最常見！）               │   │
│   │  - Nuvoton：NPCM7xx 系列                             │   │
│   │                                                       │   │
│   │  硬體規格（以 AST2600 為例）：                         │   │
│   │  - CPU：ARM Cortex-A7 雙核心                         │   │
│   │  - RAM：最多 1GB DDR4                                │   │
│   │  - Flash：放 BMC 韌體（通常 32-64MB SPI Flash）       │   │
│   │  - 介面：I2C、SPI、GPIO、UART、網路                   │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│   💡 你的 I2C/SPI/UART 知識就是用在這裡！                    │
│      BMC 透過這些介面和主機板上的 Sensor/Fan/PSU 溝通        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 📌 OpenBMC 是什麼？

```
OpenBMC 是一個 Linux 基金會的開源專案，用於：
- 伺服器的 Baseboard Management Controller (BMC)
- 提供遠端管理和監控功能
- 替代專有的 BMC 韌體（如 AMI MegaRAC、Insyde H2O）

主要貢獻者：
┌────────────────┬────────────────────────────────────────────┐
│     公司       │                   貢獻重點                  │
├────────────────┼────────────────────────────────────────────┤
│ IBM            │ OpenBMC 創始者，Power 系統                 │
│ Meta/Facebook  │ Yosemite 系列平台（你用的！）              │
│ Google         │ 雲端伺服器                                  │
│ Microsoft      │ Azure 伺服器                               │
│ Intel          │ x86 平台支援                               │
│ AMD            │ EPYC 平台支援                              │
│ NVIDIA         │ GPU 管理、DGX 系統                         │
│ Ampere         │ ARM 伺服器                                 │
└────────────────┴────────────────────────────────────────────┘

💡 你的 OpenBMC 經驗對 NVIDIA/AMD 非常有價值！
   他們正在積極招募有 OpenBMC 經驗的人才！
```

### OpenBMC vs 傳統 BMC 韌體

```
┌────────────────┬────────────────────┬────────────────────┐
│                │    傳統 BMC 韌體    │      OpenBMC       │
├────────────────┼────────────────────┼────────────────────┤
│ 原始碼         │ 封閉、專有          │ 完全開源           │
│ 作業系統       │ 專有 RTOS          │ Linux              │
│ 客製化彈性     │ 低（要找廠商改）    │ 高（自己改）        │
│ 社群支援       │ 無                  │ 活躍的開源社群      │
│ 安全更新       │ 依賴廠商            │ 快速、透明          │
│ 開發工具       │ 專有工具鏈          │ 標準 Linux 工具     │
│ 學習曲線       │ 依廠商文件          │ 有公開文件和範例    │
└────────────────┴────────────────────┴────────────────────┘
```

---

## 🔷 OpenBMC 整體架構

```
┌─────────────────────────────────────────────────────────────┐
│                    OpenBMC 架構                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Management Interfaces               │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │   │
│  │  │ Redfish │  │  IPMI   │  │   SSH   │  │  WebUI │ │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬───┘ │   │
│  └───────┼────────────┼────────────┼────────────┼──────┘   │
│          │            │            │            │           │
│  ┌───────┴────────────┴────────────┴────────────┴──────┐   │
│  │                     D-Bus                            │   │
│  │     (phosphor-dbus-interfaces - 共享 API 定義)       │   │
│  └───────┬────────────┬────────────┬────────────┬──────┘   │
│          │            │            │            │           │
│  ┌───────┴────┐ ┌─────┴─────┐ ┌────┴────┐ ┌────┴────┐     │
│  │ Phosphor   │ │ Phosphor   │ │Phosphor │ │Phosphor │     │
│  │ Inventory  │ │   LED     │ │  Hwmon  │ │ Logging │     │
│  └────────────┘ └───────────┘ └─────────┘ └─────────┘     │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 Linux Kernel                         │   │
│  │  (Device Drivers, I2C, SPI, GPIO, hwmon, etc.)      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Hardware                            │   │
│  │  (CPU, GPU, DIMM, PSU, Fan, Sensors, etc.)          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔷 核心元件詳解

### 1. D-Bus（核心中的核心！）

#### 💡 D-Bus 是什麼？生活化比喻

```
想像 OpenBMC 是一間大公司，每個「服務」是一個「部門」：

┌─────────────────────────────────────────────────────────────┐
│                    OpenBMC 公司                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐           │
│  │ 感測器  │ │  電源   │ │  風扇   │ │  日誌   │           │
│  │  部門   │ │  部門   │ │  部門   │ │  部門   │           │
│  │(Hwmon)  │ │ (PSU)   │ │ (Fan)   │ │(Logging)│           │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘           │
│       │          │          │          │                   │
│       └──────────┴──────────┴──────────┘                   │
│                      │                                      │
│              ┌───────┴───────┐                              │
│              │    D-Bus      │  ← 公司的「內部通訊系統」     │
│              │  (Message Bus)│     像是 Email + 電話總機     │
│              └───────────────┘                              │
│                                                             │
│  D-Bus 的功能：                                              │
│  1. 讓部門之間可以互相溝通（不用直接認識對方）                 │
│  2. 可以「廣播」訊息給所有人（例如：溫度太高警報！）           │
│  3. 可以查詢其他部門的狀態（例如：風扇部門，你們轉速多少？）    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 🔑 D-Bus 四大核心概念

```
┌─────────────────────────────────────────────────────────────┐
│  1. Service Name（服務名稱）= 部門名稱                       │
│     └── 例：xyz.openbmc_project.Hwmon                       │
│         類似公司裡的「感測器部門」                            │
├─────────────────────────────────────────────────────────────┤
│  2. Object Path（物件路徑）= 該部門管理的「具體物件」         │
│     └── 例：/xyz/openbmc_project/sensors/temperature/cpu0   │
│         類似「感測器部門管理的 CPU0 溫度計」                  │
├─────────────────────────────────────────────────────────────┤
│  3. Interface（介面）= 這個物件可以做什麼                    │
│     └── 例：xyz.openbmc_project.Sensor.Value                │
│         類似「這個溫度計可以讀取數值」                        │
├─────────────────────────────────────────────────────────────┤
│  4. Property（屬性）= 實際的資料                            │
│     └── 例：Value = 45.5（目前溫度 45.5 度）                 │
│         類似「溫度計顯示的數字」                              │
└─────────────────────────────────────────────────────────────┘

完整例子：
「請問 xyz.openbmc_project.Hwmon 服務（感測器部門），
 /xyz/openbmc_project/sensors/temperature/cpu0（CPU0 溫度計）
 的 xyz.openbmc_project.Sensor.Value（讀數功能）
 的 Value 屬性（實際數值）是多少？」

答：45.5
```

#### 🛠️ 常用 busctl 命令（實戰必備！）

```bash
# 1. 列出所有服務（看公司有哪些部門）
busctl list

# 2. 查看某服務的物件樹（看這個部門管理哪些東西）
busctl tree xyz.openbmc_project.Hwmon

# 輸出範例：
# └─/xyz/openbmc_project/sensors
#   ├─/xyz/openbmc_project/sensors/temperature
#   │ ├─/xyz/openbmc_project/sensors/temperature/cpu0
#   │ └─/xyz/openbmc_project/sensors/temperature/cpu1
#   └─/xyz/openbmc_project/sensors/fan
#     └─/xyz/openbmc_project/sensors/fan/fan0

# 3. 查看物件有哪些介面和屬性
busctl introspect xyz.openbmc_project.Hwmon \
    /xyz/openbmc_project/sensors/temperature/cpu0

# 4. 讀取單一屬性
busctl get-property xyz.openbmc_project.Hwmon \
    /xyz/openbmc_project/sensors/temperature/cpu0 \
    xyz.openbmc_project.Sensor.Value Value

# 輸出：d 45.5  （d = double 型態，值 = 45.5）

# 5. 呼叫方法（例如：開機）
busctl call xyz.openbmc_project.State.Host \
    /xyz/openbmc_project/state/host0 \
    xyz.openbmc_project.State.Host \
    RequestedHostTransition s \
    "xyz.openbmc_project.State.Host.Transition.On"

# 6. 即時監控 D-Bus 訊息（Debug 超好用！）
busctl monitor
```

### 2. phosphor-dbus-interfaces

```
這個 repository 定義了 OpenBMC 的 D-Bus API。

路徑結構：
yaml/
└── xyz/
    └── openbmc_project/
        ├── Sensor/
        │   └── Value.interface.yaml
        ├── State/
        │   ├── Host.interface.yaml
        │   └── Chassis.interface.yaml
        └── Inventory/
            └── Item.interface.yaml

Interface 定義範例：
# xyz/openbmc_project/Sensor/Value.interface.yaml
description: A sensor value
properties:
  - name: Value
    type: double
    description: The sensor value
  - name: Unit
    type: string
    description: The unit of measurement
```

### 3. phosphor-hwmon

```
負責讀取硬體感測器數值。

運作方式：
1. 讀取 Linux hwmon sysfs (/sys/class/hwmon)
2. 將數值透過 D-Bus 發布
3. 提供 Sensor.Value 介面

設定檔位置：
/etc/default/obmc/hwmon/

設定檔範例：
# 48-0048.conf (I2C device at address 0x48)
LABEL_temp1=cpu0_temp
LABEL_temp2=cpu1_temp
```

### 4. Entity-Manager（Meta Yosemite 4 使用這個！）

> ⚠️ 注意：OpenBMC 有兩種硬體管理方式：
> - **phosphor-inventory-manager**：傳統方式，使用靜態 YAML 設定
> - **entity-manager**：現代方式，使用動態 JSON 設定（Yosemite 4 使用這個！）

#### 💡 Entity-Manager vs Inventory-Manager 比較

```
┌────────────────────┬─────────────────────┬─────────────────────┐
│                    │ phosphor-inventory  │   entity-manager    │
│                    │     -manager        │  （你用的！）        │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 設定格式           │ YAML                │ JSON                │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 設定方式           │ 靜態編譯            │ 動態載入            │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 硬體偵測           │ 手動定義            │ 自動探測（Probe）   │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 彈性               │ 較低                │ 較高                │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 適用場景           │ 固定硬體配置        │ 可變硬體配置        │
│                    │                     │ （如多 Slot 系統）  │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 使用廠商           │ IBM                 │ Meta、Intel、Google │
└────────────────────┴─────────────────────┴─────────────────────┘
```

#### 🔧 Entity-Manager 運作原理

```
┌─────────────────────────────────────────────────────────────┐
│                    Entity-Manager 架構                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. JSON 設定檔（定義硬體配置）                               │
│     └── /usr/share/entity-manager/configurations/           │
│         ├── Yosemite4.json                                  │
│         ├── Yosemite4_Slot1.json                            │
│         └── ...                                             │
│                                                             │
│  2. Probe 機制（自動偵測硬體）                                │
│     └── Entity-Manager 會去 I2C/GPIO 探測                   │
│         如果發現符合條件的硬體，就載入對應設定                 │
│                                                             │
│  3. 發布到 D-Bus                                             │
│     └── 偵測到的硬體資訊會發布到 D-Bus                       │
│         其他服務（如 dbus-sensors）會訂閱這些資訊             │
│                                                             │
│  流程圖：                                                    │
│  ┌────────────┐    ┌───────────────┐    ┌─────────────┐     │
│  │ JSON 設定  │───→│ Entity-Manager│───→│   D-Bus     │     │
│  │  (靜態)    │    │  (Probe 偵測) │    │  (發布)     │     │
│  └────────────┘    └───────────────┘    └──────┬──────┘     │
│                                                 │            │
│                                    ┌────────────┴──────┐     │
│                                    ▼                   ▼     │
│                              ┌───────────┐      ┌───────────┐│
│                              │dbus-sensors│     │  Redfish  ││
│                              │ (讀 Sensor)│     │  (API)    ││
│                              └───────────┘      └───────────┘│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 📝 Entity-Manager JSON 設定檔範例

```json
// /usr/share/entity-manager/configurations/Yosemite4_Example.json
{
    "Exposes": [
        {
            "Name": "CPU0 Temperature",
            "Type": "TMP75",           // 使用 TMP75 溫度 Sensor
            "Bus": 2,                   // I2C Bus 2
            "Address": "0x48"           // I2C 地址 0x48
        },
        {
            "Name": "PSU0 Power",
            "Type": "ADM1278",          // 使用 ADM1278 電源管理 IC
            "Bus": 5,
            "Address": "0x10"
        }
    ],
    "Probe": "TRUE",                    // 永遠載入（或可設條件）
    "Name": "Yosemite4 Slot1",
    "Type": "Board"
}
```

#### 🛠️ Entity-Manager Debug 常用命令

```bash
# 查看 Entity-Manager 偵測到哪些硬體
busctl tree xyz.openbmc_project.EntityManager

# 查看某個硬體的詳細設定
busctl introspect xyz.openbmc_project.EntityManager \
    /xyz/openbmc_project/inventory/system/board/Yosemite4_Slot1

# 查看 Entity-Manager 的 Log
journalctl -u xyz.openbmc_project.EntityManager

# 強制重新載入設定（如果改了 JSON）
systemctl restart xyz.openbmc_project.EntityManager
```

#### Meta Yosemite 4 平台相關

```
Yosemite 4 是 Meta 的開放運算平台（OCP），特點：

┌─────────────────────────────────────────────────────────────┐
│                    Yosemite 4 架構                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Management Module                   │   │
│  │  (BMC 主控板，運行 OpenBMC)                          │   │
│  └──────────┬──────────┬──────────┬──────────┬─────────┘   │
│             │          │          │          │              │
│       ┌─────┴───┐ ┌────┴────┐ ┌───┴─────┐ ┌─┴───────┐      │
│       │ Slot 1  │ │ Slot 2  │ │ Slot 3  │ │ Slot 4  │      │
│       │(運算卡) │ │(運算卡) │ │(運算卡) │ │(運算卡) │      │
│       └─────────┘ └─────────┘ └─────────┘ └─────────┘      │
│                                                             │
│  每個 Slot 可以放不同類型的運算卡（CPU、GPU、加速器等）       │
│  這就是為什麼需要 Entity-Manager：                           │
│  → 動態偵測每個 Slot 插了什麼卡                              │
│  → 根據不同的卡載入不同的 Sensor 設定                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5. phosphor-logging

```
處理系統日誌和錯誤。

功能：
- 記錄系統事件
- 管理 SEL (System Event Log)
- 透過 Redfish 和 IPMI 提供日誌存取
```

---

## 🔷 管理介面

### IPMI

```
IPMI (Intelligent Platform Management Interface)

常見操作：
# 電源控制
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power on
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power off
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power cycle

# 讀取感測器
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sensor list

# 查看 SEL
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sel list

# SOL (Serial over LAN)
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sol activate
```

### Redfish 深度解析

```
Redfish 是由 DMTF 定義的現代化 Server 管理標準，旨在取代老舊的 IPMI。
如果把 IPMI 比喻成「發電報」，Redfish 就是「滑網頁」。

1. 為什麼需要 Redfish？
   - 安全性：強制使用 HTTPS，支援現代加密標準 (TLS)。
   - 易讀性：使用 JSON 格式，人類可讀 (Human readable)，不再是二進位代碼。
   - 擴充性：標準化的 Schema (CSDL)，不再像 IPMI OEM command 那樣混亂。
   - 雲端友善：RESTful API 設計，非常容易跟現代的雲端管理工具 (Ansible, Terraform) 整合。

2. 核心架構：資源樹三大支柱 (The Big Three)
   Redfish 將伺服器資源分為三大邏輯區塊，這也是 URL 路徑的核心結構：

   /redfish/v1/
    ├── Systems (系統視角 / 邏輯層)
    │    └── /Systems/system
    │        邏輯上的運算資源。包含 CPU 型號、記憶體大小、BIOS 版本、開機順序。
    │        就像是你進 BIOS Setup 會看到的資訊。
    │
    ├── Chassis (機殼視角 / 物理層)
    │    └── /Chassis/chassis
    │        物理上的硬體組件。包含風扇轉速、溫度感測器、PSU 狀態、機殼開啟偵測。
    │        就像是你打開機殼蓋看到的實體零件。
    │
    └── Managers (管理員視角 / BMC層)
         └── /Managers/bmc
             負責管理的 BMC 本身。包含 IP 設定、帳號管理、Serial Console、Logs。

3. 核心精神：自我描述 (Self-describing)
   Redfish 的回應不只是資料，還包含「你可以做什麼」。

   範例：GET /redfish/v1/Systems/system
   
   {
       "@odata.id": "/redfish/v1/Systems/system",
       "PowerState": "On",            <-- 直接告訴你狀態，不用查 Bit map
       "ProcessorSummary": {
           "Count": 2,
           "Model": "Intel(R) Xeon(R) Gold 6248 CPU"
       },
       "Actions": {                   <-- 關鍵！告訴你接下來可以做什麼
           "#ComputerSystem.Reset": {
               "target": "/redfish/v1/Systems/system/Actions/ComputerSystem.Reset"
           }
       }
   }
   
   注意 `Actions` 欄位，它直接引導你「如果想重置系統，請對這個 target URL 發請求」。
   這就是 RESTful 的 Hypermedia 精神 (HATEOAS)。

4. 實務操作指南 (必背！)

   準備工具：curl, Postman, 瀏覽器

   (A) 電源控制 (Power Control) - ★ 面試必考
   使用 POST 方法對 "Actions" 資源發送指令。
   
   # 開機
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "On" }

   # 關機 (Force Off - 拔電源)
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "ForceOff" }

   # 正常關機 (Graceful Shutdown - 通知 OS 關機)
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "GracefulShutdown" }

   (B) 讀取感測器 (Sensors)
   OpenBMC 的 `bmcweb` 會去 D-Bus 撈取 `phosphor-hwmon` 或 `dbus-sensors` 的數值。

   # 讀取特定 Sensor
   GET /redfish/v1/Chassis/chassis/Sensors/CPU0_Temp
   
   {
       "Name": "CPU0 Temp",
       "Reading": 45.0,        <-- 攝氏度
       "ReadingUnits": "Cel"
   }

   (C) 帳號管理
   建立新使用者：
   POST /redfish/v1/AccountService/Accounts
   {
       "UserName": "admin2",
       "Password": "NewPassword123",
       "RoleId": "Administrator"
   }

5. OpenBMC 中的 Redfish 實作架構
   OpenBMC 使用 `bmcweb` (C++ based) 作為 Web Server。
   
   Client (curl) 
      ↓ HTTPS
   bmcweb (Redfish Server)
      ↓ (查詢 Mapper)
   D-Bus (System Bus)
      ↓ (Get Property)
   Backend Services (phosphor-hwmon, phosphor-state-manager...)

   Debug 技巧：
   - 檢查 bmcweb 狀態：`systemctl status bmcweb`
   - 檢查 D-Bus 資料：`busctl get-property ...` (確認後端有資料，如果不通就是介接層問題)
```

---

## 🔷 Build System (Yocto)

```
OpenBMC 使用 Yocto Project 作為 build system。

重要目錄：
poky/              # Yocto 核心
meta-openembedded/ # 社群 layers
meta-phosphor/     # OpenBMC 核心 recipes
meta-xxx/          # 廠商特定的 layer

常用命令：
# 初始化 build 環境
source setup <machine>

# 開始 build
bitbake obmc-phosphor-image

# Build 單一 package
bitbake phosphor-hwmon

# 開發模式
devtool modify phosphor-hwmon
devtool build phosphor-hwmon
devtool reset phosphor-hwmon
```

---

## 📝 面試會問的 OpenBMC 問題

### 🎯 基礎題

**Q1：OpenBMC 的整體架構是什麼？**

```
「OpenBMC 是一個基於 Linux 的開源 BMC 韌體專案，
由 Linux 基金會託管，主要貢獻者包括 IBM、Meta、Google、Intel 等。

整體架構從下到上分為四層：

    ┌─────────────────────────────────────────────────┐
 4. │  Management Interfaces                          │
    │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌───────┐ │
    │  │ Redfish │ │  IPMI   │ │   SSH   │ │ WebUI │ │
    │  └────┬────┘ └────┬────┘ └────┬────┘ └───┬───┘ │
    ├───────┼───────────┼───────────┼──────────┼─────┤
 3. │       └───────────┴───────────┴──────────┘     │
    │              D-Bus (System Bus)                 │
    │  ┌──────────┐ ┌──────────┐ ┌──────────┐        │
    │  │  Hwmon   │ │ Logging  │ │  State   │ ...   │
    │  └────┬─────┘ └────┬─────┘ └────┬─────┘        │
    ├───────┼────────────┼────────────┼──────────────┤
 2. │       └────────────┴────────────┘              │
    │              Linux Kernel                       │
    │  (I2C driver, SPI driver, GPIO, hwmon)         │
    ├────────────────────────────────────────────────┤
 1. │              Hardware                           │
    │  (BMC SoC, Sensors, PSU, Fan, Host CPU)        │
    └────────────────────────────────────────────────┘

核心特點：
1. 使用 D-Bus 作為 IPC 機制，所有服務透過 D-Bus 溝通
2. 使用 systemd 管理服務生命週期
3. 使用 Yocto 作為 build system
4. 各元件高度模組化，可獨立開發和更新

與傳統 BMC 韌體的差異：
- 開源 vs 封閉
- Linux vs 專有 RTOS
- 社群驅動 vs 廠商鎖定」
```

---

**Q2：D-Bus 在 OpenBMC 中扮演什麼角色？**

```
「D-Bus 是 OpenBMC 的核心通訊機制，可以想像成系統的『神經網路』。

D-Bus 的四大功能：

1. 服務發現 (Service Discovery)
   - 服務啟動時向 D-Bus 註冊
   - 其他服務可以動態發現新服務
   - 例如：Entity-Manager 偵測到新硬體後，
     dbus-sensors 可以立即發現並開始讀取

2. 方法呼叫 (Method Call)
   - 類似 RPC (Remote Procedure Call)
   - 例如：Redfish 呼叫 State.Host.RequestedHostTransition 來開機

3. 屬性存取 (Property Access)
   - 透過 Get/Set 讀取和設定狀態
   - 例如：Redfish 讀取 Sensor.Value 取得溫度

4. 信號廣播 (Signal)
   - 事件通知機制，一對多
   - 例如：溫度超過閥值時廣播 ThresholdCritical 信號

為什麼選擇 D-Bus？
- 鬆耦合：服務間不需要直接相依
- 標準化：phosphor-dbus-interfaces 定義統一 API
- 可觀察：用 busctl 可以監控所有通訊，方便 debug
- 語言無關：C++、Python、Go 都可以使用

實際案例：
當使用者透過 Redfish 讀取溫度時：
Redfish → D-Bus get-property → phosphor-hwmon → 回傳數值
```

---

**Q3：請說明 Sensor 資料從硬體到 Redfish API 的完整流程**

```
「這個問題展示你對整體架構的理解。完整流程如下：

1. 硬體層
   ├─ I2C Sensor（如 TMP75）連接在 I2C Bus 上
   └─ Linux hwmon driver 載入，建立 sysfs 節點
      /sys/class/hwmon/hwmon0/temp1_input

2. Kernel 層
   └─ hwmon driver 週期性讀取 I2C 暫存器
      並更新 sysfs 檔案內容（單位通常是 milli-degree）

3. Phosphor 層（兩種方式，視平台而定）

   方式 A：phosphor-hwmon（傳統）
   └─ 讀取 /sys/class/hwmon/*/temp*_input
      透過設定檔定義 Sensor 名稱對應

   方式 B：dbus-sensors + entity-manager（現代，Yosemite 4 使用）
   └─ entity-manager 讀取 JSON 設定，偵測 I2C 裝置
   └─ dbus-sensors 根據設定建立 Sensor 物件

4. D-Bus 層
   └─ Sensor 以 D-Bus 物件發布
      Service: xyz.openbmc_project.HwmonTempSensor
      Object:  /xyz/openbmc_project/sensors/temperature/CPU0_Temp
      Interface: xyz.openbmc_project.Sensor.Value
      Property: Value = 45.5

5. Management 層
   └─ bmcweb (Redfish service) 訂閱 D-Bus
      收到 GET /redfish/v1/Chassis/chassis/Sensors/CPU0_Temp
      → 查詢 D-Bus 取得數值
      → 回傳 JSON：{ "Reading": 45.5, "ReadingUnits": "Cel" }

實際 Debug 方式：
1. cat /sys/class/hwmon/hwmon0/temp1_input  # 確認 kernel 層
2. busctl get-property ... Sensor.Value Value  # 確認 D-Bus 層
3. curl -k https://bmc/redfish/v1/.../Sensors/CPU0_Temp  # 確認 API 層
```

---

### 🎯 進階題（展示深度！）

**Q4：Entity-Manager 和 phosphor-inventory-manager 有什麼差異？你們平台用哪個？**

```
「我們使用的 Meta Yosemite 4 平台是用 entity-manager。
這兩者是 OpenBMC 兩種不同的硬體管理機制：

┌─────────────────┬──────────────────────┬──────────────────────┐
│                 │ phosphor-inventory   │   entity-manager     │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 設定格式        │ YAML                 │ JSON                 │
│ 載入時機        │ 編譯時               │ 執行時               │
│ 硬體偵測        │ 靜態定義             │ 動態 Probe           │
│ 適用場景        │ 固定硬體配置         │ 可變硬體配置         │
│ 代表廠商        │ IBM (Power)          │ Meta, Intel, Google  │
└─────────────────┴──────────────────────┴──────────────────────┘

為什麼 Yosemite 4 選擇 entity-manager？

Yosemite 4 是多 Slot 設計，每個 Slot 可以插不同的運算卡：
- Slot 1 可能是 CPU 卡
- Slot 2 可能是 GPU 卡
- Slot 3 可能是空的

entity-manager 的優勢：
1. Probe 機制可以動態偵測每個 Slot 插了什麼
2. 根據偵測結果載入對應的 Sensor 設定
3. 不需要為每種組合重新編譯韌體

實際運作流程：
1. entity-manager 啟動
2. 讀取 /usr/share/entity-manager/configurations/*.json
3. 執行 Probe 條件（如：檢查 I2C 地址是否有回應）
4. Probe 成功 → 在 D-Bus 發布 Inventory 物件
5. dbus-sensors 訂閱 D-Bus，發現新硬體
6. 建立對應的 Sensor 物件」
```

---

**Q5：IPMI 和 Redfish 的差異？為什麼趨勢是 Redfish？**

```
「這是 BMC 領域的重要議題，我來詳細說明：

┌────────────────┬──────────────────────┬──────────────────────┐
│                │        IPMI          │       Redfish        │
├────────────────┼──────────────────────┼──────────────────────┤
│ 制定組織       │ Intel (已轉移 DMTF)  │ DMTF                 │
│ 協定格式       │ 二進位               │ JSON over HTTPS      │
│ 傳輸方式       │ UDP/LAN, KCS, BT     │ HTTPS (TCP)          │
│ 安全性         │ 較弱*                │ TLS + 認證           │
│ 可讀性         │ 需要解析             │ 人類可讀             │
│ 擴展性         │ OEM Command          │ Schema + OEM         │
│ 學習曲線       │ 陡峭                 │ 較平緩               │
│ 除錯難度       │ 需要特殊工具         │ curl 即可            │
└────────────────┴──────────────────────┴──────────────────────┘

* IPMI 安全性問題：
  - IPMI v1.5 密碼明文傳輸
  - IPMI v2.0 有 RMCP+ 但實作常有漏洞
  - 2013 年發現重大漏洞（cipher 0 問題）

為什麼趨勢是 Redfish？
1. 安全性：基於 HTTPS，符合現代安全標準
2. 雲端整合：JSON 格式易於與雲端管理系統整合
3. 事件訂閱：支援 EventDestination，可主動推送事件
4. 豐富資訊：比 IPMI 能提供更詳細的系統資訊
5. 版本演進：DMTF 仍在積極更新規格

但 IPMI 仍然重要的原因：
1. 向後相容：大量現有工具依賴 IPMI
2. SOL (Serial over LAN)：Redfish 仍不如 IPMI SOL 成熟
3. 某些低階操作：如 BIOS 更新，仍常用 IPMI」
```

---

**Q6：如何 debug 一個『Sensor 讀不到值』的問題？**

```
「這是很實際的問題。我會按照從底層到上層的順序排查：

1. 確認硬體連接
   i2cdetect -y <bus>
   # 確認 Sensor 的 I2C 地址有回應（看到數字而非 --）

2. 確認 Kernel Driver
   dmesg | grep -i hwmon
   ls /sys/class/hwmon/
   # 確認 hwmon 節點有建立

3. 確認 sysfs 數值
   cat /sys/class/hwmon/hwmon*/temp*_input
   # 如果這裡沒值，問題在 driver 層

4. 確認 D-Bus 服務
   systemctl status xyz.openbmc_project.HwmonTempSensor
   journalctl -u xyz.openbmc_project.HwmonTempSensor
   # 看有沒有錯誤訊息

5. 確認 D-Bus 物件
   busctl tree xyz.openbmc_project.HwmonTempSensor
   # 確認 Sensor 物件有建立
   
   busctl get-property xyz.openbmc_project.HwmonTempSensor \
       /xyz/openbmc_project/sensors/temperature/CPU0_Temp \
       xyz.openbmc_project.Sensor.Value Value
   # 確認可以讀到值

6. 確認 Redfish
   curl -k -u root:password \
       https://localhost/redfish/v1/Chassis/chassis/Sensors

常見問題和解法：
┌─────────────────────────┬─────────────────────────────────────┐
│ 現象                    │ 可能原因                            │
├─────────────────────────┼─────────────────────────────────────┤
│ i2cdetect 看不到        │ 1. 接線問題 2. I2C Bus 錯誤         │
├─────────────────────────┼─────────────────────────────────────┤
│ sysfs 沒有節點          │ 1. Driver 沒載入 2. Device Tree 錯  │
├─────────────────────────┼─────────────────────────────────────┤
│ sysfs 有值但 D-Bus 沒有 │ 1. 設定檔錯誤 2. 服務沒啟動         │
├─────────────────────────┼─────────────────────────────────────┤
│ D-Bus 有但 Redfish 沒有 │ 1. bmcweb 設定問題 2. Sensor 命名   │
└─────────────────────────┴─────────────────────────────────────┘
```

---

**Q7：你在 OpenBMC 做過什麼功能？（STAR 框架回答）**

```
這題必須準備！以下是範例框架，你需要填入自己的經驗：

範例一：新增 Sensor 支援
─────────────────────────
Situation：
「我們的 Yosemite 4 平台新增了一款 GPU 運算卡，
上面有新的電源管理 IC (MPS MP2973)，需要讀取功耗資料。」

Task：
「我負責在 OpenBMC 上新增這顆 IC 的 Sensor 支援，
讓使用者可以透過 Redfish 讀取 GPU 功耗。」

Action：
「1. 首先研究 MP2973 的 datasheet，了解 I2C 暫存器定義
 2. 確認現有的 hwmon driver 不支援，需要新增
 3. 在 entity-manager 新增 JSON 設定，定義 I2C Bus 和 Address
 4. 在 dbus-sensors 新增 MPS MP2973 的讀取邏輯
 5. 撰寫單元測試，確保功耗計算公式正確
 6. 在實際硬體上驗證 D-Bus 和 Redfish 都可以正確讀取
 7. 提交 PR，經過 code review 後合併」

Result：
「成功上線，客戶可以透過 Redfish 監控 GPU 功耗，
這個功能也被上游 OpenBMC 接受，貢獻給社群。」

─────────────────────────

範例二：修復 Fan PWM 問題
─────────────────────────
Situation：
「QA 回報風扇轉速控制不穩定，有時候 PWM 設定沒有生效。」

Task：
「Debug 並修復這個問題。」

Action：
「1. 用 busctl monitor 觀察 Fan PWM 的 D-Bus 訊息流
 2. 發現設定 PWM 後，有另一個服務又把它改回去
 3. 追蹤發現是 phosphor-fan-control 的 PID 控制覆蓋了手動設定
 4. 研究 fan-control 的程式碼，發現需要加 Manual Override 機制
 5. 修改程式碼，新增 ManualMode 屬性
 6. 當 ManualMode = true 時，PID 不會覆蓋 PWM」

Result：
「修復後 QA 驗證通過，也發現這是上游的已知問題，
我把修復提交給上游，被接受合併。」
```

---

**Q8：OpenBMC 如何處理 Host 電源狀態管理？**

```
「電源狀態管理是 BMC 的核心功能之一。

狀態機：
┌──────────────────────────────────────────────────────────────┐
│                     Host Power State Machine                  │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│    ┌─────────┐    Power On     ┌──────────┐                 │
│    │   Off   │ ───────────────→│ Running  │                 │
│    └────┬────┘                 └────┬─────┘                 │
│         │                           │                        │
│         │                           │ Power Off / Reboot     │
│         │                           ▼                        │
│         │                      ┌──────────┐                  │
│         │←──────────────────── │ Quiesced │                  │
│         │                      └──────────┘                  │
│                                                              │
└──────────────────────────────────────────────────────────────┘

D-Bus 介面：
- Service: xyz.openbmc_project.State.Host
- Object: /xyz/openbmc_project/state/host0
- Properties:
  - CurrentHostState (Running/Off/Quiesced/...)
  - RequestedHostTransition (On/Off/Reboot/...)

電源控制方式：
1. D-Bus 方法呼叫
   busctl set-property xyz.openbmc_project.State.Host \
       /xyz/openbmc_project/state/host0 \
       xyz.openbmc_project.State.Host \
       RequestedHostTransition s \
       "xyz.openbmc_project.State.Host.Transition.On"

2. Redfish API
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "On" }

3. IPMI Command
   ipmitool power on

實際電源控制 GPIO：
BMC 通常透過 GPIO 控制電源：
- POWER_BUTTON (GPIO 觸發開機)
- RESET_BUTTON (GPIO 觸發重開)
- POWER_GOOD (GPIO 讀取電源狀態)

這些 GPIO 的定義在 Device Tree 或 Entity-Manager JSON 中」
```

---

### 🎯 實戰題

**Q9：如果要在 OpenBMC 新增一個全新的 I2C Sensor，需要改哪些東西？**

```
「這題考驗你對整個開發流程的理解。

假設要新增一個新的溫度 Sensor IC：ABC1234

需要修改的地方（使用 entity-manager + dbus-sensors）：

1. Linux Kernel Driver（如果 kernel 沒有支援）
   ────────────────────────────────────────────
   位置：Linux kernel 上游或 meta-phosphor/recipes-kernel/
   
   需要寫一個 hwmon driver，或確認現有 driver 支援

2. Entity-Manager JSON 設定
   ────────────────────────
   位置：/usr/share/entity-manager/configurations/
   
   新增或修改 JSON：
   {
       "Exposes": [{
           "Name": "New Sensor",
           "Type": "ABC1234",
           "Bus": 2,
           "Address": "0x48"
       }],
       "Probe": "xyz.openbmc_project.FruDevice({'ADDRESS': 72})"
   }

3. dbus-sensors（如果 dbus-sensors 沒有支援）
   ──────────────────────────────────────────
   位置：openbmc/dbus-sensors
   
   可能需要新增一個 Sensor 類別：
   - 新增 include/ABC1234Sensor.hpp
   - 新增 src/ABC1234Sensor.cpp
   - 修改 CMakeLists.txt

4. Recipe / Meta Layer
   ────────────────────
   如果是廠商特定的，需要在 meta-xxx layer 新增：
   - 設定檔 (JSON)
   - 可能的 patch

開發和驗證步驟：
1. 在實機用 i2cdetect 確認 Sensor 可偵測
2. 編譯包含新 driver 的 kernel
3. 編譯包含新設定的 entity-manager
4. Flash 新韌體
5. 驗證 sysfs → D-Bus → Redfish 都正確
```

---

## ✅ 面試前複習清單

```
核心概念：
☐ 能畫出 OpenBMC 四層架構圖
☐ 能解釋 D-Bus 的四大功能（發現、呼叫、屬性、信號）
☐ 能說明 Sensor 資料從硬體到 Redfish 的完整流程
☐ 知道 IPMI 和 Redfish 的差異及趨勢

技術細節：
☐ 知道 entity-manager vs phosphor-inventory-manager 差異
☐ 能解釋 entity-manager 的 Probe 機制
☐ 知道 phosphor-hwmon vs dbus-sensors 的差異
☐ 會使用 busctl 查詢和監控 D-Bus

實作經驗：
☐ 準備好 2-3 個自己做過的功能案例（用 STAR 框架）
☐ 能說明 Debug Sensor 問題的步驟
☐ 知道新增 Sensor 需要改哪些檔案

Build 相關：
☐ 知道 Yocto build system 基本操作
☐ 知道 meta-layer 的結構和用途
☐ 會使用 devtool 進行開發

加分項目：
☐ 有貢獻過上游程式碼
☐ 了解 phosphor-dbus-interfaces 的角色
☐ 知道電源狀態管理的狀態機
```

---

## 🔷 PLDM 協定（進階面試必備）

### 💡 什麼是 PLDM？

```
PLDM (Platform Level Data Model) 是 DMTF 定義的平台管理標準，
用於 BMC 與 Host、擴充卡、其他 BMC 之間的通訊。

相較於 IPMI：
┌────────────────────┬──────────────────┬────────────────────────┐
│                    │      IPMI        │        PLDM            │
├────────────────────┼──────────────────┼────────────────────────┤
│ 制定組織           │ Intel (已轉 DMTF)│ DMTF                   │
│ 資料格式           │ 二進位           │ 二進位（TLV 結構）     │
│ 傳輸層             │ KCS, BT, LAN     │ MCTP (多種傳輸)        │
│ 擴展性             │ OEM Command      │ Type/Subtype 結構化    │
│ 典型用途           │ BMC ↔ Host       │ BMC ↔ 擴充卡/Host      │
│ 未來發展           │ 維護模式         │ 積極開發               │
└────────────────────┴──────────────────┴────────────────────────┘
```

### PLDM 傳輸層：MCTP

```
MCTP (Management Component Transport Protocol) 是 PLDM 的傳輸層。

支援多種物理層：
┌─────────────────────────────────────────────────────────────────┐
│                     MCTP 傳輸層架構                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                      ┌─────────────┐                            │
│                      │    PLDM     │  ← 應用層                  │
│                      └──────┬──────┘                            │
│                             │                                   │
│                      ┌──────┴──────┐                            │
│                      │    MCTP     │  ← 傳輸層                  │
│                      └──────┬──────┘                            │
│          ┌──────────────────┼──────────────────┐                │
│          │                  │                  │                │
│    ┌─────┴─────┐     ┌─────┴─────┐     ┌──────┴─────┐          │
│    │ MCTP over │     │ MCTP over │     │ MCTP over  │          │
│    │    I2C    │     │   PCIe    │     │   SMBus    │          │
│    └───────────┘     └───────────┘     └────────────┘          │
│                                                                 │
│  典型用途：                                                      │
│  - MCTP over I2C/SMBus：BMC ↔ 擴充卡（如 GPU、NIC）             │
│  - MCTP over PCIe VDM：BMC ↔ Host CPU                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### PLDM 類型 (Types)

```c
/* PLDM 定義多種 Type，每種處理不同功能 */

/* PLDM Type 列表 */
#define PLDM_BASE           0x00  /* 基礎功能、版本查詢 */
#define PLDM_SMBIOS         0x01  /* SMBIOS 資料傳輸 */
#define PLDM_PLATFORM       0x02  /* 平台監控（Sensor、Effecter） */
#define PLDM_BIOS           0x03  /* BIOS 設定管理 */
#define PLDM_FRU            0x04  /* FRU 資料 */
#define PLDM_FWUP           0x05  /* 韌體更新 */
#define PLDM_RDE            0x06  /* Redfish Device Enablement */
#define PLDM_OEM            0x3F  /* OEM 自定義 */

/* 常見使用場景 */
/*
 * 1. PLDM Platform (Type 2)
 *    - BMC 透過 PLDM 讀取擴充卡上的 Sensor（如 GPU 溫度）
 *    - 設定 Effecter（如 LED 狀態）
 *
 * 2. PLDM FW Update (Type 5)
 *    - BMC 透過 PLDM 更新擴充卡韌體（如 NIC firmware）
 *
 * 3. PLDM BIOS (Type 3)
 *    - BMC 讀取/設定 BIOS 屬性（取代部分 IPMI OEM）
 */
```

### OpenBMC 中的 PLDM

```bash
# OpenBMC 的 PLDM 實作：pldm (openbmc/pldm)

# 查看 PLDM 服務狀態
systemctl status pldm

# 查看 PLDM D-Bus 物件
busctl tree xyz.openbmc_project.PLDM

# PLDM 發現的 Sensor 會發布到 D-Bus
# 其他服務（如 bmcweb）可以訂閱這些 Sensor

# PLDM Debug
journalctl -u pldm -f
```

### PLDM 面試常見問題

```
Q：PLDM 和 IPMI 有什麼差異？什麼時候用 PLDM？

A：PLDM 設計更現代，適合複雜的平台管理：

1. 結構化擴展：PLDM 用 Type/Subtype 定義功能，比 IPMI OEM 更規範

2. 豐富的 Sensor 模型：
   - IPMI SDR：固定格式，難以描述複雜 Sensor
   - PLDM PDR：可描述 Sensor 依賴、關聯

3. 典型使用場景：
   - GPU 卡上的溫度/功耗 Sensor → PLDM Platform
   - NIC 韌體更新 → PLDM FW Update
   - BIOS 設定同步 → PLDM BIOS

4. 傳輸靈活：
   - MCTP 可走 I2C、PCIe、SMBus
   - 適合多種拓撲
```

---

## 🔷 SPDM 協定（安全面試加分）

### 💡 什麼是 SPDM？

```
SPDM (Security Protocol and Data Model) 是 DMTF 定義的安全協定，
用於設備間的身份認證和安全通訊。

┌─────────────────────────────────────────────────────────────────┐
│                     SPDM 核心功能                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. 設備身份驗證 (Device Authentication)                        │
│     - BMC 可以驗證擴充卡是否為正版                              │
│     - 防止惡意硬體插入                                          │
│                                                                 │
│  2. 韌體完整性驗證 (Firmware Measurement)                       │
│     - 驗證擴充卡韌體是否被竄改                                  │
│     - 搭配 Attestation 使用                                     │
│                                                                 │
│  3. 安全通訊 (Secure Session)                                   │
│     - 建立加密通道傳輸敏感資料                                  │
│     - 類似 TLS，但用於設備間通訊                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### SPDM 流程

```
SPDM 認證流程（簡化版）：

1. GET_VERSION
   BMC → Device：你支援哪些 SPDM 版本？
   Device → BMC：支援 SPDM 1.0, 1.1, 1.2

2. GET_CAPABILITIES
   BMC → Device：你有什麼能力？
   Device → BMC：可以做認證、量測、加密...

3. NEGOTIATE_ALGORITHMS
   雙方協商使用的加密演算法（如 ECDSA、SHA-384）

4. GET_DIGESTS
   BMC 取得 Device 的憑證摘要（快速比對）

5. GET_CERTIFICATE
   BMC 取得 Device 的完整憑證鏈

6. CHALLENGE
   BMC 發送隨機數，Device 用私鑰簽章回應
   → 驗證 Device 擁有對應的私鑰 = 驗證身份

7. GET_MEASUREMENTS
   BMC 讀取 Device 的韌體量測值
   → 與已知好的值比對 = 驗證韌體完整性
```

### 為什麼需要 SPDM？

```
現代伺服器安全需求：

1. 供應鏈安全 (Supply Chain Security)
   - 確保擴充卡是原廠正品
   - 防止硬體級別攻擊

2. 零信任架構 (Zero Trust)
   - 不再假設內部設備可信
   - 每個設備都需要驗證

3. 合規要求
   - NIST SP 800-193 (Firmware Resilience)
   - Cyber Resilience Act (歐盟)

4. 與 Attestation 整合
   - SPDM 量測 → 送到 Attestation Server
   - 企業可以驗證所有設備的韌體狀態
```

### OpenBMC 中的 SPDM

```
# OpenBMC 正在積極開發 SPDM 支援
# 主要 repository：openbmc/libspdm, openbmc/spdm

# 典型整合方式：
# 1. BMC 啟動時，對所有擴充卡做 SPDM 認證
# 2. 認證失敗的卡會被標記/disable
# 3. 結果透過 Redfish 報告
```

---

## 🔷 AST2600 硬體知識

### 💡 什麼是 AST2600？

```
AST2600 是 ASPEED 的 BMC SoC，是目前最主流的 BMC 晶片之一。
（AST = ASPEED，2600 是第三代，前代是 AST2500, AST2400）

┌─────────────────────────────────────────────────────────────────┐
│                     AST2600 規格                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  CPU：ARM Cortex-A7 雙核心 @ 1.2GHz                             │
│       （前代 AST2500 是 ARM11 單核心）                          │
│                                                                 │
│  記憶體：最大 1GB DDR4                                          │
│                                                                 │
│  Flash：支援 SPI NOR Flash（通常 64-128MB）                     │
│                                                                 │
│  安全功能：                                                      │
│    - Secure Boot                                                │
│    - Hardware Crypto Engine (AES, SHA)                          │
│    - True Random Number Generator                               │
│    - One-Time Programmable (OTP) Memory                         │
│                                                                 │
│  介面：                                                          │
│    - I2C: 16 組 Bus                                             │
│    - SPI: 3 組                                                  │
│    - UART: 13 組                                                │
│    - GPIO: 232 個                                               │
│    - PWM/TACH: 16 組                                            │
│    - ADC: 16 通道                                               │
│    - 10/100/1000M Ethernet x2                                   │
│    - USB 2.0 x2                                                 │
│    - eSPI / LPC（Host 通訊）                                    │
│    - PCIe（VGA 輸出）                                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### AST2600 vs AST2500

```
┌─────────────────────┬─────────────────────┬─────────────────────┐
│                     │     AST2500         │     AST2600         │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ CPU                 │ ARM11 單核 800MHz   │ Cortex-A7 雙核 1.2G │
│ RAM                 │ 最大 512MB DDR3     │ 最大 1GB DDR4       │
│ Secure Boot         │ ❌                  │ ✅                  │
│ eSPI                │ ❌（只有 LPC）      │ ✅                  │
│ USB                 │ 1.1                 │ 2.0                 │
│ Crypto HW           │ 基本                │ 完整 HW 加速        │
│ I2C Bus             │ 14 組               │ 16 組               │
│ 效能                │ ~                   │ 3x~5x               │
└─────────────────────┴─────────────────────┴─────────────────────┘

面試重點：
- AST2600 有 Secure Boot，適合高安全需求平台
- 雙核心可以做更複雜的運算（如 Attestation）
- eSPI 是現代 Host 通訊的標準（取代 LPC）
```

### AST2600 GPIO 使用

```c
/* AST2600 GPIO 在 Linux 中的使用 */

/* 1. 透過 sysfs（舊方法，但仍常見） */
# 匯出 GPIO
echo 128 > /sys/class/gpio/export

# 設定方向
echo out > /sys/class/gpio/gpio128/direction

# 設定值
echo 1 > /sys/class/gpio/gpio128/value

/* 2. 透過 gpiod（推薦方法） */
# 查看 GPIO chip 資訊
gpioinfo

# 設定 GPIO 值
gpioset gpiochip0 128=1

# 讀取 GPIO 值
gpioget gpiochip0 128

/* 3. 在 OpenBMC 中，通常透過 D-Bus */
busctl call xyz.openbmc_project.LED.GroupManager \
    /xyz/openbmc_project/led/groups/enclosure_identify \
    xyz.openbmc_project.Led.Group \
    Asserted b true
```

### AST2600 I2C 多路器

```
AST2600 有 16 組 I2C Bus，但實際系統通常需要更多。
解決方案：使用 I2C Multiplexer (Mux)

典型拓撲：
                    ┌─────────────────────────────────────┐
                    │           AST2600                    │
                    │  I2C0 ─────→ 直接連接設備            │
                    │  I2C1 ─────→ 直接連接設備            │
                    │  I2C2 ───┬── PCA9548 Mux ───┬─ ch0 ─→ Slot0 設備│
                    │          │                 ├─ ch1 ─→ Slot1 設備│
                    │          │                 ├─ ch2 ─→ Slot2 設備│
                    │          │                 └─ ch3 ─→ Slot3 設備│
                    │          └──────────────────────────│
                    └─────────────────────────────────────┘

在 Device Tree 中定義 Mux：
i2c_mux@70 {
    compatible = "nxp,pca9548";
    reg = <0x70>;
    #address-cells = <1>;
    #size-cells = <0>;
    
    i2c@0 {  /* Channel 0 → Slot 0 */
        reg = <0>;
        sensor@48 {
            compatible = "ti,tmp75";
            reg = <0x48>;
        };
    };
};
```

### 面試常問：AST2600 相關

```
Q：為什麼選擇 AST2600 而不是其他 BMC 晶片？

A：
1. 市場主流：ASPEED 在 BMC 市場佔有率最高
2. OpenBMC 支援最完整
3. 效能/功能平衡好
4. 有 Secure Boot，符合安全合規

Q：AST2600 和 Host CPU 如何通訊？

A：
1. eSPI/LPC：系統管理（IPMI over KCS）
2. Shared Memory：BIOS POST Code
3. PCIe VDM + MCTP：PLDM 通訊
4. USB Virtual Media：遠端掛載 ISO
5. 網路：帶外管理（Redfish、SSH）
```

---

## 🔷 phosphor-dbus-interfaces 核心 Interface

### 💡 什麼是 phosphor-dbus-interfaces？

```
phosphor-dbus-interfaces 是 OpenBMC 的 D-Bus API 定義庫。
就像是 OpenBMC 的「API 規格書」。

位置：https://github.com/openbmc/phosphor-dbus-interfaces

目錄結構：
yaml/
└── xyz/
    └── openbmc_project/
        ├── Sensor/
        │   ├── Value.interface.yaml
        │   └── Threshold/
        │       ├── Warning.interface.yaml
        │       └── Critical.interface.yaml
        ├── State/
        │   ├── Host.interface.yaml
        │   └── Chassis.interface.yaml
        ├── Inventory/
        │   └── Item.interface.yaml
        └── ...
```

### 核心 Interface 列表

```yaml
# 1. Sensor.Value - 感測器數值
# yaml/xyz/openbmc_project/Sensor/Value.interface.yaml

description: A sensor reading value
properties:
  - name: Value
    type: double
    description: The sensor reading value
  - name: Unit
    type: enum[self.Unit]
    description: The unit of the reading
  - name: Scale
    type: int64
    default: 0
    description: The scale as a power of 10

# 2. State.Host - Host 電源狀態
# yaml/xyz/openbmc_project/State/Host.interface.yaml

properties:
  - name: CurrentHostState
    type: enum[self.HostState]
    description: The current state of the host
  - name: RequestedHostTransition
    type: enum[self.Transition]
    description: The desired transition for the host

enumerations:
  - name: HostState
    values:
      - name: Off
      - name: Running
      - name: Quiesced
      - name: TransitioningToRunning
      - name: TransitioningToOff
  - name: Transition
    values:
      - name: Off
      - name: On
      - name: Reboot
      - name: GracefulReboot

# 3. Sensor.Threshold.Warning - 警告閾值
# yaml/xyz/openbmc_project/Sensor/Threshold/Warning.interface.yaml

properties:
  - name: WarningHigh
    type: double
    description: The upper warning threshold
  - name: WarningLow
    type: double
    description: The lower warning threshold
  - name: WarningAlarmHigh
    type: boolean
    description: True if value is above WarningHigh
```

### 實際使用範例

```bash
# 讀取 Sensor 數值
busctl get-property xyz.openbmc_project.HwmonTempSensor \
    /xyz/openbmc_project/sensors/temperature/CPU0_Temp \
    xyz.openbmc_project.Sensor.Value Value

# 設定 Host 電源（開機）
busctl set-property xyz.openbmc_project.State.Host \
    /xyz/openbmc_project/state/host0 \
    xyz.openbmc_project.State.Host \
    RequestedHostTransition s \
    "xyz.openbmc_project.State.Host.Transition.On"

# 讀取閾值
busctl get-property xyz.openbmc_project.HwmonTempSensor \
    /xyz/openbmc_project/sensors/temperature/CPU0_Temp \
    xyz.openbmc_project.Sensor.Threshold.Warning WarningHigh
```

### 為什麼重要？

```
1. 統一 API：所有 OpenBMC 服務遵循相同的介面定義
2. 相互操作性：Meta 寫的服務可以和 IBM 寫的互通
3. 文件化：YAML 定義即是文件
4. 程式碼生成：可以自動生成 C++/Python binding
5. 面試重點：知道這些 interface 代表你真的懂 OpenBMC 架構
```

---

## 📝 面試題庫補充

### Q10：什麼是 PLDM？與 IPMI 的關係？

**難度**：⭐⭐⭐⭐⭐

**答案**：
```
PLDM 是 DMTF 定義的平台管理標準，用於 BMC 與擴充卡、Host 的通訊。

與 IPMI 的關係：
- 互補：IPMI 用於傳統管理，PLDM 用於擴充卡通訊
- 傳輸不同：IPMI 用 KCS/LAN，PLDM 用 MCTP（可走 I2C/PCIe）
- 功能擴展：PLDM 可以做 FW Update、BIOS 設定等

典型使用場景：
- GPU 卡的溫度/功耗 Sensor → PLDM Platform
- NIC 韌體更新 → PLDM FW Update
- Host BIOS 設定同步 → PLDM BIOS
```

---

### Q11：解釋 SPDM 的用途

**難度**：⭐⭐⭐⭐⭐

**答案**：
```
SPDM 是安全協定，用於：

1. 設備認證：驗證擴充卡是正品（憑證檢驗）
2. 韌體完整性：驗證擴充卡韌體未被竄改（量測值）
3. 安全通道：建立加密通訊

用途：
- 供應鏈安全：防止惡意硬體
- 零信任架構：每個設備都需驗證
- Attestation：定期驗證系統狀態
```

---

### Q12：AST2600 有哪些關鍵特性？

**難度**：⭐⭐⭐⭐

**答案**：
```
AST2600 是 ASPEED 最新的 BMC SoC：

1. CPU：ARM Cortex-A7 雙核心 1.2GHz
2. RAM：最大 1GB DDR4
3. Secure Boot：支援硬體安全啟動
4. eSPI：現代 Host 通訊介面
5. Crypto HW：AES/SHA 硬體加速
6. 介面豐富：16 I2C、232 GPIO、16 PWM

相比 AST2500：
- 效能 3-5 倍
- 有 Secure Boot
- 支援 eSPI（不只 LPC）
```

---

### Q13：如何在 OpenBMC 中新增一個 PLDM Sensor？

**難度**：⭐⭐⭐⭐⭐

**答案**：
```
假設要讀取 GPU 卡上的溫度 Sensor（透過 PLDM）：

1. 確認 MCTP 連接
   - 確認 GPU 卡支援 MCTP over I2C
   - 在 device-tree 設定 MCTP endpoint

2. PLDM 發現
   - pldm 服務啟動時會發現 endpoint
   - 查詢 PLDM Platform Type 取得 PDR

3. PDR 解析
   - PLDM 服務解析 PDR（Platform Descriptor Records）
   - 建立 Sensor 物件

4. D-Bus 發布
   - PLDM 服務將 Sensor 發布到 D-Bus
   - 實作 xyz.openbmc_project.Sensor.Value interface

5. Redfish 整合
   - bmcweb 訂閱 D-Bus Sensor
   - 透過 Redfish API 提供給使用者
```

---

### Q14：phosphor-dbus-interfaces 的作用是什麼？

**難度**：⭐⭐⭐⭐

**答案**：
```
phosphor-dbus-interfaces 是 OpenBMC D-Bus API 的定義庫：

1. YAML 定義：
   - 每個 interface 用 YAML 檔案定義
   - 包含 properties、methods、signals

2. 作用：
   - 統一 API：所有服務遵循相同定義
   - 文件化：YAML 即是文件
   - 程式碼生成：可生成 C++/Python binding

3. 核心 interface：
   - Sensor.Value：感測器數值
   - State.Host：Host 電源狀態
   - Logging.Entry：日誌項目
   - Inventory.Item：硬體資產

4. 重要性：
   知道這些 interface 代表你真的理解 OpenBMC 的架構設計
```

---

## ✅ 面試前複習清單（更新版）

```
核心概念：
☐ 能畫出 OpenBMC 四層架構圖
☐ 能解釋 D-Bus 的四大功能（發現、呼叫、屬性、信號）
☐ 能說明 Sensor 資料從硬體到 Redfish 的完整流程
☐ 知道 IPMI 和 Redfish 的差異及趨勢

技術細節：
☐ 知道 entity-manager vs phosphor-inventory-manager 差異
☐ 能解釋 entity-manager 的 Probe 機制
☐ 知道 phosphor-hwmon vs dbus-sensors 的差異
☐ 會使用 busctl 查詢和監控 D-Bus

進階主題：
☐ 理解 PLDM 的用途和類型（Platform、FW Update、BIOS）
☐ 理解 SPDM 的安全功能（認證、量測、加密通道）
☐ 知道 AST2600 的關鍵規格和與 AST2500 的差異
☐ 熟悉 phosphor-dbus-interfaces 核心 interface

實作經驗：
☐ 準備好 2-3 個自己做過的功能案例（用 STAR 框架）
☐ 能說明 Debug Sensor 問題的步驟
☐ 知道新增 Sensor 需要改哪些檔案

Build 相關：
☐ 知道 Yocto build system 基本操作
☐ 知道 meta-layer 的結構和用途
☐ 會使用 devtool 進行開發

加分項目：
☐ 有貢獻過上游程式碼
☐ 了解 MCTP 傳輸層
☐ 知道電源狀態管理的狀態機
☐ 了解 Secure Boot 流程
```

---

## 🔷 Yocto Build System 深入解析

### 💡 什麼是 Yocto？

```
Yocto Project 是一個開源專案，用於建立客製化 Linux 發行版。
OpenBMC 使用 Yocto 作為其 build system。

為什麼選擇 Yocto？
1. 可重現性：相同 recipe 在不同機器上產生相同結果
2. 客製化：完全控制每個 package 的內容
3. 交叉編譯：在 x86 主機上編譯 ARM BMC 韌體
4. 層級化架構：不同廠商可以在不修改核心的情況下客製化
```

### Yocto 核心概念

```
┌─────────────────────────────────────────────────────────────────┐
│                    Yocto 核心概念                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Layer（層）                                                  │
│     一組相關的 metadata（recipes, configs, classes）             │
│     例如：meta-phosphor, meta-aspeed, meta-facebook              │
│                                                                 │
│  2. Recipe（配方）                                               │
│     描述如何 fetch、configure、compile、install 一個 package     │
│     檔案副檔名：.bb（一般 recipe）, .bbappend（附加修改）         │
│                                                                 │
│  3. BitBake                                                      │
│     Yocto 的 build engine，負責解析 recipe 並執行 build          │
│     類似 Make，但更複雜且適合發行版等級的 build                    │
│                                                                 │
│  4. Machine（機器）                                              │
│     定義目標硬體平台的設定                                        │
│     例如：ast2600-evb, yosemite4                                 │
│                                                                 │
│  5. Distro（發行版）                                             │
│     定義發行版的政策，如 init system、libc 類型                   │
│     OpenBMC 的 distro = openbmc-phosphor                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### OpenBMC Layer 結構

```
OpenBMC 專案目錄結構：

openbmc/
├── poky/                      # Yocto 核心（上游）
│   ├── meta/                  # 核心 layer
│   └── meta-poky/             # Poky distro
│
├── meta-openembedded/         # 社群維護的 layer
│   ├── meta-oe/               # 常用工具
│   ├── meta-python/           # Python packages
│   └── meta-networking/       # 網路工具
│
├── meta-phosphor/             # OpenBMC 核心 layer ★
│   ├── recipes-phosphor/      # OpenBMC 服務 recipes
│   │   ├── dbus/              # D-Bus 相關
│   │   ├── flash/             # 韌體更新
│   │   ├── interfaces/        # phosphor-dbus-interfaces
│   │   ├── logging/           # 日誌
│   │   ├── sensors/           # 感測器
│   │   └── state/             # 電源狀態
│   ├── classes/               # OpenBMC 專用 class
│   └── conf/                  # 設定檔
│
├── meta-aspeed/               # ASPEED 晶片支援
│   ├── recipes-bsp/           # U-Boot, kernel 設定
│   └── recipes-kernel/        # Kernel patches
│
├── meta-xxx/                  # 廠商特定 layer
│   ├── meta-facebook/         # Meta 平台
│   ├── meta-google/           # Google 平台
│   ├── meta-intel/            # Intel 平台
│   └── meta-nvidia/           # NVIDIA 平台
│
└── build/                     # Build 輸出目錄
    ├── conf/
    │   ├── local.conf         # 本地設定
    │   └── bblayers.conf      # Layer 列表
    └── tmp/                   # 中間檔案
```

### Layer 優先級 (Priority)

```
每個 layer 有一個優先級（BBFILE_PRIORITY），決定同名 recipe 的覆蓋順序。

典型優先級（數字越大越優先）：

┌─────────────────────┬────────────┬────────────────────────────┐
│       Layer         │  Priority  │         說明               │
├─────────────────────┼────────────┼────────────────────────────┤
│ meta                │     5      │ Yocto 核心，最低優先       │
│ meta-oe             │     6      │ 社群 layer                 │
│ meta-phosphor       │     7      │ OpenBMC 核心               │
│ meta-aspeed         │     8      │ 晶片廠商                   │
│ meta-facebook       │     9      │ 平台廠商，最高優先         │
└─────────────────────┴────────────┴────────────────────────────┘

實際用途：
- meta-phosphor 定義 phosphor-hwmon recipe
- meta-facebook 用 .bbappend 附加自己的設定檔
- 優先級確保 meta-facebook 的修改生效

設定方式（在 layer.conf 中）：
BBFILE_PRIORITY_meta-facebook = "9"
```

### Recipe 撰寫入門

```bash
# Recipe 基本結構 (.bb 檔案)
# 檔案：meta-facebook/recipes-example/example/example_1.0.bb

# 基本資訊
SUMMARY = "Example recipe for OpenBMC"
DESCRIPTION = "This is an example recipe"
LICENSE = "Apache-2.0"
LIC_FILES_CHKSUM = "file://LICENSE;md5=xxx"

# 原始碼來源
SRC_URI = "git://github.com/example/example.git;branch=main;protocol=https"
SRCREV = "abc123def456"
S = "${WORKDIR}/git"

# 相依性
DEPENDS = "systemd sdbusplus"
RDEPENDS:${PN} = "bash"

# Build 相關
inherit cmake systemd

# Systemd 服務設定
SYSTEMD_SERVICE:${PN} = "example.service"

# 安裝步驟（如果需要客製化）
do_install:append() {
    install -d ${D}${sysconfdir}/example
    install -m 0644 ${S}/config.json ${D}${sysconfdir}/example/
}

# 產出的 package
FILES:${PN} += "${sysconfdir}/example/*"
```

### .bbappend 修改現有 Recipe

```bash
# .bbappend 用於修改其他 layer 的 recipe
# 檔案：meta-facebook/recipes-phosphor/sensors/phosphor-hwmon_%.bbappend

# 附加額外的設定檔
FILESEXTRAPATHS:prepend := "${THISDIR}/${PN}:"

SRC_URI += " \
    file://yosemite4_sensor.conf \
    "

# 修改安裝步驟
do_install:append() {
    install -d ${D}${sysconfdir}/default/obmc/hwmon
    install -m 0644 ${WORKDIR}/yosemite4_sensor.conf \
        ${D}${sysconfdir}/default/obmc/hwmon/
}

# 附加檔案到 package
FILES:${PN} += "${sysconfdir}/default/obmc/hwmon/*"
```

### 常用 BitBake 命令

```bash
# 初始化 build 環境
source setup yosemite4

# Build 完整韌體 image
bitbake obmc-phosphor-image

# Build 單一 package
bitbake phosphor-hwmon

# Clean 後重新 build
bitbake -c cleanall phosphor-hwmon
bitbake phosphor-hwmon

# 查看 package 資訊
bitbake -e phosphor-hwmon | grep ^SRC_URI=

# 查看 task 順序
bitbake -c listtasks phosphor-hwmon

# 產生 dependency graph
bitbake -g obmc-phosphor-image
```

### devtool 開發流程

```bash
# devtool 是 Yocto 的開發輔助工具，大幅簡化開發流程

# 1. 設定開發環境
source setup yosemite4

# 2. 取出程式碼到 workspace
devtool modify phosphor-hwmon
# 程式碼會被 clone 到 build/workspace/sources/phosphor-hwmon

# 3. 切換到原始碼目錄進行開發
cd build/workspace/sources/phosphor-hwmon
# 編輯程式碼、commit 等

# 4. Build 並驗證
devtool build phosphor-hwmon

# 5. 部署到目標機器（透過 SSH）
devtool deploy-target phosphor-hwmon root@<bmc-ip>

# 6. 如果要提交到 layer
devtool update-recipe phosphor-hwmon

# 7. 完成開發，清理 workspace
devtool reset phosphor-hwmon
```

### 常見開發情境

```
情境一：新增 Sensor 設定檔
──────────────────────────
1. 建立 .bbappend
   meta-facebook/recipes-phosphor/sensors/phosphor-hwmon_%.bbappend

2. 放置設定檔
   meta-facebook/recipes-phosphor/sensors/phosphor-hwmon/yosemite4.conf

3. 在 .bbappend 中 install 設定檔

情境二：Patch 上游程式碼
──────────────────────────
1. 使用 devtool modify 取出程式碼
2. 修改並 commit
3. 使用 devtool finish 產生 patch

情境三：新增全新服務
──────────────────────────
1. 建立新 recipe (.bb)
2. 使用 inherit systemd 並定義 service
3. 加入 obmc-phosphor-image 的 IMAGE_INSTALL

Build Log 常見問題：
──────────────────────────
ERROR: do_fetch failed
  → 原始碼 URL 無法存取，檢查網路或 SRCREV

ERROR: do_compile failed
  → 編譯錯誤，查看 log.do_compile

ERROR: do_install failed
  → 安裝步驟錯誤，通常是路徑問題
```

---

## 🔷 Sensor Daemon 架構深入比較

### phosphor-hwmon vs dbus-sensors

```
OpenBMC 有兩種主流的 Sensor 讀取服務，理解差異很重要：

┌─────────────────────┬─────────────────────────┬─────────────────────────┐
│                     │    phosphor-hwmon       │    dbus-sensors         │
├─────────────────────┼─────────────────────────┼─────────────────────────┤
│ 設計理念            │ 讀取 sysfs，簡單直接    │ 主動探測，現代設計      │
│ 設定方式            │ 靜態設定檔              │ 配合 entity-manager     │
│ 支援的 Sensor       │ hwmon 相容設備          │ 更廣泛（含 PLDM）       │
│ 硬體偵測            │ 不偵測，依賴 kernel     │ 主動 probe I2C 裝置     │
│ 典型使用者          │ IBM                     │ Intel, Meta, Google     │
│ 開發活躍度          │ 維護模式                │ 積極開發                │
└─────────────────────┴─────────────────────────┴─────────────────────────┘
```

### phosphor-hwmon 詳解

```
運作流程：

1. Kernel hwmon driver 載入
   → 建立 /sys/class/hwmon/hwmonX/

2. phosphor-hwmon 服務啟動
   → 讀取設定檔 /etc/default/obmc/hwmon/

3. 設定檔定義 sysfs 到 D-Bus 的對應
   → 建立 D-Bus 物件

設定檔範例：
# /etc/default/obmc/hwmon/2-0048.conf
# 設定檔名稱 = <bus>-<address>
LABEL_temp1=CPU0_Temp
WARNHI_temp1=85000
WARNLO_temp1=10000
CRITHI_temp1=95000

# 說明：
# temp1 對應 sysfs 中的 temp1_input
# LABEL 定義 D-Bus 物件名稱
# WARNHI/LO 定義閾值（milli-degree）

優點：
- 簡單，學習曲線低
- 與 kernel hwmon 緊密整合

缺點：
- 不支援動態硬體偵測
- 設定分散在多個檔案
```

### dbus-sensors 詳解

```
運作流程：

1. entity-manager 啟動
   → 讀取 JSON 設定，執行 Probe
   → 在 D-Bus 發布 Inventory 物件

2. dbus-sensors 服務群啟動
   → 訂閱 entity-manager 的 InterfacesAdded signal
   → 根據硬體類型啟動對應的 sensor daemon

3. 各 sensor daemon 讀取硬體
   → 發布 Sensor.Value 到 D-Bus

dbus-sensors 包含多個服務：
┌─────────────────────────┬────────────────────────────────────┐
│ 服務名稱                │ 支援硬體                           │
├─────────────────────────┼────────────────────────────────────┤
│ hwmon-temp-sensor       │ TMP75, TMP112 等 hwmon 溫度        │
│ psu-sensor              │ PMBus PSU                          │
│ adc-sensor              │ ADC 輸入                           │
│ fan-sensor              │ TACH 風扇轉速                      │
│ intrusion-sensor        │ 機殼開啟偵測                       │
│ nvme-sensor             │ NVMe SSD 溫度                      │
│ pldm-sensor             │ PLDM Type 2 Sensor                 │
└─────────────────────────┴────────────────────────────────────┘

優點：
- 現代設計，與 entity-manager 整合
- 支援動態硬體偵測
- 集中化 JSON 設定

缺點：
- 學習曲線較陡
- 除錯時需要理解多個元件
```

### 選擇指南

```
何時選擇 phosphor-hwmon：
- 繼承既有的 IBM 平台設計
- 硬體配置固定不變
- 需要快速啟動專案

何時選擇 dbus-sensors：
- 新平台開發（推薦）
- 硬體配置可變（如多 Slot 系統）
- 需要 PLDM Sensor 支援
- 需要其他現代功能

Yosemite 4 選擇 dbus-sensors 的原因：
- 多 Slot 設計，每個 Slot 可能插不同卡
- 需要 entity-manager 的動態探測能力
- Meta 的新平台標準架構
```

---

## 🔷 D-Bus 進階主題

### D-Bus Object Mapper

```
Object Mapper 是 OpenBMC 的服務發現機制。

問題：
當你有一個 object path，如何知道哪個 service 擁有它？

解答：使用 Mapper

架構圖：
┌─────────────────────────────────────────────────────────────────┐
│                     Object Mapper 運作                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  各服務啟動時：                                                   │
│  ┌────────────────┐     ┌────────────────┐                      │
│  │ phosphor-hwmon │ ──→│ Object Mapper  │ ← 註冊物件訊息       │
│  │ phosphor-state │ ──→│ (會追蹤所有    │                      │
│  │ pldm-sensor    │ ──→│  D-Bus 物件)   │                      │
│  └────────────────┘     └───────┬────────┘                      │
│                                 │                               │
│  查詢時：                        │                               │
│  ┌────────────────┐             ▼                               │
│  │    bmcweb      │ ─→ 「這個 object path 是誰的？」            │
│  │  (需要 Sensor) │ ←─ 「是 phosphor-hwmon 的」                 │
│  └────────────────┘                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Mapper 使用範例

```bash
# Service: xyz.openbmc_project.ObjectMapper
# Object: /xyz/openbmc_project/object_mapper

# 查詢某個 path 是哪個 service 的
busctl call xyz.openbmc_project.ObjectMapper \
    /xyz/openbmc_project/object_mapper \
    xyz.openbmc_project.ObjectMapper \
    GetObject \
    sas "/xyz/openbmc_project/sensors/temperature/CPU0_Temp" 1 \
    xyz.openbmc_project.Sensor.Value

# 輸出：
# a{sas} 1 "xyz.openbmc_project.HwmonTempSensor" 1 "xyz.openbmc_project.Sensor.Value"

# 查詢實作某個 interface 的所有物件
busctl call xyz.openbmc_project.ObjectMapper \
    /xyz/openbmc_project/object_mapper \
    xyz.openbmc_project.ObjectMapper \
    GetSubTree \
    sias "/xyz/openbmc_project/sensors" 0 1 \
    xyz.openbmc_project.Sensor.Value

# 這會列出所有 Sensor
```

### D-Bus Signal 訂閱

```cpp
// C++ 範例：訂閱 D-Bus Signal

#include <sdbusplus/bus.hpp>

int main()
{
    auto bus = sdbusplus::bus::new_default();
    
    // 訂閱 PropertiesChanged signal
    auto match = sdbusplus::bus::match::match(
        bus,
        "type='signal',"
        "interface='org.freedesktop.DBus.Properties',"
        "member='PropertiesChanged',"
        "arg0='xyz.openbmc_project.Sensor.Value'",
        [](sdbusplus::message::message& msg) {
            std::string interface;
            std::map<std::string, std::variant<double>> properties;
            
            msg.read(interface, properties);
            
            if (auto v = properties.find("Value"); v != properties.end())
            {
                double value = std::get<double>(v->second);
                std::cout << "Sensor value changed: " << value << std::endl;
            }
        });
    
    while (true)
    {
        bus.process_discard();
        bus.wait();
    }
    
    return 0;
}
```

---

## 🔷 OpenBMC 安全機制

### Secure Boot 流程

```
AST2600 Secure Boot 流程：

1. ROM Code（不可修改）
   → 驗證 SPL 的簽章

2. SPL (Secondary Program Loader)
   → 驗證 U-Boot 的簽章

3. U-Boot
   → 驗證 Linux Kernel 的簽章

4. Linux Kernel
   → 可選：驗證 rootfs（dm-verity）

┌─────────────────────────────────────────────────────────────────┐
│                     Secure Boot Chain                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────┐    驗證     ┌──────┐    驗證    ┌─────────┐          │
│  │ ROM  │ ──────────→ │ SPL  │ ─────────→ │ U-Boot  │          │
│  │      │   RSA-2048  │      │  RSA-2048  │         │          │
│  └──────┘             └──────┘            └────┬────┘          │
│                                                │               │
│                                                ▼    驗證      │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                     Linux Kernel                        │   │
│  │  （可選：FIT Image 包含 DTB、Initramfs 一起驗證）        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  金鑰儲存：                                                      │
│  - Public Key 燒錄在 OTP (One-Time Programmable Memory)         │
│  - Private Key 由 BMC 廠商保管                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 韌體更新安全

```
OpenBMC 韌體更新流程（有 Secure Boot 時）：

1. 使用者上傳韌體 image
   POST /redfish/v1/UpdateService/update

2. bmcweb 將 image 交給 phosphor-software-manager

3. phosphor-software-manager 驗證：
   - 簽章驗證
   - 版本相容性檢查
   - Image 完整性（Hash）

4. 驗證通過後寫入 Flash

5. 重開機，Secure Boot 再次驗證新韌體

如果驗證失敗：
- ROM Code 不會跳轉到 SPL
- 系統無法啟動
- 需要 Recovery（如 UART 下載）
```

---

## 📝 面試題庫（擴充版）

### Q15：如何撰寫一個 OpenBMC recipe？

**難度**：⭐⭐⭐⭐
**常見於**：NVIDIA / Intel / Meta

**問題**：
假設你需要在 OpenBMC 中新增一個 C++ 服務，描述需要撰寫的 recipe 內容。

**標準答案**：
```
1. 建立 recipe 檔案
   meta-xxx/recipes-phosphor/example/example_1.0.bb

2. 定義基本資訊
   SUMMARY = "My example service"
   LICENSE = "Apache-2.0"
   LIC_FILES_CHKSUM = "file://LICENSE;md5=..."

3. 設定原始碼來源
   SRC_URI = "git://github.com/xxx/example.git;branch=main;protocol=https"
   SRCREV = "${AUTOREV}"  # 開發時使用
   S = "${WORKDIR}/git"

4. 設定相依性
   DEPENDS = "sdbusplus phosphor-dbus-interfaces"

5. Build 設定
   inherit cmake systemd
   SYSTEMD_SERVICE:${PN} = "example.service"

6. 安裝設定
   FILES:${PN} += "${sysconfdir}/example/*"
   
7. 加入 image
   在 image recipe 中加入：
   IMAGE_INSTALL:append = " example"
```

**延伸思考**：
- 如何處理不同版本的 recipe？（使用 PREFERRED_VERSION）
- 如何做 cross-compile 時的 native 工具依賴？

---

### Q16：解釋 OpenBMC 的 Object Mapper

**難度**：⭐⭐⭐⭐
**常見於**：Google / NVIDIA

**問題**：
什麼是 Object Mapper？它解決什麼問題？

**標準答案**：
```
Object Mapper 是 OpenBMC 的服務發現機制。

問題：
D-Bus 物件分散在多個 service 中，當你只知道 object path
（如 /xyz/openbmc_project/sensors/temperature/CPU0_Temp），
如何知道要向哪個 service 發送請求？

解決方案：
Object Mapper 會追蹤所有 D-Bus 物件的擁有者。

使用方式：
1. GetObject - 查詢 object path 對應的 service
2. GetSubTree - 查詢某路徑下所有物件
3. GetAssociatedSubTree - 查詢關聯物件

實際應用：
bmcweb 收到 Redfish 請求時：
1. 先查詢 Mapper 找到對應的 D-Bus service
2. 再向該 service 請求資料
```

---

### Q17：dbus-sensors 和 phosphor-hwmon 的差異？

**難度**：⭐⭐⭐⭐
**常見於**：Intel / Meta

**問題**：
說明兩者的設計差異和使用場景。

**標準答案**：
```
設計理念差異：

phosphor-hwmon：
- 被動讀取 kernel hwmon sysfs
- 靜態設定，編譯時決定
- 簡單直接，與 kernel 緊密整合

dbus-sensors：
- 主動探測硬體
- 配合 entity-manager 動態設定
- 支援更多硬體類型（含 PLDM）

選擇指南：
- 固定硬體配置 → phosphor-hwmon
- 可變硬體配置（如多 Slot）→ dbus-sensors
- 需要 PLDM → 必須用 dbus-sensors

Meta Yosemite 4 選擇 dbus-sensors 因為：
1. 多 Slot 設計需要動態偵測
2. 需要 PLDM 讀取 GPU Sensor
3. 標準化的 JSON 設定管理
```

---

### Q18：解釋 devtool 的開發流程

**難度**：⭐⭐⭐
**常見於**：普遍

**問題**：
如何使用 devtool 加速 OpenBMC 開發？

**標準答案**：
```
devtool 是 Yocto 的開發輔助工具：

基本流程：
1. devtool modify <recipe>
   → Clone 原始碼到 workspace

2. 修改程式碼
   → 在 build/workspace/sources/<recipe>/ 中開發

3. devtool build <recipe>
   → 編譯修改後的程式碼

4. devtool deploy-target <recipe> root@<bmc-ip>
   → 部署到 BMC（需要 SSH）

5. devtool reset <recipe>
   → 清理 workspace

進階用法：
- devtool update-recipe：更新 recipe 反映修改
- devtool finish：產生 patch 給 .bbappend

優點：
- 不需要完整 rebuild image
- 快速迭代，適合開發除錯
- 自動處理 cross-compile 設定
```

---

### Q19：D-Bus Signal 如何實現事件通知？

**難度**：⭐⭐⭐⭐⭐
**常見於**：NVIDIA / Google

**問題**：
說明如何使用 D-Bus Signal 實現溫度超過閾值時的事件通知。

**標準答案**：
```
使用 D-Bus PropertiesChanged Signal：

1. Sensor Service 發送 Signal
   當 Sensor 值超過 WarningHigh 閾值時，
   phosphor-hwmon 會：
   - 設定 WarningAlarmHigh = true
   - 發送 PropertiesChanged Signal

2. 監控方訂閱 Signal
   使用 sdbusplus match 訂閱：
   
   match = match::match(
       bus,
       "type='signal',"
       "interface='org.freedesktop.DBus.Properties',"
       "member='PropertiesChanged',"
       "arg0='xyz.openbmc_project.Sensor.Threshold.Warning'",
       callback);

3. 回調處理
   callback 收到 signal 後：
   - 解析 interface 和 properties
   - 檢查 WarningAlarmHigh 是否為 true
   - 執行對應動作（如：加速風扇、記錄日誌）

4. Redfish EventService
   bmcweb 也訂閱這些 Signal，
   然後透過 SSE 推送給已訂閱的 client
```

---

### Q20：OpenBMC Secure Boot 的實作細節？

**難度**：⭐⭐⭐⭐⭐
**常見於**：NVIDIA / AMD

**問題**：
解釋 AST2600 的 Secure Boot 流程和金鑰管理。

**標準答案**：
```
AST2600 Secure Boot 流程：

啟動順序：
ROM → SPL → U-Boot → Kernel

每個階段驗證下一階段的簽章：
1. ROM 驗證 SPL（ROM 是 ROM-resident，不可修改）
2. SPL 驗證 U-Boot
3. U-Boot 驗證 Kernel + DTB（FIT Image）

金鑰管理：
- OTP 燒錄 Public Key Hash
- Private Key 由廠商（如 Meta）安全保管
- 簽章通常使用 RSA-2048 或 ECDSA

韌體更新時：
1. 新韌體必須用 Private Key 簽章
2. phosphor-software-manager 驗證簽章
3. 驗證通過才寫入 Flash

Recovery 機制：
- UART 強制下載模式
- 需要物理訪問
- 某些設計有 Fallback partition

安全考量：
- OTP 只能寫一次，無法更新
- 需要規劃 Key Revocation 策略
- 考慮 Rollback Protection
```

---

## ✅ 章節完成報告

- 檔案：`/04_OpenBMC深化/架構複習.md`
- 擴充後行數：約 2500+ 行
- 新增內容：
  - ✅ PLDM 協定詳解（類型、MCTP、OpenBMC 整合）
  - ✅ SPDM 協定說明（認證流程、用途）
  - ✅ AST2600 硬體知識（規格、GPIO、I2C Mux）
  - ✅ phosphor-dbus-interfaces 核心 interface
  - ✅ Yocto Build System 深入解析
  - ✅ Sensor Daemon 架構比較（phosphor-hwmon vs dbus-sensors）
  - ✅ D-Bus 進階主題（Object Mapper、Signal 訂閱）
  - ✅ OpenBMC 安全機制（Secure Boot、韌體更新）
  - ✅ 面試題庫擴充至 20 題
