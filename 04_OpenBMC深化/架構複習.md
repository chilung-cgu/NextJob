# 🖥️ OpenBMC 架構複習

> 這是你的優勢！面試時可以深入展示你的專業  
> 本文件針對 **Meta Yosemite 4 平台**（使用 entity-manager）

---

## 📌 從零開始：什麼是 BMC？

### 💡 生活化比喻

```
想像一台伺服器是一棟大樓：

┌─────────────────────────────────────────────────────────────┐
│                        伺服器 = 大樓                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   CPU = 辦公室的員工    RAM = 辦公桌空間   硬碟 = 檔案櫃      │
│   GPU = 專業設備        網路 = 電梯/走道                      │
│                                                             │
│   那誰是「大樓管理員」呢？                                    │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │  BMC = 大樓管理員（Baseboard Management Controller）  │   │
│   │                                                       │   │
│   │  負責：                                               │   │
│   │  ✅ 開關電源（開/關整棟大樓的電）                       │   │
│   │  ✅ 監控溫度（確保冷氣正常、不會過熱）                  │   │
│   │  ✅ 看誰進出（遠端連線管理）                           │   │
│   │  ✅ 處理緊急狀況（當機時遠端復原）                      │   │
│   │  ✅ 記錄事件（誰何時做了什麼）                          │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│   重點：即使大樓（伺服器）停電/當機，                         │
│         管理員（BMC）還是可以獨立運作！                       │
│         因為 BMC 有自己的電源、CPU、記憶體、網路              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 🔧 BMC 的實際硬體

```
┌─────────────────────────────────────────────────────────────┐
│                       BMC 硬體組成                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   BMC 其實是一塊獨立的小電腦，焊在主機板上：                   │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │  BMC SoC（常見廠牌）：                                │   │
│   │  - ASPEED：AST2500、AST2600（最常見！）               │   │
│   │  - Nuvoton：NPCM7xx 系列                             │   │
│   │                                                       │   │
│   │  硬體規格（以 AST2600 為例）：                         │   │
│   │  - CPU：ARM Cortex-A7 雙核心                         │   │
│   │  - RAM：最多 1GB DDR4                                │   │
│   │  - Flash：放 BMC 韌體（通常 32-64MB SPI Flash）       │   │
│   │  - 介面：I2C、SPI、GPIO、UART、網路                   │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                             │
│   💡 你的 I2C/SPI/UART 知識就是用在這裡！                    │
│      BMC 透過這些介面和主機板上的 Sensor/Fan/PSU 溝通        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 📌 OpenBMC 是什麼？

```
OpenBMC 是一個 Linux 基金會的開源專案，用於：
- 伺服器的 Baseboard Management Controller (BMC)
- 提供遠端管理和監控功能
- 替代專有的 BMC 韌體（如 AMI MegaRAC、Insyde H2O）

主要貢獻者：
┌────────────────┬────────────────────────────────────────────┐
│     公司       │                   貢獻重點                  │
├────────────────┼────────────────────────────────────────────┤
│ IBM            │ OpenBMC 創始者，Power 系統                 │
│ Meta/Facebook  │ Yosemite 系列平台（你用的！）              │
│ Google         │ 雲端伺服器                                  │
│ Microsoft      │ Azure 伺服器                               │
│ Intel          │ x86 平台支援                               │
│ AMD            │ EPYC 平台支援                              │
│ NVIDIA         │ GPU 管理、DGX 系統                         │
│ Ampere         │ ARM 伺服器                                 │
└────────────────┴────────────────────────────────────────────┘

💡 你的 OpenBMC 經驗對 NVIDIA/AMD 非常有價值！
   他們正在積極招募有 OpenBMC 經驗的人才！
```

### OpenBMC vs 傳統 BMC 韌體

```
┌────────────────┬────────────────────┬────────────────────┐
│                │    傳統 BMC 韌體    │      OpenBMC       │
├────────────────┼────────────────────┼────────────────────┤
│ 原始碼         │ 封閉、專有          │ 完全開源           │
│ 作業系統       │ 專有 RTOS          │ Linux              │
│ 客製化彈性     │ 低（要找廠商改）    │ 高（自己改）        │
│ 社群支援       │ 無                  │ 活躍的開源社群      │
│ 安全更新       │ 依賴廠商            │ 快速、透明          │
│ 開發工具       │ 專有工具鏈          │ 標準 Linux 工具     │
│ 學習曲線       │ 依廠商文件          │ 有公開文件和範例    │
└────────────────┴────────────────────┴────────────────────┘
```

---

## 🔷 OpenBMC 整體架構

```
┌─────────────────────────────────────────────────────────────┐
│                    OpenBMC 架構                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Management Interfaces               │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌────────┐ │   │
│  │  │ Redfish │  │  IPMI   │  │   SSH   │  │  WebUI │ │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬───┘ │   │
│  └───────┼────────────┼────────────┼────────────┼──────┘   │
│          │            │            │            │           │
│  ┌───────┴────────────┴────────────┴────────────┴──────┐   │
│  │                     D-Bus                            │   │
│  │     (phosphor-dbus-interfaces - 共享 API 定義)       │   │
│  └───────┬────────────┬────────────┬────────────┬──────┘   │
│          │            │            │            │           │
│  ┌───────┴────┐ ┌─────┴─────┐ ┌────┴────┐ ┌────┴────┐     │
│  │ Phosphor   │ │ Phosphor   │ │Phosphor │ │Phosphor │     │
│  │ Inventory  │ │   LED     │ │  Hwmon  │ │ Logging │     │
│  └────────────┘ └───────────┘ └─────────┘ └─────────┘     │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                 Linux Kernel                         │   │
│  │  (Device Drivers, I2C, SPI, GPIO, hwmon, etc.)      │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Hardware                            │   │
│  │  (CPU, GPU, DIMM, PSU, Fan, Sensors, etc.)          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔷 核心元件詳解

### 1. D-Bus（核心中的核心！）

#### 💡 D-Bus 是什麼？生活化比喻

```
想像 OpenBMC 是一間大公司，每個「服務」是一個「部門」：

┌─────────────────────────────────────────────────────────────┐
│                    OpenBMC 公司                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐           │
│  │ 感測器  │ │  電源   │ │  風扇   │ │  日誌   │           │
│  │  部門   │ │  部門   │ │  部門   │ │  部門   │           │
│  │(Hwmon)  │ │ (PSU)   │ │ (Fan)   │ │(Logging)│           │
│  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘           │
│       │          │          │          │                   │
│       └──────────┴──────────┴──────────┘                   │
│                      │                                      │
│              ┌───────┴───────┐                              │
│              │    D-Bus      │  ← 公司的「內部通訊系統」     │
│              │  (Message Bus)│     像是 Email + 電話總機     │
│              └───────────────┘                              │
│                                                             │
│  D-Bus 的功能：                                              │
│  1. 讓部門之間可以互相溝通（不用直接認識對方）                 │
│  2. 可以「廣播」訊息給所有人（例如：溫度太高警報！）           │
│  3. 可以查詢其他部門的狀態（例如：風扇部門，你們轉速多少？）    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 🔑 D-Bus 四大核心概念

```
┌─────────────────────────────────────────────────────────────┐
│  1. Service Name（服務名稱）= 部門名稱                       │
│     └── 例：xyz.openbmc_project.Hwmon                       │
│         類似公司裡的「感測器部門」                            │
├─────────────────────────────────────────────────────────────┤
│  2. Object Path（物件路徑）= 該部門管理的「具體物件」         │
│     └── 例：/xyz/openbmc_project/sensors/temperature/cpu0   │
│         類似「感測器部門管理的 CPU0 溫度計」                  │
├─────────────────────────────────────────────────────────────┤
│  3. Interface（介面）= 這個物件可以做什麼                    │
│     └── 例：xyz.openbmc_project.Sensor.Value                │
│         類似「這個溫度計可以讀取數值」                        │
├─────────────────────────────────────────────────────────────┤
│  4. Property（屬性）= 實際的資料                            │
│     └── 例：Value = 45.5（目前溫度 45.5 度）                 │
│         類似「溫度計顯示的數字」                              │
└─────────────────────────────────────────────────────────────┘

完整例子：
「請問 xyz.openbmc_project.Hwmon 服務（感測器部門），
 /xyz/openbmc_project/sensors/temperature/cpu0（CPU0 溫度計）
 的 xyz.openbmc_project.Sensor.Value（讀數功能）
 的 Value 屬性（實際數值）是多少？」

答：45.5
```

#### 🛠️ 常用 busctl 命令（實戰必備！）

```bash
# 1. 列出所有服務（看公司有哪些部門）
busctl list

# 2. 查看某服務的物件樹（看這個部門管理哪些東西）
busctl tree xyz.openbmc_project.Hwmon

# 輸出範例：
# └─/xyz/openbmc_project/sensors
#   ├─/xyz/openbmc_project/sensors/temperature
#   │ ├─/xyz/openbmc_project/sensors/temperature/cpu0
#   │ └─/xyz/openbmc_project/sensors/temperature/cpu1
#   └─/xyz/openbmc_project/sensors/fan
#     └─/xyz/openbmc_project/sensors/fan/fan0

# 3. 查看物件有哪些介面和屬性
busctl introspect xyz.openbmc_project.Hwmon \
    /xyz/openbmc_project/sensors/temperature/cpu0

# 4. 讀取單一屬性
busctl get-property xyz.openbmc_project.Hwmon \
    /xyz/openbmc_project/sensors/temperature/cpu0 \
    xyz.openbmc_project.Sensor.Value Value

# 輸出：d 45.5  （d = double 型態，值 = 45.5）

# 5. 呼叫方法（例如：開機）
busctl call xyz.openbmc_project.State.Host \
    /xyz/openbmc_project/state/host0 \
    xyz.openbmc_project.State.Host \
    RequestedHostTransition s \
    "xyz.openbmc_project.State.Host.Transition.On"

# 6. 即時監控 D-Bus 訊息（Debug 超好用！）
busctl monitor
```

### 2. phosphor-dbus-interfaces

```
這個 repository 定義了 OpenBMC 的 D-Bus API。

路徑結構：
yaml/
└── xyz/
    └── openbmc_project/
        ├── Sensor/
        │   └── Value.interface.yaml
        ├── State/
        │   ├── Host.interface.yaml
        │   └── Chassis.interface.yaml
        └── Inventory/
            └── Item.interface.yaml

Interface 定義範例：
# xyz/openbmc_project/Sensor/Value.interface.yaml
description: A sensor value
properties:
  - name: Value
    type: double
    description: The sensor value
  - name: Unit
    type: string
    description: The unit of measurement
```

### 3. phosphor-hwmon

```
負責讀取硬體感測器數值。

運作方式：
1. 讀取 Linux hwmon sysfs (/sys/class/hwmon)
2. 將數值透過 D-Bus 發布
3. 提供 Sensor.Value 介面

設定檔位置：
/etc/default/obmc/hwmon/

設定檔範例：
# 48-0048.conf (I2C device at address 0x48)
LABEL_temp1=cpu0_temp
LABEL_temp2=cpu1_temp
```

### 4. Entity-Manager（Meta Yosemite 4 使用這個！）

> ⚠️ 注意：OpenBMC 有兩種硬體管理方式：
> - **phosphor-inventory-manager**：傳統方式，使用靜態 YAML 設定
> - **entity-manager**：現代方式，使用動態 JSON 設定（Yosemite 4 使用這個！）

#### 💡 Entity-Manager vs Inventory-Manager 比較

```
┌────────────────────┬─────────────────────┬─────────────────────┐
│                    │ phosphor-inventory  │   entity-manager    │
│                    │     -manager        │  （你用的！）        │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 設定格式           │ YAML                │ JSON                │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 設定方式           │ 靜態編譯            │ 動態載入            │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 硬體偵測           │ 手動定義            │ 自動探測（Probe）   │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 彈性               │ 較低                │ 較高                │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 適用場景           │ 固定硬體配置        │ 可變硬體配置        │
│                    │                     │ （如多 Slot 系統）  │
├────────────────────┼─────────────────────┼─────────────────────┤
│ 使用廠商           │ IBM                 │ Meta、Intel、Google │
└────────────────────┴─────────────────────┴─────────────────────┘
```

#### 🔧 Entity-Manager 運作原理

```
┌─────────────────────────────────────────────────────────────┐
│                    Entity-Manager 架構                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. JSON 設定檔（定義硬體配置）                               │
│     └── /usr/share/entity-manager/configurations/           │
│         ├── Yosemite4.json                                  │
│         ├── Yosemite4_Slot1.json                            │
│         └── ...                                             │
│                                                             │
│  2. Probe 機制（自動偵測硬體）                                │
│     └── Entity-Manager 會去 I2C/GPIO 探測                   │
│         如果發現符合條件的硬體，就載入對應設定                 │
│                                                             │
│  3. 發布到 D-Bus                                             │
│     └── 偵測到的硬體資訊會發布到 D-Bus                       │
│         其他服務（如 dbus-sensors）會訂閱這些資訊             │
│                                                             │
│  流程圖：                                                    │
│  ┌────────────┐    ┌───────────────┐    ┌─────────────┐     │
│  │ JSON 設定  │───→│ Entity-Manager│───→│   D-Bus     │     │
│  │  (靜態)    │    │  (Probe 偵測) │    │  (發布)     │     │
│  └────────────┘    └───────────────┘    └──────┬──────┘     │
│                                                 │            │
│                                    ┌────────────┴──────┐     │
│                                    ▼                   ▼     │
│                              ┌───────────┐      ┌───────────┐│
│                              │dbus-sensors│     │  Redfish  ││
│                              │ (讀 Sensor)│     │  (API)    ││
│                              └───────────┘      └───────────┘│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

#### 📝 Entity-Manager JSON 設定檔範例

```json
// /usr/share/entity-manager/configurations/Yosemite4_Example.json
{
    "Exposes": [
        {
            "Name": "CPU0 Temperature",
            "Type": "TMP75",           // 使用 TMP75 溫度 Sensor
            "Bus": 2,                   // I2C Bus 2
            "Address": "0x48"           // I2C 地址 0x48
        },
        {
            "Name": "PSU0 Power",
            "Type": "ADM1278",          // 使用 ADM1278 電源管理 IC
            "Bus": 5,
            "Address": "0x10"
        }
    ],
    "Probe": "TRUE",                    // 永遠載入（或可設條件）
    "Name": "Yosemite4 Slot1",
    "Type": "Board"
}
```

#### 🛠️ Entity-Manager Debug 常用命令

```bash
# 查看 Entity-Manager 偵測到哪些硬體
busctl tree xyz.openbmc_project.EntityManager

# 查看某個硬體的詳細設定
busctl introspect xyz.openbmc_project.EntityManager \
    /xyz/openbmc_project/inventory/system/board/Yosemite4_Slot1

# 查看 Entity-Manager 的 Log
journalctl -u xyz.openbmc_project.EntityManager

# 強制重新載入設定（如果改了 JSON）
systemctl restart xyz.openbmc_project.EntityManager
```

#### Meta Yosemite 4 平台相關

```
Yosemite 4 是 Meta 的開放運算平台（OCP），特點：

┌─────────────────────────────────────────────────────────────┐
│                    Yosemite 4 架構                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                  Management Module                   │   │
│  │  (BMC 主控板，運行 OpenBMC)                          │   │
│  └──────────┬──────────┬──────────┬──────────┬─────────┘   │
│             │          │          │          │              │
│       ┌─────┴───┐ ┌────┴────┐ ┌───┴─────┐ ┌─┴───────┐      │
│       │ Slot 1  │ │ Slot 2  │ │ Slot 3  │ │ Slot 4  │      │
│       │(運算卡) │ │(運算卡) │ │(運算卡) │ │(運算卡) │      │
│       └─────────┘ └─────────┘ └─────────┘ └─────────┘      │
│                                                             │
│  每個 Slot 可以放不同類型的運算卡（CPU、GPU、加速器等）       │
│  這就是為什麼需要 Entity-Manager：                           │
│  → 動態偵測每個 Slot 插了什麼卡                              │
│  → 根據不同的卡載入不同的 Sensor 設定                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5. phosphor-logging

```
處理系統日誌和錯誤。

功能：
- 記錄系統事件
- 管理 SEL (System Event Log)
- 透過 Redfish 和 IPMI 提供日誌存取
```

---

## 🔷 管理介面

### IPMI

```
IPMI (Intelligent Platform Management Interface)

常見操作：
# 電源控制
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power on
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power off
ipmitool -I lanplus -H <bmc-ip> -U admin -P password power cycle

# 讀取感測器
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sensor list

# 查看 SEL
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sel list

# SOL (Serial over LAN)
ipmitool -I lanplus -H <bmc-ip> -U admin -P password sol activate
```

### Redfish 深度解析

```
Redfish 是由 DMTF 定義的現代化 Server 管理標準，旨在取代老舊的 IPMI。
如果把 IPMI 比喻成「發電報」，Redfish 就是「滑網頁」。

1. 為什麼需要 Redfish？
   - 安全性：強制使用 HTTPS，支援現代加密標準 (TLS)。
   - 易讀性：使用 JSON 格式，人類可讀 (Human readable)，不再是二進位代碼。
   - 擴充性：標準化的 Schema (CSDL)，不再像 IPMI OEM command 那樣混亂。
   - 雲端友善：RESTful API 設計，非常容易跟現代的雲端管理工具 (Ansible, Terraform) 整合。

2. 核心架構：資源樹三大支柱 (The Big Three)
   Redfish 將伺服器資源分為三大邏輯區塊，這也是 URL 路徑的核心結構：

   /redfish/v1/
    ├── Systems (系統視角 / 邏輯層)
    │    └── /Systems/system
    │        邏輯上的運算資源。包含 CPU 型號、記憶體大小、BIOS 版本、開機順序。
    │        就像是你進 BIOS Setup 會看到的資訊。
    │
    ├── Chassis (機殼視角 / 物理層)
    │    └── /Chassis/chassis
    │        物理上的硬體組件。包含風扇轉速、溫度感測器、PSU 狀態、機殼開啟偵測。
    │        就像是你打開機殼蓋看到的實體零件。
    │
    └── Managers (管理員視角 / BMC層)
         └── /Managers/bmc
             負責管理的 BMC 本身。包含 IP 設定、帳號管理、Serial Console、Logs。

3. 核心精神：自我描述 (Self-describing)
   Redfish 的回應不只是資料，還包含「你可以做什麼」。

   範例：GET /redfish/v1/Systems/system
   
   {
       "@odata.id": "/redfish/v1/Systems/system",
       "PowerState": "On",            <-- 直接告訴你狀態，不用查 Bit map
       "ProcessorSummary": {
           "Count": 2,
           "Model": "Intel(R) Xeon(R) Gold 6248 CPU"
       },
       "Actions": {                   <-- 關鍵！告訴你接下來可以做什麼
           "#ComputerSystem.Reset": {
               "target": "/redfish/v1/Systems/system/Actions/ComputerSystem.Reset"
           }
       }
   }
   
   注意 `Actions` 欄位，它直接引導你「如果想重置系統，請對這個 target URL 發請求」。
   這就是 RESTful 的 Hypermedia 精神 (HATEOAS)。

4. 實務操作指南 (必背！)

   準備工具：curl, Postman, 瀏覽器

   (A) 電源控制 (Power Control) - ★ 面試必考
   使用 POST 方法對 "Actions" 資源發送指令。
   
   # 開機
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "On" }

   # 關機 (Force Off - 拔電源)
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "ForceOff" }

   # 正常關機 (Graceful Shutdown - 通知 OS 關機)
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "GracefulShutdown" }

   (B) 讀取感測器 (Sensors)
   OpenBMC 的 `bmcweb` 會去 D-Bus 撈取 `phosphor-hwmon` 或 `dbus-sensors` 的數值。

   # 讀取特定 Sensor
   GET /redfish/v1/Chassis/chassis/Sensors/CPU0_Temp
   
   {
       "Name": "CPU0 Temp",
       "Reading": 45.0,        <-- 攝氏度
       "ReadingUnits": "Cel"
   }

   (C) 帳號管理
   建立新使用者：
   POST /redfish/v1/AccountService/Accounts
   {
       "UserName": "admin2",
       "Password": "NewPassword123",
       "RoleId": "Administrator"
   }

5. OpenBMC 中的 Redfish 實作架構
   OpenBMC 使用 `bmcweb` (C++ based) 作為 Web Server。
   
   Client (curl) 
      ↓ HTTPS
   bmcweb (Redfish Server)
      ↓ (查詢 Mapper)
   D-Bus (System Bus)
      ↓ (Get Property)
   Backend Services (phosphor-hwmon, phosphor-state-manager...)

   Debug 技巧：
   - 檢查 bmcweb 狀態：`systemctl status bmcweb`
   - 檢查 D-Bus 資料：`busctl get-property ...` (確認後端有資料，如果不通就是介接層問題)
```

---

## 🔷 Build System (Yocto)

```
OpenBMC 使用 Yocto Project 作為 build system。

重要目錄：
poky/              # Yocto 核心
meta-openembedded/ # 社群 layers
meta-phosphor/     # OpenBMC 核心 recipes
meta-xxx/          # 廠商特定的 layer

常用命令：
# 初始化 build 環境
source setup <machine>

# 開始 build
bitbake obmc-phosphor-image

# Build 單一 package
bitbake phosphor-hwmon

# 開發模式
devtool modify phosphor-hwmon
devtool build phosphor-hwmon
devtool reset phosphor-hwmon
```

---

## 📝 面試會問的 OpenBMC 問題

### 🎯 基礎題

**Q1：OpenBMC 的整體架構是什麼？**

```
「OpenBMC 是一個基於 Linux 的開源 BMC 韌體專案，
由 Linux 基金會託管，主要貢獻者包括 IBM、Meta、Google、Intel 等。

整體架構從下到上分為四層：

    ┌─────────────────────────────────────────────────┐
 4. │  Management Interfaces                          │
    │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌───────┐ │
    │  │ Redfish │ │  IPMI   │ │   SSH   │ │ WebUI │ │
    │  └────┬────┘ └────┬────┘ └────┬────┘ └───┬───┘ │
    ├───────┼───────────┼───────────┼──────────┼─────┤
 3. │       └───────────┴───────────┴──────────┘     │
    │              D-Bus (System Bus)                 │
    │  ┌──────────┐ ┌──────────┐ ┌──────────┐        │
    │  │  Hwmon   │ │ Logging  │ │  State   │ ...   │
    │  └────┬─────┘ └────┬─────┘ └────┬─────┘        │
    ├───────┼────────────┼────────────┼──────────────┤
 2. │       └────────────┴────────────┘              │
    │              Linux Kernel                       │
    │  (I2C driver, SPI driver, GPIO, hwmon)         │
    ├────────────────────────────────────────────────┤
 1. │              Hardware                           │
    │  (BMC SoC, Sensors, PSU, Fan, Host CPU)        │
    └────────────────────────────────────────────────┘

核心特點：
1. 使用 D-Bus 作為 IPC 機制，所有服務透過 D-Bus 溝通
2. 使用 systemd 管理服務生命週期
3. 使用 Yocto 作為 build system
4. 各元件高度模組化，可獨立開發和更新

與傳統 BMC 韌體的差異：
- 開源 vs 封閉
- Linux vs 專有 RTOS
- 社群驅動 vs 廠商鎖定」
```

---

**Q2：D-Bus 在 OpenBMC 中扮演什麼角色？**

```
「D-Bus 是 OpenBMC 的核心通訊機制，可以想像成系統的『神經網路』。

D-Bus 的四大功能：

1. 服務發現 (Service Discovery)
   - 服務啟動時向 D-Bus 註冊
   - 其他服務可以動態發現新服務
   - 例如：Entity-Manager 偵測到新硬體後，
     dbus-sensors 可以立即發現並開始讀取

2. 方法呼叫 (Method Call)
   - 類似 RPC (Remote Procedure Call)
   - 例如：Redfish 呼叫 State.Host.RequestedHostTransition 來開機

3. 屬性存取 (Property Access)
   - 透過 Get/Set 讀取和設定狀態
   - 例如：Redfish 讀取 Sensor.Value 取得溫度

4. 信號廣播 (Signal)
   - 事件通知機制，一對多
   - 例如：溫度超過閥值時廣播 ThresholdCritical 信號

為什麼選擇 D-Bus？
- 鬆耦合：服務間不需要直接相依
- 標準化：phosphor-dbus-interfaces 定義統一 API
- 可觀察：用 busctl 可以監控所有通訊，方便 debug
- 語言無關：C++、Python、Go 都可以使用

實際案例：
當使用者透過 Redfish 讀取溫度時：
Redfish → D-Bus get-property → phosphor-hwmon → 回傳數值
```

---

**Q3：請說明 Sensor 資料從硬體到 Redfish API 的完整流程**

```
「這個問題展示你對整體架構的理解。完整流程如下：

1. 硬體層
   ├─ I2C Sensor（如 TMP75）連接在 I2C Bus 上
   └─ Linux hwmon driver 載入，建立 sysfs 節點
      /sys/class/hwmon/hwmon0/temp1_input

2. Kernel 層
   └─ hwmon driver 週期性讀取 I2C 暫存器
      並更新 sysfs 檔案內容（單位通常是 milli-degree）

3. Phosphor 層（兩種方式，視平台而定）

   方式 A：phosphor-hwmon（傳統）
   └─ 讀取 /sys/class/hwmon/*/temp*_input
      透過設定檔定義 Sensor 名稱對應

   方式 B：dbus-sensors + entity-manager（現代，Yosemite 4 使用）
   └─ entity-manager 讀取 JSON 設定，偵測 I2C 裝置
   └─ dbus-sensors 根據設定建立 Sensor 物件

4. D-Bus 層
   └─ Sensor 以 D-Bus 物件發布
      Service: xyz.openbmc_project.HwmonTempSensor
      Object:  /xyz/openbmc_project/sensors/temperature/CPU0_Temp
      Interface: xyz.openbmc_project.Sensor.Value
      Property: Value = 45.5

5. Management 層
   └─ bmcweb (Redfish service) 訂閱 D-Bus
      收到 GET /redfish/v1/Chassis/chassis/Sensors/CPU0_Temp
      → 查詢 D-Bus 取得數值
      → 回傳 JSON：{ "Reading": 45.5, "ReadingUnits": "Cel" }

實際 Debug 方式：
1. cat /sys/class/hwmon/hwmon0/temp1_input  # 確認 kernel 層
2. busctl get-property ... Sensor.Value Value  # 確認 D-Bus 層
3. curl -k https://bmc/redfish/v1/.../Sensors/CPU0_Temp  # 確認 API 層
```

---

### 🎯 進階題（展示深度！）

**Q4：Entity-Manager 和 phosphor-inventory-manager 有什麼差異？你們平台用哪個？**

```
「我們使用的 Meta Yosemite 4 平台是用 entity-manager。
這兩者是 OpenBMC 兩種不同的硬體管理機制：

┌─────────────────┬──────────────────────┬──────────────────────┐
│                 │ phosphor-inventory   │   entity-manager     │
├─────────────────┼──────────────────────┼──────────────────────┤
│ 設定格式        │ YAML                 │ JSON                 │
│ 載入時機        │ 編譯時               │ 執行時               │
│ 硬體偵測        │ 靜態定義             │ 動態 Probe           │
│ 適用場景        │ 固定硬體配置         │ 可變硬體配置         │
│ 代表廠商        │ IBM (Power)          │ Meta, Intel, Google  │
└─────────────────┴──────────────────────┴──────────────────────┘

為什麼 Yosemite 4 選擇 entity-manager？

Yosemite 4 是多 Slot 設計，每個 Slot 可以插不同的運算卡：
- Slot 1 可能是 CPU 卡
- Slot 2 可能是 GPU 卡
- Slot 3 可能是空的

entity-manager 的優勢：
1. Probe 機制可以動態偵測每個 Slot 插了什麼
2. 根據偵測結果載入對應的 Sensor 設定
3. 不需要為每種組合重新編譯韌體

實際運作流程：
1. entity-manager 啟動
2. 讀取 /usr/share/entity-manager/configurations/*.json
3. 執行 Probe 條件（如：檢查 I2C 地址是否有回應）
4. Probe 成功 → 在 D-Bus 發布 Inventory 物件
5. dbus-sensors 訂閱 D-Bus，發現新硬體
6. 建立對應的 Sensor 物件」
```

---

**Q5：IPMI 和 Redfish 的差異？為什麼趨勢是 Redfish？**

```
「這是 BMC 領域的重要議題，我來詳細說明：

┌────────────────┬──────────────────────┬──────────────────────┐
│                │        IPMI          │       Redfish        │
├────────────────┼──────────────────────┼──────────────────────┤
│ 制定組織       │ Intel (已轉移 DMTF)  │ DMTF                 │
│ 協定格式       │ 二進位               │ JSON over HTTPS      │
│ 傳輸方式       │ UDP/LAN, KCS, BT     │ HTTPS (TCP)          │
│ 安全性         │ 較弱*                │ TLS + 認證           │
│ 可讀性         │ 需要解析             │ 人類可讀             │
│ 擴展性         │ OEM Command          │ Schema + OEM         │
│ 學習曲線       │ 陡峭                 │ 較平緩               │
│ 除錯難度       │ 需要特殊工具         │ curl 即可            │
└────────────────┴──────────────────────┴──────────────────────┘

* IPMI 安全性問題：
  - IPMI v1.5 密碼明文傳輸
  - IPMI v2.0 有 RMCP+ 但實作常有漏洞
  - 2013 年發現重大漏洞（cipher 0 問題）

為什麼趨勢是 Redfish？
1. 安全性：基於 HTTPS，符合現代安全標準
2. 雲端整合：JSON 格式易於與雲端管理系統整合
3. 事件訂閱：支援 EventDestination，可主動推送事件
4. 豐富資訊：比 IPMI 能提供更詳細的系統資訊
5. 版本演進：DMTF 仍在積極更新規格

但 IPMI 仍然重要的原因：
1. 向後相容：大量現有工具依賴 IPMI
2. SOL (Serial over LAN)：Redfish 仍不如 IPMI SOL 成熟
3. 某些低階操作：如 BIOS 更新，仍常用 IPMI」
```

---

**Q6：如何 debug 一個『Sensor 讀不到值』的問題？**

```
「這是很實際的問題。我會按照從底層到上層的順序排查：

1. 確認硬體連接
   i2cdetect -y <bus>
   # 確認 Sensor 的 I2C 地址有回應（看到數字而非 --）

2. 確認 Kernel Driver
   dmesg | grep -i hwmon
   ls /sys/class/hwmon/
   # 確認 hwmon 節點有建立

3. 確認 sysfs 數值
   cat /sys/class/hwmon/hwmon*/temp*_input
   # 如果這裡沒值，問題在 driver 層

4. 確認 D-Bus 服務
   systemctl status xyz.openbmc_project.HwmonTempSensor
   journalctl -u xyz.openbmc_project.HwmonTempSensor
   # 看有沒有錯誤訊息

5. 確認 D-Bus 物件
   busctl tree xyz.openbmc_project.HwmonTempSensor
   # 確認 Sensor 物件有建立
   
   busctl get-property xyz.openbmc_project.HwmonTempSensor \
       /xyz/openbmc_project/sensors/temperature/CPU0_Temp \
       xyz.openbmc_project.Sensor.Value Value
   # 確認可以讀到值

6. 確認 Redfish
   curl -k -u root:password \
       https://localhost/redfish/v1/Chassis/chassis/Sensors

常見問題和解法：
┌─────────────────────────┬─────────────────────────────────────┐
│ 現象                    │ 可能原因                            │
├─────────────────────────┼─────────────────────────────────────┤
│ i2cdetect 看不到        │ 1. 接線問題 2. I2C Bus 錯誤         │
├─────────────────────────┼─────────────────────────────────────┤
│ sysfs 沒有節點          │ 1. Driver 沒載入 2. Device Tree 錯  │
├─────────────────────────┼─────────────────────────────────────┤
│ sysfs 有值但 D-Bus 沒有 │ 1. 設定檔錯誤 2. 服務沒啟動         │
├─────────────────────────┼─────────────────────────────────────┤
│ D-Bus 有但 Redfish 沒有 │ 1. bmcweb 設定問題 2. Sensor 命名   │
└─────────────────────────┴─────────────────────────────────────┘
```

---

**Q7：你在 OpenBMC 做過什麼功能？（STAR 框架回答）**

```
這題必須準備！以下是範例框架，你需要填入自己的經驗：

範例一：新增 Sensor 支援
─────────────────────────
Situation：
「我們的 Yosemite 4 平台新增了一款 GPU 運算卡，
上面有新的電源管理 IC (MPS MP2973)，需要讀取功耗資料。」

Task：
「我負責在 OpenBMC 上新增這顆 IC 的 Sensor 支援，
讓使用者可以透過 Redfish 讀取 GPU 功耗。」

Action：
「1. 首先研究 MP2973 的 datasheet，了解 I2C 暫存器定義
 2. 確認現有的 hwmon driver 不支援，需要新增
 3. 在 entity-manager 新增 JSON 設定，定義 I2C Bus 和 Address
 4. 在 dbus-sensors 新增 MPS MP2973 的讀取邏輯
 5. 撰寫單元測試，確保功耗計算公式正確
 6. 在實際硬體上驗證 D-Bus 和 Redfish 都可以正確讀取
 7. 提交 PR，經過 code review 後合併」

Result：
「成功上線，客戶可以透過 Redfish 監控 GPU 功耗，
這個功能也被上游 OpenBMC 接受，貢獻給社群。」

─────────────────────────

範例二：修復 Fan PWM 問題
─────────────────────────
Situation：
「QA 回報風扇轉速控制不穩定，有時候 PWM 設定沒有生效。」

Task：
「Debug 並修復這個問題。」

Action：
「1. 用 busctl monitor 觀察 Fan PWM 的 D-Bus 訊息流
 2. 發現設定 PWM 後，有另一個服務又把它改回去
 3. 追蹤發現是 phosphor-fan-control 的 PID 控制覆蓋了手動設定
 4. 研究 fan-control 的程式碼，發現需要加 Manual Override 機制
 5. 修改程式碼，新增 ManualMode 屬性
 6. 當 ManualMode = true 時，PID 不會覆蓋 PWM」

Result：
「修復後 QA 驗證通過，也發現這是上游的已知問題，
我把修復提交給上游，被接受合併。」
```

---

**Q8：OpenBMC 如何處理 Host 電源狀態管理？**

```
「電源狀態管理是 BMC 的核心功能之一。

狀態機：
┌──────────────────────────────────────────────────────────────┐
│                     Host Power State Machine                  │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│    ┌─────────┐    Power On     ┌──────────┐                 │
│    │   Off   │ ───────────────→│ Running  │                 │
│    └────┬────┘                 └────┬─────┘                 │
│         │                           │                        │
│         │                           │ Power Off / Reboot     │
│         │                           ▼                        │
│         │                      ┌──────────┐                  │
│         │←──────────────────── │ Quiesced │                  │
│         │                      └──────────┘                  │
│                                                              │
└──────────────────────────────────────────────────────────────┘

D-Bus 介面：
- Service: xyz.openbmc_project.State.Host
- Object: /xyz/openbmc_project/state/host0
- Properties:
  - CurrentHostState (Running/Off/Quiesced/...)
  - RequestedHostTransition (On/Off/Reboot/...)

電源控制方式：
1. D-Bus 方法呼叫
   busctl set-property xyz.openbmc_project.State.Host \
       /xyz/openbmc_project/state/host0 \
       xyz.openbmc_project.State.Host \
       RequestedHostTransition s \
       "xyz.openbmc_project.State.Host.Transition.On"

2. Redfish API
   POST /redfish/v1/Systems/system/Actions/ComputerSystem.Reset
   { "ResetType": "On" }

3. IPMI Command
   ipmitool power on

實際電源控制 GPIO：
BMC 通常透過 GPIO 控制電源：
- POWER_BUTTON (GPIO 觸發開機)
- RESET_BUTTON (GPIO 觸發重開)
- POWER_GOOD (GPIO 讀取電源狀態)

這些 GPIO 的定義在 Device Tree 或 Entity-Manager JSON 中」
```

---

### 🎯 實戰題

**Q9：如果要在 OpenBMC 新增一個全新的 I2C Sensor，需要改哪些東西？**

```
「這題考驗你對整個開發流程的理解。

假設要新增一個新的溫度 Sensor IC：ABC1234

需要修改的地方（使用 entity-manager + dbus-sensors）：

1. Linux Kernel Driver（如果 kernel 沒有支援）
   ────────────────────────────────────────────
   位置：Linux kernel 上游或 meta-phosphor/recipes-kernel/
   
   需要寫一個 hwmon driver，或確認現有 driver 支援

2. Entity-Manager JSON 設定
   ────────────────────────
   位置：/usr/share/entity-manager/configurations/
   
   新增或修改 JSON：
   {
       "Exposes": [{
           "Name": "New Sensor",
           "Type": "ABC1234",
           "Bus": 2,
           "Address": "0x48"
       }],
       "Probe": "xyz.openbmc_project.FruDevice({'ADDRESS': 72})"
   }

3. dbus-sensors（如果 dbus-sensors 沒有支援）
   ──────────────────────────────────────────
   位置：openbmc/dbus-sensors
   
   可能需要新增一個 Sensor 類別：
   - 新增 include/ABC1234Sensor.hpp
   - 新增 src/ABC1234Sensor.cpp
   - 修改 CMakeLists.txt

4. Recipe / Meta Layer
   ────────────────────
   如果是廠商特定的，需要在 meta-xxx layer 新增：
   - 設定檔 (JSON)
   - 可能的 patch

開發和驗證步驟：
1. 在實機用 i2cdetect 確認 Sensor 可偵測
2. 編譯包含新 driver 的 kernel
3. 編譯包含新設定的 entity-manager
4. Flash 新韌體
5. 驗證 sysfs → D-Bus → Redfish 都正確
```

---

## ✅ 面試前複習清單

```
核心概念：
☐ 能畫出 OpenBMC 四層架構圖
☐ 能解釋 D-Bus 的四大功能（發現、呼叫、屬性、信號）
☐ 能說明 Sensor 資料從硬體到 Redfish 的完整流程
☐ 知道 IPMI 和 Redfish 的差異及趨勢

技術細節：
☐ 知道 entity-manager vs phosphor-inventory-manager 差異
☐ 能解釋 entity-manager 的 Probe 機制
☐ 知道 phosphor-hwmon vs dbus-sensors 的差異
☐ 會使用 busctl 查詢和監控 D-Bus

實作經驗：
☐ 準備好 2-3 個自己做過的功能案例（用 STAR 框架）
☐ 能說明 Debug Sensor 問題的步驟
☐ 知道新增 Sensor 需要改哪些檔案

Build 相關：
☐ 知道 Yocto build system 基本操作
☐ 知道 meta-layer 的結構和用途
☐ 會使用 devtool 進行開發

加分項目：
☐ 有貢獻過上游程式碼
☐ 了解 phosphor-dbus-interfaces 的角色
☐ 知道電源狀態管理的狀態機
```
