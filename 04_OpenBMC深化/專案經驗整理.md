# 🎤 專案經驗整理指南

> 面試時最重要的就是能講出你做過的事！這份指南幫你包裝經驗  
> 針對 NVIDIA / AMD / Intel / Meta 等外商 BMC 韌體職位準備

---

## 📌 STAR 法則

```
面試回答專案問題時，使用 STAR 法則：

S - Situation（情境）：背景是什麼？
T - Task（任務）：你負責什麼？
A - Action（行動）：你做了什麼具體的事？
R - Result（結果）：結果如何？學到什麼？

注意：
- 每個部分都要有具體細節
- 避免過於籠統的描述
- 量化成果更有說服力
```

---

## 🔷 專案經驗範例（完整版）

> 以下提供 10 個詳細的專案經驗範例，涵蓋 BMC 工程師常見的工作場景

---

### 範例 1：PLDM Sensor 開發與整合

**Situation（情境）：**
```
在 Meta Yosemite 4 專案中，需要支援 8 張 NVIDIA H100 GPU 的監控。
這些 GPU 透過 PLDM over MCTP (I2C) 與 BMC 通訊。
傳統的 IPMI Sensor 機制無法滿足需求，必須使用 PLDM Type 2 協定。
```

**Task（任務）：**
```
負責開發 PLDM Sensor 整合方案：
1. 與 GPU 建立 PLDM 通訊
2. 解析 PDR (Platform Descriptor Records)
3. 將 Sensor 數據發布到 D-Bus
4. 確保 Redfish API 正確曝露 GPU 資訊
```

**Action（行動）：**
```
1. 研究 PLDM 規範
   - 閱讀 DSP0248 (PLDM for Platform Monitoring)
   - 分析現有 pldmd 程式碼架構
   - 與 NVIDIA 工程師確認 PDR 格式

2. 實作 MCTP 通訊
   - 在 device tree 新增 I2C MCTP binding
   - 設定 mctp-i2c kernel driver
   - 使用 mctp-tool 驗證基本通訊

3. PDR 解析與 Sensor 建立
   - 實作 PDR repository 解析邏輯
   - 動態建立 D-Bus Sensor 物件
   - 處理 Compact Numeric Sensor PDR

4. 處理 Threshold 和 Event
   - 從 PDR 讀取 Warning/Critical 閾值
   - 實作 Event 通知機制
   - 與 phosphor-sel-logger 整合

困難與解決：
- 問題：PDR 格式與規範有差異
  解決：與 NVIDIA 開會確認，更新解析邏輯
  
- 問題：多 GPU 同時輪詢導致 I2C 擁塞
  解決：實作非同步請求和 request 排隊機制
```

**Result（結果）：**
```
量化成果：
- 成功支援 8 張 GPU 的 32 個 Sensor（溫度、功率、利用率）
- Sensor 更新頻率達到 1 秒，滿足客戶需求
- 程式碼合併到 OpenBMC upstream

學習與貢獻：
- 深入理解 PLDM 協定架構
- 撰寫 PLDM Sensor 開發指南
- 成為團隊 PLDM 技術 owner
```

**涉及技術：**
```
- Protocols: PLDM Type 2, MCTP, I2C
- OpenBMC: pldmd, sdbusplus, entity-manager
- Tools: mctp-tool, pldmtool, busctl
- Languages: C++17, Python
```

---

### 範例 2：Redfish EventService SSE 實作

**Situation（情境）：**
```
客戶要求即時接收 BMC 事件通知（溫度告警、電源狀態變化等），
原本的 Webhook 機制延遲太高（平均 500ms），
需要實作 Server-Sent Events (SSE) 提供即時推送。
```

**Task（任務）：**
```
在 bmcweb 中實作 Redfish EventService 的 SSE 功能：
1. 實作 SSE 連線管理
2. 訂閱 D-Bus Signal
3. 將事件轉換為 Redfish Event 格式
4. 處理連線中斷和重連
```

**Action（行動）：**
```
1. 研究 SSE 規範和 Redfish EventService
   - 閱讀 HTML5 EventSource 規範
   - 分析 Redfish Event Schema
   - 研究 bmcweb 現有架構

2. 實作 SSE Handler
   - 使用 Boost.Beast 建立長連接
   - 設定 "text/event-stream" Content-Type
   - 實作 keep-alive 心跳機制

3. D-Bus Signal 訂閱
   - 使用 sdbusplus match rules
   - 訂閱 PropertiesChanged Signal
   - 過濾 Registry prefix

4. 事件格式化與推送
   - 將 D-Bus 訊息轉換為 Redfish Event
   - 加入 MessageId、Severity、Timestamp
   - 使用 nlohmann::json 序列化

5. 測試與驗證
   - 使用 curl 測試 SSE 連線
   - 觸發 Sensor 告警驗證推送
   - 壓測多連線情境

困難與解決：
- 問題：連線中斷後 D-Bus match 未清理，導致 memory leak
  解決：使用 shared_ptr weak reference 追蹤連線狀態
  
- 問題：高頻事件導致 client buffer overflow
  解決：實作 event coalescing 機制
```

**Result（結果）：**
```
量化成果：
- 事件通知延遲從 500ms 降低到 10ms
- 支援同時 50 個 SSE 連線
- 通過 Redfish Service Validator 驗證

貢獻：
- 程式碼合併到 bmcweb upstream
- 撰寫 SSE 使用文件
```

**涉及技術：**
```
- Protocols: HTTP/1.1 SSE, Redfish
- Libraries: Boost.Beast, nlohmann::json
- OpenBMC: bmcweb, sdbusplus
- Languages: C++17
```

---

### 範例 3：AST2600 Secure Boot 實作

**Situation（情境）：**
```
資料中心客戶要求 BMC 必須啟用 Secure Boot，
確保韌體從 Boot ROM 到 Linux Kernel 每個階段都經過驗證，
防止供應鏈攻擊和惡意韌體注入。
```

**Task（任務）：**
```
在 AST2600 平台實作完整的 Secure Boot chain：
1. 設計金鑰管理流程
2. 配置 U-Boot verified boot
3. 實作 FIT image 簽章
4. 處理 OTP 燒錄流程
```

**Action（行動）：**
```
1. 金鑰基礎建設
   - 設計三層金鑰結構（Root → Signing → Image）
   - 使用 OpenSSL 產生 RSA-4096 金鑰對
   - 建立金鑰保管的 SOP

2. U-Boot 驗證啟動配置
   - 啟用 CONFIG_FIT_SIGNATURE
   - 設定 required-keys 和 signature 節點
   - 整合 SPL 驗證機制

3. FIT Image 簽章流程
   - 修改 Yocto recipe 加入簽章步驟
   - 使用 mkimage 的 -K 和 -k 選項
   - 驗證簽章鏈

4. OTP 燒錄
   - 研究 AST2600 OTP 結構
   - 撰寫 Public Key Hash 計算腳本
   - 設計 Production 燒錄流程

5. Recovery 機制
   - 設計 Fail-safe 更新流程
   - 實作雙分區（A/B）機制
   - 測試各種失敗情境

困難與解決：
- 問題：OTP 燒錄後無法回復，測試困難
  解決：使用 ASPEED 的 strap 模式進行開發測試
  
- 問題：簽章驗證增加開機時間
  解決：優化驗證演算法，使用硬體加速器
```

**Result（結果）：**
```
量化成果：
- 完成 Root of Trust 到 Kernel 的完整驗證鏈
- 通過客戶安全審計
- 開機時間增加控制在 5 秒內

貢獻：
- 建立公司 Secure Boot 標準流程
- 撰寫完整的安全白皮書
- 專利申請中
```

**涉及技術：**
```
- Security: Secure Boot, PKI, RSA-4096, SHA-512
- Hardware: AST2600 OTP, Hardware Crypto Engine
- Bootloader: U-Boot, SPL, FIT Image
- Tools: OpenSSL, mkimage
```

---

### 範例 4：I2C 問題除錯（生產線問題）

**Situation（情境）：**
```
生產線回報 5% 的板子 BMC 無法讀取 DIMM 溫度，
造成生產進度嚴重落後。
問題具有隨機性，增加除錯難度。
```

**Task（任務）：**
```
快速定位問題根因，提供解決方案，
儘快讓生產線恢復運作。
```

**Action（行動）：**
```
1. 問題確認與範圍
   - 遠端登入問題機器
   - 確認只有 DIMM SPD 無法讀取
   - 其他 I2C 設備正常

2. 軟體層除錯
   - i2cdetect 顯示 SPD 地址有回應
   - i2cget 讀取 timeout
   - dmesg 顯示 "i2c transfer timeout"

3. 硬體層除錯
   - 到生產線現場
   - 示波器量測 I2C 波形
   - 發現 clock stretching 過長（>50ms）

4. 根因分析
   - 這批 DIMM 是新供應商
   - Datasheet 標示 clock stretch 最大 100ms
   - BMC I2C driver timeout 只有 35ms

5. 解決方案
   - 短期：增加 I2C timeout 到 150ms
   - 長期：與 DIMM 供應商協商規格

6. 驗證與回歸
   - 修改 device tree i2c-timeout-ms
   - 重新測試所有問題機器
   - 確認問題解決

困難與解決：
- 問題：問題有隨機性，難以穩定重現
  解決：收集多台機器的 I2C 波形，發現規律
```

**Result（結果）：**
```
量化成果：
- 問題在 48 小時內解決
- 生產線恢復運作
- 零客訴

貢獻：
- 建立 I2C 除錯 SOP
- 新增 I2C 驗收自動化測試
- 更新 DIMM 供應商驗收標準
```

**涉及技術：**
```
- Protocols: I2C, SMBus
- Tools: i2c-tools, 示波器
- Debug: dmesg, journalctl
- Hardware: 訊號分析
```

---

### 範例 5：BMC 開機效能優化

**Situation（情境）：**
```
客戶要求 BMC 開機時間不超過 60 秒，
但實測達到 95 秒無法接受。
這影響了伺服器的快速部署能力。
```

**Task（任務）：**
```
分析開機流程，找出瓶頸，
將開機時間優化到 60 秒以內。
```

**Action（行動）：**
```
1. 效能分析
   - systemd-analyze blame 列出最慢服務
   - systemd-analyze critical-chain 看關鍵路徑
   - bootchart 產生可視化圖表

2. 識別主要瓶頸
   瓶頸列表（按影響排序）：
   - phosphor-hwmon-readall: 25 秒
   - phosphor-image-signing: 12 秒
   - obmc-console@xxx: 8 秒
   - entity-manager: 7 秒

3. 優化措施

   phosphor-hwmon-readall (25s → 5s)：
   - 改為平行初始化多個 hwmon device
   - 延遲非關鍵 sensor 的首次讀取
   
   phosphor-image-signing (12s → 3s)：
   - 優化 RSA 驗證使用硬體加速
   - 快取驗證結果
   
   obmc-console (8s → 2s)：
   - 調整 SOL 初始化順序
   - 使用 socket activation
   
   entity-manager (7s → 3s)：
   - 精簡 JSON 配置檔
   - 優化 D-Bus 查詢

4. 系統層優化
   - 調整 udev rules 減少設備掃描
   - 禁用不需要的 kernel modules
   - 使用 meson 的 LTO 優化

5. 建立效能回歸測試
   - 自動化開機時間測量
   - PR 自動檢查效能影響

困難與解決：
- 問題：某些優化影響功能正確性
  解決：建立完整的功能回歸測試
```

**Result（結果）：**
```
量化成果：
- 開機時間從 95 秒降到 48 秒
- 超越客戶要求（60秒）
- 效能提升 49%

貢獻：
- 建立開機效能監控機制
- 撰寫效能優化最佳實踐文件
- 部分優化合併到 upstream
```

**涉及技術：**
```
- Tools: systemd-analyze, bootchart, perf
- Optimization: systemd socket activation, parallel init
- Build: meson, LTO
```

---

### 範例 6：SPDM 設備認證整合

**Situation（情境）：**
```
為了符合資料中心安全合規要求，
BMC 需要在開機時驗證所有 PCIe 設備（GPU、NIC）的身份，
確認設備未被竄改或替換。
```

**Task（任務）：**
```
整合 SPDM 協定到 OpenBMC：
1. 實作 SPDM Requester
2. 與各設備進行認證
3. 將認證結果報告給管理系統
```

**Action（行動）：**
```
1. 研究 SPDM 協定
   - 閱讀 DSP0274 規範
   - 研究 libspdm 開源實作
   - 與設備廠商確認支援版本

2. 整合 libspdm
   - 將 libspdm 打包為 Yocto recipe
   - 實作 MCTP transport layer
   - 建立 spdmd daemon

3. 認證流程實作
   - GET_VERSION → GET_CAPABILITIES
   - NEGOTIATE_ALGORITHMS
   - GET_CERTIFICATE → CHALLENGE

4. 憑證驗證
   - 整合 OpenSSL 驗證 certificate chain
   - Root CA 儲存在 BMC 安全區域
   - 處理 certificate revocation

5. Measurement 驗證
   - 請求 device firmware measurement
   - 比對 golden image hash
   - 不符則產生安全事件

6. 整合 Redfish
   - 新增 /redfish/v1/ComponentIntegrity
   - 報告各設備認證狀態
   - 支援重新認證 Action

困難與解決：
- 問題：不同廠商的 SPDM 實作有差異
  解決：建立設備相容性矩陣，逐一調適
  
- 問題：認證失敗時的處理策略
  解決：設計 policy-based 處理（log / alert / block）
```

**Result（結果）：**
```
量化成果：
- 支援 5 種不同廠商的設備認證
- 認證流程 < 2 秒完成
- 通過安全審計

貢獻：
- 成為公司 SPDM 專家
- 與設備廠商建立技術合作關係
```

**涉及技術：**
```
- Security: SPDM 1.2, PKI, X.509
- Libraries: libspdm, OpenSSL
- Protocols: MCTP over PCIe VDM
```

---

### 範例 7：entity-manager 動態硬體配置

**Situation（情境）：**
```
專案需要支援 10 種 I/O 擴充卡的熱插拔，
每種卡有不同的 Sensor 配置。
傳統的靜態配置方式無法滿足需求。
```

**Task（任務）：**
```
設計動態硬體配置方案：
1. 自動偵測擴充卡類型
2. 動態載入對應的 Sensor 配置
3. 處理熱插拔事件
```

**Action（行動）：**
```
1. 設計 FRU 偵測機制
   - 使用 fru-device daemon 讀取 FRU EEPROM
   - 解析 PRODUCT_NAME 識別卡片類型
   - 發布 FRU 資訊到 D-Bus

2. 撰寫 entity-manager JSON 配置
   每種卡片一個 JSON 檔：
   {
     "Name": "GPU Riser Card A",
     "Probe": "xyz.openbmc_project.FruDevice({'PRODUCT': '.*GPU_RISER_A.*'})",
     "Exposes": [
       {
         "Type": "TMP75",
         "Name": "Riser$INDEX Inlet Temp",
         "Address": "0x48",
         "Bus": "$bus"
       },
       {
         "Type": "ADC128D818",
         "Name": "Riser$INDEX Voltage",
         "Address": "0x35",
         "Bus": "$bus"
       }
     ]
   }

3. 處理熱插拔
   - 監聽 InterfacesAdded / InterfacesRemoved
   - 動態建立/移除 Sensor 物件
   - 更新 Redfish Chassis

4. 測試與驗證
   - 實機測試 10 種 I/O 卡
   - 熱插拔壓力測試
   - 確認 Redfish 資源正確更新

困難與解決：
- 問題：某些 I/O 卡的 FRU 格式不標準
  解決：與硬體團隊協調統一 FRU 格式
  
- 問題：熱插拔時 I2C Bus 可能不穩
  解決：加入重試機制和錯誤處理
```

**Result（結果）：**
```
量化成果：
- 成功支援 10 種 I/O 卡，無需重編譯
- 熱插拔偵測 < 3 秒
- 配置維護時間減少 80%

貢獻：
- 建立 I/O 卡配置的標準流程
- 撰寫 entity-manager 使用指南
```

**涉及技術：**
```
- OpenBMC: entity-manager, fru-device, dbus-sensors
- Data: JSON, FRU IPMI format
- Protocols: I2C, EEPROM
```

---

### 範例 8：OEM IPMI Command 開發

**Situation（情境）：**
```
客戶需要透過 IPMI 讀取 BMC 特有的診斷資訊，
包括：硬體版本、電壓校正值、生產追溯碼等。
這些資訊標準 IPMI 沒有定義。
```

**Task（任務）：**
```
設計並實作一套 OEM IPMI Commands：
1. 定義 OEM NetFn 和 Command Code
2. 實作 handlers
3. 撰寫客戶文件
```

**Action（行動）：**
```
1. 需求分析與設計
   - 與客戶確認需要的資訊
   - 設計 Command 結構（Request/Response）
   - 決定 NetFn = 0x30 (OEM)

2. Command 定義
   OEM Commands：
   - 0x01: Get Platform Info（硬體版本、序號）
   - 0x02: Get Calibration Data（電壓校正值）
   - 0x03: Get Manufacturing Info（生產追溯）
   - 0x10: Set LED Pattern（燈號控制）
   - 0x20: Trigger Diagnostic（診斷模式）

3. 實作 IPMI Handlers
   // src/oemcmds.cpp
   ipmi::RspType<...> ipmiOemGetPlatformInfo(...) {
       // 讀取 EEPROM 資料
       // 格式化回應
   }

4. 整合 phosphor-ipmi-host
   - 註冊 OEM handlers
   - 處理權限檢查
   - 錯誤碼定義

5. 測試與文件
   - ipmitool raw 測試
   - 撰寫完整 API 文件
   - 提供 Python 範例程式

困難與解決：
- 問題：某些資料需要跨 daemon 取得
  解決：透過 D-Bus 呼叫其他服務
```

**Result（結果）：**
```
量化成果：
- 實作 8 個 OEM Commands
- 100% 測試覆蓋率
- 客戶工具整合成功

貢獻：
- 建立 OEM Command 開發範本
- 撰寫完整的 API 文件
```

**涉及技術：**
```
- Protocols: IPMI, OEM Extension
- OpenBMC: phosphor-ipmi-host, ipmid
- Languages: C++17
- Tools: ipmitool
```

---

### 範例 9：Fan Control Algorithm 優化

**Situation（情境）：**
```
現有風扇控制邏輯過於簡單（線性），
導致兩個問題：
1. 高負載時散熱不足
2. 低負載時風扇噪音過大
```

**Task（任務）：**
```
優化風扇控制演算法：
1. 改善散熱效果
2. 降低噪音
3. 平衡能源消耗
```

**Action（行動）：**
```
1. 收集數據
   - 記錄不同負載下的溫度曲線
   - 測量各風扇轉速對溫度的影響
   - 測量噪音水平

2. 設計新演算法
   - 改用 PID 控制器
   - 針對不同 zone 設定不同參數
   - 加入斜率限制避免急劇變化

3. 實作與整合
   - 修改 phosphor-fan-presence
   - 實作 pid-config JSON 配置
   - 與 dbus-sensors 整合

4. 測試與調參
   - 熱室測試（40°C 環境）
   - 調整 PID 參數（P=2.0, I=0.1, D=0.5）
   - 壓力測試驗證穩定性

5. 噪音測量
   - 使用噪音計測量各場景
   - 與舊版比較改善幅度

困難與解決：
- 問題：PID 參數調整耗時
  解決：撰寫自動調參腳本
  
- 問題：某些極端場景過熱
  解決：加入緊急風扇全速邏輯
```

**Result（結果）：**
```
量化成果：
- 高負載溫度降低 5°C
- 低負載噪音降低 8 dB
- 風扇壽命預計延長 15%（減少 PWM 變化）

貢獻：
- 撰寫 Fan Control 調參指南
- 分享演算法設計到社群
```

**涉及技術：**
```
- Algorithms: PID Control
- OpenBMC: phosphor-pid-control, dbus-sensors
- Testing: 熱室, 噪音計
```

---

### 範例 10：GPIO 與 Power Sequencing

**Situation（情境）：**
```
新主機板的電源時序與舊版不同，
需要修改 BMC 的 GPIO 控制順序，
否則會導致開機失敗或損壞硬體。
```

**Task（任務）：**
```
實作新的 Power Sequencing 邏輯：
1. 分析電源時序圖
2. 修改 GPIO 控制程式
3. 確保可靠性和安全性
```

**Action（行動）：**
```
1. 時序分析
   - 分析硬體電源時序圖
   - 識別各電壓軌的相依關係
   - 確認 delay 和 hold 時間

2. GPIO 配置
   - 更新 device tree gpio-line-names
   - 確認 GPIO 方向和預設值
   - 設定 open-drain 等屬性

3. Power Sequencing 實作
   電源開啟順序：
   1. 3.3V_AUX → wait 10ms
   2. 5V_AUX → wait 10ms
   3. VR_EN → wait 50ms
   4. CPU_PWRGD 確認 → wait 100ms
   5. 釋放 CPU reset

4. 整合 phosphor-state-manager
   - 修改 chassis-poweron target
   - 實作 PowerControl service
   - 加入錯誤處理

5. 安全機制
   - 電源失敗時的緊急關機
   - 過流保護觸發處理
   - 開機 timeout 機制

6. 測試驗證
   - 電源壓力測試（1000 次開關機）
   - Fault injection 測試
   - 量測實際時序

困難與解決：
- 問題：某些 GPIO 在開機瞬間有毛刺
  解決：加入 debounce 和硬體濾波器
```

**Result（結果）：**
```
量化成果：
- Power cycle 測試 10000 次無失敗
- 相容 3 種不同的主機板版本
- 開機成功率 100%

貢獻：
- 建立 Power Sequencing 設計規範
- 撰寫測試 checklist
```

**涉及技術：**
```
- Hardware: GPIO, Power Sequencing
- OpenBMC: phosphor-state-manager, gpiod
- Testing: Power cycle, Fault injection
```

---

## 📝 面試深入問題準備

面試官可能問的追問問題：

### 技術深度問題

```
1. 這個功能用了哪些技術/API？
   → 準備技術棧清單和關鍵程式碼片段

2. 為什麼選擇這個方案而不是其他？
   → 準備替代方案比較表
   → 說明 trade-off 分析

3. 遇到什麼困難？怎麼解決的？
   → 準備 2-3 個具體例子
   → 包含除錯過程和工具使用

4. 如果重做一次，會有什麼改進？
   → 展示反思能力
   → 可提 performance, maintainability, testability

5. 這個功能的性能/品質如何保證？
   → 說明測試方法
   → 提供具體數據
```

### 合作溝通問題

```
1. 你和誰一起做這個專案？
   → 說明團隊結構（BMC team, HW team, 客戶）

2. 如何分工？
   → 展示專案管理能力

3. 有沒有和其他團隊溝通？
   → 跨團隊協作經驗很加分

4. 遇到意見不同怎麼處理？
   → 展示溝通技巧和妥協能力
```

### 學習成長問題

```
1. 從這個專案學到什麼？
   → 技術、流程、軟技能

2. 有什麼失敗的經驗嗎？
   → 誠實回答 + 學到的教訓

3. 如果再做一次會怎麼做？
   → 展示持續改進的心態
```

---

## ✅ 你的專案整理（模板）

請根據範例填寫以下模板，準備 2-3 個專案：

### 專案 A：________________

| 項目 | 內容 |
|-----|------|
| 情境 | （背景和問題）|
| 任務 | （你負責什麼）|
| 行動（1-3 點）| （具體做了什麼）|
| 困難和解決方法 | （技術難點）|
| 結果和學習 | （量化成果）|
| 涉及技術 | （技術關鍵字）|

### 專案 B：________________

| 項目 | 內容 |
|-----|------|
| 情境 | |
| 任務 | |
| 行動（1-3 點）| |
| 困難和解決方法 | |
| 結果和學習 | |
| 涉及技術 | |

### 專案 C：________________

| 項目 | 內容 |
|-----|------|
| 情境 | |
| 任務 | |
| 行動（1-3 點）| |
| 困難和解決方法 | |
| 結果和學習 | |
| 涉及技術 | |

---

## 💡 包裝技巧

```
1. 量化成果
   ❌ 「系統變快了」
   ✅ 「開機時間從 95 秒降到 48 秒，效能提升 49%」

2. 技術關鍵字
   ❌ 「寫了一些程式」
   ✅ 「使用 C++17 實作 PLDM Type 2 Sensor daemon」

3. 問題解決過程
   ❌ 「花了一些時間解決」
   ✅ 「使用示波器分析 I2C 波形，發現 clock stretching 過長」

4. 展示影響力
   ❌ 「程式碼寫好了」
   ✅ 「程式碼合併到 OpenBMC upstream，被 3 個廠商採用」

5. 團隊合作
   ❌ 「自己完成」
   ✅ 「與 NVIDIA 工程師合作，協調 PDR 格式規範」

6. 持續學習
   ❌ 「完成功能」
   ✅ 「撰寫技術文件，成為團隊 PLDM 技術 owner」
```

---

## 🎯 面試前檢查清單

```
□ 準備 3 個詳細的專案經驗（STAR 格式）
□ 每個專案都有量化的成果
□ 每個專案都能深入講技術細節
□ 每個專案都有「困難與解決」的故事
□ 準備好英文版的專案描述
□ 練習 2 分鐘簡短版和 10 分鐘詳細版
□ 準備可能的追問問題答案
□ 對專案涉及的技術要能畫架構圖
```

---

## ✅ 章節完成報告

- 檔案：`/04_OpenBMC深化/專案經驗整理.md`
- 擴充後行數：約 900 行
- 新增內容：
  - ✅ 10 個完整的專案經驗範例
  - ✅ 涵蓋 PLDM、Redfish、Secure Boot、I2C Debug 等場景
  - ✅ 每個範例都包含完整 STAR 結構
  - ✅ 面試深入問題準備指南
  - ✅ 包裝技巧與面試前檢查清單
