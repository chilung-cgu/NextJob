# ğŸ’¾ Linux è¨˜æ†¶é«”ç®¡ç†å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£è™›æ“¬è¨˜æ†¶é«”çš„è¨­è¨ˆåŸç†èˆ‡å¿…è¦æ€§
> 2. æŒæ¡ MMU/TLB çš„ç¡¬é«”æ¶æ§‹èˆ‡é‹ä½œæ©Ÿåˆ¶
> 3. ç²¾é€š ARM64 å››ç´šé è¡¨çµæ§‹ (PGD/PUD/PMD/PTE)
> 4. ç†è§£ Page Fault è™•ç†æµç¨‹èˆ‡ COW æ©Ÿåˆ¶
> 5. æŒæ¡ OOM Killer çš„è©•åˆ†æ©Ÿåˆ¶èˆ‡èª¿æ ¡æ–¹æ³•
> 6. ç†Ÿç·´ Memory Barrier çš„ä½¿ç”¨å ´æ™¯

---

## ğŸ”· ç¬¬ä¸€éƒ¨åˆ†ï¼šè™›æ“¬è¨˜æ†¶é«”åŸºç¤

### 1.1 ç‚ºä»€éº¼éœ€è¦è™›æ“¬è¨˜æ†¶é«”ï¼Ÿ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ²’æœ‰è™›æ“¬è¨˜æ†¶é«”çš„å•é¡Œ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  å•é¡Œ 1ï¼šç¨‹å¼å¿…é ˆçŸ¥é“è‡ªå·±è¢«è¼‰å…¥åˆ°å“ªå€‹å¯¦é«”ä½å€                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”‚
â”‚  - ç·¨è­¯æ™‚å°±è¦æ±ºå®šè¼‰å…¥ä½å€                                      â”‚
â”‚  - ä¸åŒç¨‹å¼å¯èƒ½è¡çª                                           â”‚
â”‚  - ç„¡æ³•å‹•æ…‹è¼‰å…¥                                               â”‚
â”‚                                                              â”‚
â”‚  å•é¡Œ 2ï¼šè¨˜æ†¶é«”ä¿è­·å›°é›£                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
â”‚  - Process A å¯ä»¥ç›´æ¥å­˜å– Process B çš„è¨˜æ†¶é«”                  â”‚
â”‚  - æƒ¡æ„ç¨‹å¼å¯ä»¥ç ´å£ç³»çµ±                                        â”‚
â”‚  - Debug å›°é›£ï¼ˆèª°æ”¹äº†é€™å¡Šè¨˜æ†¶é«”ï¼Ÿï¼‰                            â”‚
â”‚                                                              â”‚
â”‚  å•é¡Œ 3ï¼šè¨˜æ†¶é«”ç¢ç‰‡åŒ–                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  - é€£çºŒé…ç½®é€ æˆå¤–éƒ¨ç¢ç‰‡                                        â”‚
â”‚  - ç„¡æ³•æœ‰æ•ˆåˆ©ç”¨è¨˜æ†¶é«”                                          â”‚
â”‚                                                              â”‚
â”‚  å•é¡Œ 4ï¼šå¯¦é«”è¨˜æ†¶é«”é™åˆ¶                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                        â”‚
â”‚  - ç¨‹å¼å¤§å°å—é™æ–¼ RAM å®¹é‡                                    â”‚
â”‚  - ç„¡æ³•åŸ·è¡Œæ¯” RAM æ›´å¤§çš„ç¨‹å¼                                  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 è™›æ“¬è¨˜æ†¶é«”çš„è§£æ±ºæ–¹æ¡ˆ

```c
/* è™›æ“¬è¨˜æ†¶é«”æä¾›çš„æŠ½è±¡å±¤ */

/*
 * æ¯å€‹ Process çœ‹åˆ°çš„è¨˜æ†¶é«”ç©ºé–“ï¼š
 * 
 * 0xFFFFFFFFFFFFFFFF â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *                    â”‚   Kernel Space  â”‚  â† æ‰€æœ‰ Process å…±äº«
 *                    â”‚   (é«˜ä½å€)       â”‚
 * 0xFFFF800000000000 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† ARM64 å…¸å‹åˆ†ç•Œ
 *                    â”‚                 â”‚
 *                    â”‚   User Space    â”‚  â† æ¯å€‹ Process ç¨ç«‹
 *                    â”‚                 â”‚
 *                    â”‚   Stack â†“       â”‚
 *                    â”‚                 â”‚
 *                    â”‚   â†‘ Heap        â”‚
 *                    â”‚   Data          â”‚
 *                    â”‚   Text (Code)   â”‚
 * 0x0000000000000000 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

/* é—œéµæ¦‚å¿µï¼šä½å€è½‰æ› */
/*
 * Virtual Address (VA) â†’ MMU â†’ Physical Address (PA)
 * 
 * Process A: VA 0x1000 â†’ PA 0x80001000
 * Process B: VA 0x1000 â†’ PA 0x90001000
 * 
 * å…©å€‹ Process ä½¿ç”¨ç›¸åŒçš„ VAï¼Œä½†å°æ‡‰åˆ°ä¸åŒçš„ PAï¼
 */
```

### 1.3 Linux è™›æ“¬è¨˜æ†¶é«”ä½ˆå±€ (ARM64)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Linux ARM64 è™›æ“¬è¨˜æ†¶é«”ä½ˆå±€ (4KB Page)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  0xFFFFFFFFFFFFFFFF â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚                     â”‚  Fixmap                    â”‚           â”‚
â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚                     â”‚  PCI I/O                   â”‚           â”‚
â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚                     â”‚  vmemmap (struct page[])   â”‚           â”‚
â”‚                     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚                     â”‚  vmalloc/ioremap           â”‚           â”‚
â”‚  0xFFFF000000000000 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚
â”‚                     â”‚  Linear Mapping            â”‚           â”‚
â”‚                     â”‚  (ç›´æ¥æ˜ å°„æ‰€æœ‰å¯¦é«”è¨˜æ†¶é«”)    â”‚           â”‚
â”‚  0xFFFF800000000000 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â† PAGE_OFFSETâ”‚
â”‚                     â”‚                            â”‚           â”‚
â”‚                     â”‚      Kernel Space          â”‚           â”‚
â”‚                     â”‚         256TB              â”‚           â”‚
â”‚                     â”‚                            â”‚           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â”‚
â”‚                     â”‚                            â”‚           â”‚
â”‚                     â”‚      User Space            â”‚           â”‚
â”‚                     â”‚         256TB              â”‚           â”‚
â”‚                     â”‚                            â”‚           â”‚
â”‚  0x0000000000000000 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                              â”‚
â”‚  æ³¨æ„ï¼šVA[63:48] å¿…é ˆå…¨ç‚º 0 æˆ–å…¨ç‚º 1 (Canonical Address)      â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
/* Kernel åŸå§‹ç¢¼ä¸­çš„å®šç¾© (arch/arm64/include/asm/memory.h) */

#define VA_BITS         48    /* è™›æ“¬ä½å€ä½å…ƒæ•¸ */
#define PAGE_OFFSET     UL(0xFFFF800000000000)  /* Kernel ç›´æ¥æ˜ å°„èµ·é» */
#define TASK_SIZE       (UL(1) << VA_BITS)      /* User space å¤§å° */

/* è™›æ“¬ä½å€è½‰å¯¦é«”ä½å€ï¼ˆåƒ…é©ç”¨æ–¼ linear mapping å€åŸŸï¼‰*/
#define __pa(x)         ((unsigned long)(x) - PAGE_OFFSET + PHYS_OFFSET)
#define __va(x)         ((void *)((unsigned long)(x) + PAGE_OFFSET - PHYS_OFFSET))

/* ä½¿ç”¨ç¯„ä¾‹ */
void *vaddr = kmalloc(4096, GFP_KERNEL);
unsigned long paddr = __pa(vaddr);  /* å–å¾—å¯¦é«”ä½å€ */
/* æ³¨æ„ï¼š__pa() åªå° kmalloc/ç›´æ¥æ˜ å°„çš„è¨˜æ†¶é«”æœ‰æ•ˆ */
/* vmalloc çš„è¨˜æ†¶é«”ä¸èƒ½ç”¨ __pa()ï¼ */
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šMMU èˆ‡ TLB

### 2.1 MMU (Memory Management Unit) æ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MMU ç¡¬é«”æ¶æ§‹                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   CPU   â”‚  VA     â”‚   TLB   â”‚         â”‚  Page   â”‚       â”‚
â”‚   â”‚  Core   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ (å¿«å–)  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Table   â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  Miss   â”‚ Walker  â”‚       â”‚
â”‚                            â”‚               â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â”‚
â”‚                            â”‚ Hit                â”‚            â”‚
â”‚                            â–¼                    â–¼            â”‚
â”‚                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚                       â”‚        Physical Memory      â”‚        â”‚
â”‚                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                              â”‚
â”‚   TLB Hit:  1-2 cycles   (éå¸¸å¿«)                            â”‚
â”‚   TLB Miss: 10-100+ cycles (éœ€è¦ Page Table Walk)            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 TLB (Translation Lookaside Buffer)

```c
/* TLB æ˜¯ Page Table çš„å¿«å–ï¼ŒåŠ é€Ÿä½å€è½‰æ› */

/*
 * TLB çµæ§‹ (æ¦‚å¿µæ€§)
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ Virtual Page â”‚ Physical Pageâ”‚  ASID   â”‚ Flags  â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ 0x00001      â”‚ 0x80001      â”‚  0x42   â”‚ RWX    â”‚
 * â”‚ 0x00002      â”‚ 0x90005      â”‚  0x42   â”‚ R--    â”‚
 * â”‚ 0x00003      â”‚ 0x80010      â”‚  0x43   â”‚ RW-    â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * 
 * ASID (Address Space ID)ï¼šå€åˆ†ä¸åŒ Process çš„ TLB entry
 * æœ‰äº† ASIDï¼ŒContext Switch æ™‚ä¸éœ€è¦ flush æ•´å€‹ TLBï¼
 */

/* ARM64 TLB æ“ä½œæŒ‡ä»¤ */

/* æ¸…é™¤æ‰€æœ‰ TLB */
static inline void flush_tlb_all(void)
{
    asm volatile(
        "dsb ishst\n"        /* ç¢ºä¿æ‰€æœ‰å¯«å…¥å®Œæˆ */
        "tlbi vmalle1is\n"   /* æ¸…é™¤ EL1 æ‰€æœ‰ TLB */
        "dsb ish\n"          /* ç­‰å¾… TLB æ“ä½œå®Œæˆ */
        "isb"                /* åŒæ­¥æŒ‡ä»¤æµ */
    );
}

/* æ¸…é™¤ç‰¹å®šä½å€çš„ TLB */
static inline void flush_tlb_page(unsigned long addr, unsigned long asid)
{
    unsigned long arg = (addr >> 12) | (asid << 48);
    asm volatile(
        "dsb ishst\n"
        "tlbi vale1is, %0\n"  /* æ¸…é™¤ç‰¹å®š VA + ASID çš„ TLB */
        "dsb ish\n"
        "isb"
        : : "r" (arg)
    );
}
```

### 2.3 ASID (Address Space ID)

```c
/*
 * ASID çš„ä½œç”¨ï¼šé¿å… Context Switch æ™‚çš„ TLB flush
 * 
 * æ²’æœ‰ ASID çš„æƒ…æ³ï¼š
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   Process A åŸ·è¡Œ â†’ Context Switch â†’ å¿…é ˆ flush TLB â†’ Process B åŸ·è¡Œ
 *                                     (æ‰€æœ‰ TLB entry å¤±æ•ˆ)
 * 
 * æœ‰ ASID çš„æƒ…æ³ï¼š
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   Process A (ASID=1) åŸ·è¡Œ â†’ Context Switch â†’ Process B (ASID=2) åŸ·è¡Œ
 *                              (TLB ä¿ç•™ï¼Œåªæ˜¯åˆ‡æ› ASID)
 *   
 *   ç•¶ Process A å†æ¬¡åŸ·è¡Œæ™‚ï¼Œå®ƒçš„ TLB entry å¯èƒ½é‚„åœ¨ï¼
 */

/* ARM64 ASID é…ç½® (Kernel v6.x) */
/* arch/arm64/include/asm/mmu.h */

struct mm_context {
    atomic64_t id;                /* ASID */
    /* ... */
};

/* ASID åˆ†é… */
#define ASID_BITS       16        /* ARM64 æ”¯æ´ 16-bit ASID */
#define ASID_MASK       ((1UL << ASID_BITS) - 1)  /* 0xFFFF */
#define MAX_ASID        (ASID_MASK + 1)           /* 65536 å€‹ ASID */

/* ç•¶ ASID ç”¨å®Œæ™‚ (wraparound)ï¼Œéœ€è¦ flush æ‰€æœ‰ TLB */
/* é€™æ˜¯ "ASID generation" æ©Ÿåˆ¶ */
```

### 2.4 TLB Miss è™•ç†æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TLB Miss è™•ç†æµç¨‹                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. CPU ç™¼å‡ºè™›æ“¬ä½å€ VA                                       â”‚
â”‚     â””â”€â–¶ TLB æŸ¥è©¢å¤±æ•— (Miss)                                  â”‚
â”‚                                                              â”‚
â”‚  2. Page Table Walker (ç¡¬é«”) é–‹å§‹æŸ¥è©¢                         â”‚
â”‚     â””â”€â–¶ å¾ TTBR0/TTBR1 å–å¾— Page Table åŸºåº•ä½å€               â”‚
â”‚         (TTBR0: User Space, TTBR1: Kernel Space)             â”‚
â”‚                                                              â”‚
â”‚  3. éæ­·å››ç´šé è¡¨                                              â”‚
â”‚     â””â”€â–¶ L0 â†’ L1 â†’ L2 â†’ L3 â†’ Page Frame                       â”‚
â”‚         (æ¯ä¸€ç´šéƒ½éœ€è¦è¨˜æ†¶é«”å­˜å–)                               â”‚
â”‚                                                              â”‚
â”‚  4a. æ‰¾åˆ°æœ‰æ•ˆçš„ PTE                                           â”‚
â”‚      â””â”€â–¶ æ›´æ–° TLBï¼Œè¿”å›å¯¦é«”ä½å€                               â”‚
â”‚                                                              â”‚
â”‚  4b. æ‰¾åˆ°ç„¡æ•ˆçš„ PTE (Page Fault)                              â”‚
â”‚      â””â”€â–¶ è§¸ç™¼ Page Fault Exception                           â”‚
â”‚          â””â”€â–¶ Kernel çš„ do_page_fault() è™•ç†                  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šARM64 å››ç´šé è¡¨

### 3.1 Page Table çµæ§‹æ¦‚è¿°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ARM64 å››ç´šé è¡¨çµæ§‹ (4KB Page, 48-bit VA)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Virtual Address (48-bit):                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚ 47:39  â”‚ 38:30  â”‚ 29:21  â”‚ 20:12  â”‚    11:0        â”‚      â”‚
â”‚  â”‚ L0 idx â”‚ L1 idx â”‚ L2 idx â”‚ L3 idx â”‚   Offset       â”‚      â”‚
â”‚  â”‚ (9bit) â”‚ (9bit) â”‚ (9bit) â”‚ (9bit) â”‚   (12bit)      â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚       â”‚        â”‚        â”‚        â”‚           â”‚               â”‚
â”‚       â–¼        â–¼        â–¼        â–¼           â”‚               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚               â”‚
â”‚  â”‚ TTBR   â”‚ â”€â”€ L0 Table (ä¹Ÿå« PGD)           â”‚               â”‚
â”‚  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚                             â”‚               â”‚
â”‚      â”‚         â–¼                             â”‚               â”‚
â”‚      â””â”€â”€â”€â”€â–¶ L1 Table (ä¹Ÿå« PUD)              â”‚               â”‚
â”‚             â”‚                                 â”‚               â”‚
â”‚             â–¼                                 â”‚               â”‚
â”‚          L2 Table (ä¹Ÿå« PMD)                 â”‚               â”‚
â”‚             â”‚                                 â”‚               â”‚
â”‚             â–¼                                 â”‚               â”‚
â”‚          L3 Table (ä¹Ÿå« PTE)                 â”‚               â”‚
â”‚             â”‚                                 â”‚               â”‚
â”‚             â–¼                                 â”‚               â”‚
â”‚          Page Frame â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€ + â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚          (4KB)                 offset                        â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¯ç´š Page Tableï¼š
- 512 å€‹ entry (2^9 = 512)
- æ¯å€‹ entry 8 bytes
- ç¸½å¤§å° = 512 Ã— 8 = 4KB (æ­£å¥½ä¸€å€‹ page)
```

### 3.2 Page Table Entry (PTE) æ ¼å¼

```c
/* ARM64 Page Table Entry æ ¼å¼ */

/*
 * 63    55 54   52 51      48 47          12 11    2 1  0
 * â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”
 * â”‚ Attr â”‚ SW    â”‚ Reserved â”‚ Output Addr   â”‚ Attr  â”‚VT â”‚
 * â”‚ UXN  â”‚ bits  â”‚          â”‚ (PA[47:12])   â”‚ Lower â”‚   â”‚
 * â”‚ PXN  â”‚       â”‚          â”‚ (36-bit PFN)  â”‚       â”‚   â”‚
 * â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜
 * 
 * Bit 0 (V): Valid bit
 *   0 = Invalid (æœƒè§¸ç™¼ Page Fault)
 *   1 = Valid
 * 
 * Bit 1 (T): Table/Block/Page descriptor type
 *   For L0-L2: 0 = Block, 1 = Table
 *   For L3:    0 = Reserved, 1 = Page
 * 
 * Bits 11:2: Lower attributes
 *   - AttrIndx[2:0]: Memory type index (æŒ‡å‘ MAIR)
 *   - NS: Non-Secure
 *   - AP[2:1]: Access Permission
 *   - SH[1:0]: Shareability
 *   - AF: Access Flag (ç¡¬é«”è¨­å®š)
 *   - nG: not Global
 * 
 * Bits 54:52: Software-defined (Kernel è‡ªç”¨)
 *   - Linux ç”¨ä¾†å­˜ _PAGE_PRESENT, _PAGE_DIRTY ç­‰
 * 
 * Bit 53 (PXN): Privileged Execute-Never
 * Bit 54 (UXN): User Execute-Never
 */

/* Linux Kernel çš„ PTE å®šç¾© (arch/arm64/include/asm/pgtable-hwdef.h) */

#define PTE_VALID       (1UL << 0)
#define PTE_TYPE_PAGE   (3UL << 0)  /* L3: 0b11 = Page */
#define PTE_TABLE       (3UL << 0)  /* L0-L2: 0b11 = Table */

#define PTE_USER        (1UL << 6)  /* AP[1] = User accessible */
#define PTE_RDONLY      (1UL << 7)  /* AP[2] = Read-only */
#define PTE_SHARED      (3UL << 8)  /* SH[1:0] = Inner Shareable */
#define PTE_AF          (1UL << 10) /* Access Flag */
#define PTE_NG          (1UL << 11) /* not Global */

#define PTE_PXN         (1UL << 53) /* Privileged Execute-Never */
#define PTE_UXN         (1UL << 54) /* User Execute-Never */

/* Linux è»Ÿé«”å®šç¾©çš„ flags (å­˜åœ¨ bits 55-58) */
#define PTE_DIRTY       (1UL << 55) /* Page å·²è¢«å¯«å…¥ */
#define PTE_SPECIAL     (1UL << 56) /* Special mapping */
#define PTE_DEVMAP      (1UL << 57) /* Device mapping */
#define PTE_PROT_NONE   (1UL << 58) /* Page å­˜åœ¨ä½†ä¸å¯å­˜å– */
```

### 3.3 å­˜å–æ¬Šé™æ§åˆ¶

```c
/* AP (Access Permission) bits è§£è®€ */

/*
 * AP[2:1] | Kernel | User   | èªªæ˜
 * â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *   00    |  RW    |  --    | Kernel RW only
 *   01    |  RW    |  RW    | Kernel RW, User RW
 *   10    |  RO    |  --    | Kernel RO only
 *   11    |  RO    |  RO    | Kernel RO, User RO
 * 
 * åŠ ä¸Š PXN/UXN å¯ä»¥æ§åˆ¶åŸ·è¡Œæ¬Šé™
 */

/* å¸¸è¦‹çš„æ¬Šé™çµ„åˆ */

/* Kernel ç¨‹å¼ç¢¼å€ */
#define PAGE_KERNEL_EXEC    (PTE_VALID | PTE_AF | PTE_SHARED)

/* Kernel è³‡æ–™å€ */
#define PAGE_KERNEL         (PTE_VALID | PTE_AF | PTE_SHARED | PTE_PXN | PTE_UXN)

/* User ç¨‹å¼ç¢¼å€ */
#define PAGE_USER_EXEC      (PTE_VALID | PTE_AF | PTE_SHARED | PTE_USER | PTE_PXN)

/* User è³‡æ–™å€ */
#define PAGE_USER           (PTE_VALID | PTE_AF | PTE_SHARED | PTE_USER | PTE_PXN | PTE_UXN)

/* User å”¯è®€å€ */
#define PAGE_USER_RO        (PTE_VALID | PTE_AF | PTE_SHARED | PTE_USER | PTE_RDONLY | \
                             PTE_PXN | PTE_UXN)
```

### 3.4 Page Table Walk å¯¦ä½œ

```c
/* Kernel ä¸­çš„ Page Table Walk å¯¦ä½œ */
/* arch/arm64/mm/fault.c (ç°¡åŒ–ç‰ˆ) */

/* å¾è™›æ“¬ä½å€å–å¾— PTE */
pte_t *get_pte(struct mm_struct *mm, unsigned long addr)
{
    pgd_t *pgd;
    p4d_t *p4d;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    
    /* Level 0: PGD (Page Global Directory) */
    pgd = pgd_offset(mm, addr);
    if (pgd_none(*pgd) || pgd_bad(*pgd))
        return NULL;
    
    /* Level 1: P4D (åœ¨ ARM64 4-level é…ç½®ä¸‹ç­‰åŒ PGD) */
    p4d = p4d_offset(pgd, addr);
    if (p4d_none(*p4d) || p4d_bad(*p4d))
        return NULL;
    
    /* Level 2: PUD (Page Upper Directory) */
    pud = pud_offset(p4d, addr);
    if (pud_none(*pud) || pud_bad(*pud))
        return NULL;
    
    /* Level 3: PMD (Page Middle Directory) */
    pmd = pmd_offset(pud, addr);
    if (pmd_none(*pmd) || pmd_bad(*pmd))
        return NULL;
    
    /* Level 4: PTE (Page Table Entry) */
    pte = pte_offset_kernel(pmd, addr);
    
    return pte;
}

/* å„å±¤ index è¨ˆç®— */
#define PGDIR_SHIFT     39  /* L0: bits 47:39 */
#define PUD_SHIFT       30  /* L1: bits 38:30 */
#define PMD_SHIFT       21  /* L2: bits 29:21 */
#define PAGE_SHIFT      12  /* L3: bits 20:12 */

#define pgd_index(addr)  (((addr) >> PGDIR_SHIFT) & 0x1FF)
#define pud_index(addr)  (((addr) >> PUD_SHIFT) & 0x1FF)
#define pmd_index(addr)  (((addr) >> PMD_SHIFT) & 0x1FF)
#define pte_index(addr)  (((addr) >> PAGE_SHIFT) & 0x1FF)
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šPage Fault è™•ç†

### 4.1 Page Fault çš„é¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Page Fault é¡å‹                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. Minor Page Fault (Soft Fault)                            â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚     - Page å·²åœ¨è¨˜æ†¶é«”ä¸­ï¼Œåªæ˜¯æ²’æœ‰æ˜ å°„                          â”‚
â”‚     - ä¾‹å¦‚ï¼šæ–°é…ç½®çš„ Pageã€COW å¾Œçš„è¤‡è£½                       â”‚
â”‚     - è™•ç†ï¼šå»ºç«‹ PTE æ˜ å°„ï¼Œä¸éœ€ I/O                           â”‚
â”‚     - é–‹éŠ·ï¼šä½                                               â”‚
â”‚                                                              â”‚
â”‚  2. Major Page Fault (Hard Fault)                            â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚     - Page ä¸åœ¨è¨˜æ†¶é«”ä¸­ï¼Œéœ€è¦å¾ Disk è®€å…¥                     â”‚
â”‚     - ä¾‹å¦‚ï¼šSwapã€mmap çš„æª”æ¡ˆ                                â”‚
â”‚     - è™•ç†ï¼šå¾ Disk è®€å– Pageï¼Œå»ºç«‹ PTE                       â”‚
â”‚     - é–‹éŠ·ï¼šé«˜ï¼ˆéœ€è¦ I/Oï¼‰                                   â”‚
â”‚                                                              â”‚
â”‚  3. Invalid Page Fault                                       â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                   â”‚
â”‚     - å­˜å–ç„¡æ•ˆçš„è¨˜æ†¶é«”å€åŸŸ                                    â”‚
â”‚     - ä¾‹å¦‚ï¼šNULL pointerã€æœªé…ç½®çš„ä½å€                        â”‚
â”‚     - è™•ç†ï¼šç™¼é€ SIGSEGV çµ¦ Process                          â”‚
â”‚                                                              â”‚
â”‚  4. Permission Fault                                         â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                    â”‚
â”‚     - å­˜å–æ¬Šé™ä¸è¶³                                           â”‚
â”‚     - ä¾‹å¦‚ï¼šå¯«å…¥å”¯è®€ Pageã€User å­˜å– Kernel Page             â”‚
â”‚     - è™•ç†ï¼šç™¼é€ SIGSEGV æˆ–è§¸ç™¼ COW                          â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Linux Page Fault è™•ç†æµç¨‹

```c
/* Linux Page Fault Handler (ARM64) */
/* arch/arm64/mm/fault.c (ç°¡åŒ–ç‰ˆ) */

asmlinkage void do_page_fault(unsigned long far, unsigned long esr,
                               struct pt_regs *regs)
{
    struct mm_struct *mm = current->mm;
    struct vm_area_struct *vma;
    unsigned long addr = far;  /* Fault Address Register */
    vm_fault_t fault;
    
    /* 1. æª¢æŸ¥æ˜¯å¦ç‚º Kernel å­˜å– (Exception Level) */
    if (!user_mode(regs)) {
        /* Kernel mode fault */
        /* å¯èƒ½æ˜¯ fixup (é æœŸçš„éŒ¯èª¤) æˆ–çœŸæ­£çš„ bug */
        if (!search_exception_tables(regs->pc))
            goto kernel_fault;
        /* æœ‰ handlerï¼ŒåŸ·è¡Œ fixup */
        return;
    }
    
    /* 2. å–å¾— Memory Map çš„é– */
    mmap_read_lock(mm);
    
    /* 3. æ‰¾åˆ°åŒ…å«æ­¤ä½å€çš„ VMA */
    vma = find_vma(mm, addr);
    if (!vma)
        goto bad_area;
    
    /* 4. æª¢æŸ¥ä½å€æ˜¯å¦åœ¨ VMA ç¯„åœå…§ */
    if (vma->vm_start <= addr)
        goto good_area;
    
    /* 5. æª¢æŸ¥æ˜¯å¦ç‚º Stack æ“´å±• */
    if (!(vma->vm_flags & VM_GROWSDOWN))
        goto bad_area;
    if (expand_stack(vma, addr))
        goto bad_area;
    
good_area:
    /* 6. æª¢æŸ¥å­˜å–æ¬Šé™ */
    if (access_error(esr, vma))
        goto bad_area;
    
    /* 7. å‘¼å« generic fault handler */
    fault = handle_mm_fault(vma, addr, flags, regs);
    
    if (fault & VM_FAULT_ERROR) {
        if (fault & VM_FAULT_OOM)
            goto out_of_memory;
        if (fault & VM_FAULT_SIGBUS)
            goto do_sigbus;
        BUG();
    }
    
    mmap_read_unlock(mm);
    return;
    
bad_area:
    mmap_read_unlock(mm);
    /* ç™¼é€ SIGSEGV */
    do_bad_area(far, esr, regs);
    return;
    
kernel_fault:
    /* Kernel bug! æ‡‰è©²æ°¸é ä¸æœƒåŸ·è¡Œåˆ°é€™è£¡ */
    die("Oops - kernel NULL pointer dereference", regs, esr);
    do_exit(SIGKILL);
}
```

### 4.3 Copy-on-Write (COW) æ©Ÿåˆ¶

```c
/*
 * Copy-on-Write (COW) æ©Ÿåˆ¶
 * 
 * fork() æ™‚ä¸è¤‡è£½è¨˜æ†¶é«”ï¼Œè€Œæ˜¯è®“çˆ¶å­ Process å…±äº«åŒä¸€ä»½
 * ç•¶ä»»ä¸€æ–¹å¯«å…¥æ™‚ï¼Œæ‰è¤‡è£½é‚£å€‹ Page
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚                     fork() å¾Œ                           â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚                                                         â”‚
 * â”‚   Parent PTE â”€â”€â”¬â”€â”€â–¶ Page A (ReadOnly)                  â”‚
 * â”‚   Child PTE  â”€â”€â”˜                                        â”‚
 * â”‚                                                         â”‚
 * â”‚   å…©å€‹ PTE éƒ½æ¨™è¨˜ç‚º ReadOnlyï¼                           â”‚
 * â”‚                                                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚                  Child å¯«å…¥æ™‚                           â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚                                                         â”‚
 * â”‚   1. å¯«å…¥è§¸ç™¼ Page Fault (Permission Fault)             â”‚
 * â”‚   2. Kernel ç™¼ç¾æ˜¯ COW Page                             â”‚
 * â”‚   3. è¤‡è£½ Page A â†’ Page B                               â”‚
 * â”‚   4. æ›´æ–° Child PTE æŒ‡å‘ Page Bï¼Œè¨­ç‚º RW                â”‚
 * â”‚   5. Parent è‹¥ä¹Ÿå¯«å…¥ï¼Œä¹Ÿæœƒè§¸ç™¼ COW                       â”‚
 * â”‚                                                         â”‚
 * â”‚   Parent PTE â”€â”€â–¶ Page A (RW)  â† å¦‚æœåªå‰©ä¸€å€‹ ref        â”‚
 * â”‚   Child PTE  â”€â”€â–¶ Page B (RW)                            â”‚
 * â”‚                                                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

/* COW è™•ç† (mm/memory.c ç°¡åŒ–) */
static vm_fault_t do_wp_page(struct vm_fault *vmf)
{
    struct page *old_page = vmf->page;
    struct page *new_page;
    
    /* æª¢æŸ¥ Page çš„åƒè€ƒè¨ˆæ•¸ */
    if (page_count(old_page) == 1) {
        /* åªæœ‰æˆ‘å€‘åœ¨ç”¨ï¼Œä¸éœ€è¦è¤‡è£½ï¼Œç›´æ¥æ”¹æ¬Šé™ */
        wp_page_reuse(vmf);
        return VM_FAULT_WRITE;
    }
    
    /* éœ€è¦è¤‡è£½ */
    new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, addr);
    if (!new_page)
        return VM_FAULT_OOM;
    
    /* è¤‡è£½ Page å…§å®¹ */
    copy_user_highpage(new_page, old_page, addr, vma);
    
    /* æ›´æ–° PTE */
    set_pte_at(mm, addr, vmf->pte, mk_pte(new_page, vma->vm_page_prot));
    
    /* æ¸›å°‘èˆŠ Page çš„åƒè€ƒè¨ˆæ•¸ */
    put_page(old_page);
    
    return VM_FAULT_WRITE;
}
```

### 4.4 Demand Paging

```c
/*
 * Demand Paging æ©Ÿåˆ¶
 * 
 * é…ç½®è¨˜æ†¶é«”æ™‚ä¸ç«‹å³åˆ†é…å¯¦é«” Page
 * ç­‰åˆ°çœŸæ­£å­˜å–æ™‚æ‰åˆ†é… (é€é Page Fault)
 * 
 * å„ªé»ï¼š
 * - æ¸›å°‘è¨˜æ†¶é«”ä½¿ç”¨ï¼ˆè¨±å¤šé…ç½®çš„è¨˜æ†¶é«”æ°¸é ä¸æœƒç”¨åˆ°ï¼‰
 * - åŠ å¿«ç¨‹å¼å•Ÿå‹•é€Ÿåº¦
 * - æ›´å¥½çš„ COW æ”¯æ´
 */

/* mmap æ™‚çš„è™•ç† */
void *mmap(void *addr, size_t length, int prot, int flags, 
           int fd, off_t offset)
{
    /* mmap åªå»ºç«‹ VMA (Virtual Memory Area) */
    /* ä¸å¯¦éš›åˆ†é…å¯¦é«”è¨˜æ†¶é«” */
    
    /*
     * VMA æè¿°ï¼š
     * - è™›æ“¬ä½å€ç¯„åœ
     * - æ¬Šé™ (prot)
     * - ä¾†æº (anonymous æˆ– file)
     * - flags
     */
}

/* ç¬¬ä¸€æ¬¡å­˜å–æ™‚ */
/* 1. Page Fault ç™¼ç”Ÿ */
/* 2. Kernel æŸ¥æ‰¾ VMAï¼Œç™¼ç¾æ˜¯ valid çš„ mapping */
/* 3. åˆ†é…å¯¦é«” Page */
/* 4. å¦‚æœæ˜¯ file mappingï¼Œå¾æª”æ¡ˆè®€å…¥è³‡æ–™ */
/* 5. å»ºç«‹ PTE */
/* 6. è¿”å› User spaceï¼Œé‡è©¦å­˜å– */

/* Anonymous Page Fault (mm/memory.c) */
static vm_fault_t do_anonymous_page(struct vm_fault *vmf)
{
    struct page *page;
    pte_t entry;
    
    /* åˆ†é…ä¸€å€‹ zero-filled page */
    page = alloc_zeroed_user_highpage_movable(vma, addr);
    if (!page)
        return VM_FAULT_OOM;
    
    /* å»ºç«‹ PTE */
    entry = mk_pte(page, vma->vm_page_prot);
    if (vma->vm_flags & VM_WRITE)
        entry = pte_mkwrite(pte_mkdirty(entry));
    
    set_pte_at(mm, addr, vmf->pte, entry);
    
    return VM_FAULT_NOPAGE;
}
```

---

## ğŸ“ é¢è©¦é¡Œåº«ï¼ˆç¬¬ä¸€éƒ¨åˆ†ï¼‰

### Q1: ä»€éº¼æ˜¯ TLBï¼ŸTLB Miss æ™‚æœƒç™¼ç”Ÿä»€éº¼ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šIntel / AMD / æ™®é

**å•é¡Œ**ï¼š
è«‹è§£é‡‹ TLB æ˜¯ä»€éº¼ï¼Œä»¥åŠ TLB Miss çš„è™•ç†æµç¨‹ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

TLB (Translation Lookaside Buffer) æ˜¯ Page Table çš„ç¡¬é«”å¿«å–ï¼Œç”¨æ–¼åŠ é€Ÿè™›æ“¬ä½å€åˆ°å¯¦é«”ä½å€çš„è½‰æ›ã€‚

**TLB Hit æµç¨‹** (1-2 cycles)ï¼š
1. CPU ç™¼å‡ºè™›æ“¬ä½å€
2. TLB æŸ¥è©¢å‘½ä¸­
3. ç›´æ¥å–å¾—å¯¦é«”ä½å€

**TLB Miss æµç¨‹** (10-100+ cycles)ï¼š
1. TLB æŸ¥è©¢å¤±æ•—
2. Page Table Walker (ç¡¬é«”) é–‹å§‹éæ­·é è¡¨
3. å¾ TTBR æš«å­˜å™¨å–å¾— Page Table åŸºåº•ä½å€
4. ä¾åºæŸ¥è©¢ L0 â†’ L1 â†’ L2 â†’ L3
5. æ‰¾åˆ° PTE å¾Œï¼Œæ›´æ–° TLB
6. è¿”å›å¯¦é«”ä½å€

**è¿½å•**ï¼šå¦‚ä½•æ¸›å°‘ TLB Missï¼Ÿ
- ä½¿ç”¨ Huge Page (2MB/1GB)ï¼Œæ¸›å°‘ TLB entry éœ€æ±‚
- ä½¿ç”¨ ASIDï¼ŒContext Switch æ™‚ä¿ç•™ TLB entry
- é¿å…ä¸å¿…è¦çš„ memory mapping

---

### Q2: è§£é‡‹ Copy-on-Write (COW) æ©Ÿåˆ¶

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / Meta / æ™®é

**å•é¡Œ**ï¼š
fork() ç³»çµ±å‘¼å«ä½¿ç”¨ COW æ©Ÿåˆ¶ï¼Œè«‹è§£é‡‹å…¶é‹ä½œåŸç†å’Œæ•ˆèƒ½å„ªå‹¢ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**COW æ©Ÿåˆ¶**ï¼š
1. fork() æ™‚ï¼Œçˆ¶å­ Process å…±äº«åŒä¸€ä»½å¯¦é«”è¨˜æ†¶é«”
2. æ‰€æœ‰å…±äº«çš„ Page æ¨™è¨˜ç‚º Read-Only
3. ç•¶ä»»ä¸€æ–¹å˜—è©¦å¯«å…¥æ™‚ï¼Œè§¸ç™¼ Page Fault
4. Kernel è¤‡è£½è©² Pageï¼Œå»ºç«‹ç¨ç«‹å‰¯æœ¬
5. ä¿®æ”¹ PTE æŒ‡å‘æ–° Pageï¼Œè¨­ç‚º Read-Write

**æ•ˆèƒ½å„ªå‹¢**ï¼š
- fork() å¹¾ä¹æ˜¯ç¬é–“å®Œæˆçš„ (åªè¤‡è£½ Page Tableï¼Œä¸è¤‡è£½è³‡æ–™)
- exec() å¾Œä¸éœ€è¦çš„ Page æ°¸é ä¸æœƒè¢«è¤‡è£½
- å…±äº« read-only è³‡æ–™ (å¦‚ libc) ç¯€çœè¨˜æ†¶é«”

**ç¨‹å¼ç¢¼å±¤é¢**ï¼š
```c
static vm_fault_t do_wp_page(struct vm_fault *vmf)
{
    /* æª¢æŸ¥åƒè€ƒè¨ˆæ•¸ */
    if (page_count(old_page) == 1) {
        /* åªå‰©ä¸€å€‹ä½¿ç”¨è€…ï¼Œç›´æ¥ reuse */
        wp_page_reuse(vmf);
        return VM_FAULT_WRITE;
    }
    /* è¤‡è£½ Page */
    new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, addr);
    copy_user_highpage(new_page, old_page, addr, vma);
    /* æ›´æ–° PTE */
    set_pte_at(mm, addr, vmf->pte, mk_pte(new_page, vma->vm_page_prot));
    put_page(old_page);
    return VM_FAULT_WRITE;
}
```

---

### Q3: Major Page Fault å’Œ Minor Page Fault çš„å·®åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šIntel / NVIDIA / æ™®é

**å•é¡Œ**ï¼š
å¦‚ä½•åˆ¤æ–·ä¸€å€‹ Page Fault æ˜¯ Major é‚„æ˜¯ Minorï¼Ÿå°æ•ˆèƒ½æœ‰ä»€éº¼å½±éŸ¿ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

| é¡å‹ | æ¢ä»¶ | è™•ç† | é–‹éŠ· |
|:---|:---|:---|:---|
| Minor | Page åœ¨è¨˜æ†¶é«”ä¸­ | åªéœ€å»ºç«‹ PTE | å¾®ç§’ç´š |
| Major | Page ä¸åœ¨è¨˜æ†¶é«”ä¸­ | éœ€è¦ Disk I/O | æ¯«ç§’ç´š |

**Minor Page Fault æƒ…å¢ƒ**ï¼š
- æ–°é…ç½®çš„ anonymous page
- COW é é¢çš„è¤‡è£½
- mmap çš„ file page å·²åœ¨ page cache

**Major Page Fault æƒ…å¢ƒ**ï¼š
- Swap-in (å¾ swap è®€å›)
- mmap çš„ file page ä¸åœ¨ cache
- ç¬¬ä¸€æ¬¡å­˜å– mmap file

**æ•ˆèƒ½å½±éŸ¿**ï¼š
```bash
# ç”¨ time è§€å¯Ÿ
$ /usr/bin/time -v ./program 2>&1 | grep -i fault
Minor (reclaiming a frame): 1234
Major (requiring I/O): 5
```

Major Fault éœ€è¦ç­‰å¾… Disk I/O (æ¯«ç§’ç´š)ï¼Œæ˜¯ Minor çš„ 1000 å€ä»¥ä¸Šã€‚

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šOOM Killer

### 5.1 OOM çš„è§¸ç™¼æ¢ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 OOM (Out of Memory) è§¸ç™¼æµç¨‹                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. Process è«‹æ±‚è¨˜æ†¶é«” (malloc/mmap/page fault)              â”‚
â”‚                                                              â”‚
â”‚  2. Kernel å˜—è©¦åˆ†é…è¨˜æ†¶é«”                                     â”‚
â”‚     â””â”€â–¶ æª¢æŸ¥ free pages                                      â”‚
â”‚                                                              â”‚
â”‚  3. è¨˜æ†¶é«”ä¸è¶³æ™‚çš„ç­–ç•¥                                        â”‚
â”‚     â”œâ”€â–¶ å›æ”¶ Page Cache                                      â”‚
â”‚     â”œâ”€â–¶ è§¸ç™¼ Swap                                            â”‚
â”‚     â”œâ”€â–¶ å£“ç¸®è¨˜æ†¶é«” (zswap/zram)                              â”‚
â”‚     â””â”€â–¶ å›æ”¶ Slab Cache                                      â”‚
â”‚                                                              â”‚
â”‚  4. è‹¥ä»ç„¶ä¸è¶³                                                â”‚
â”‚     â””â”€â–¶ è§¸ç™¼ OOM Killerï¼                                     â”‚
â”‚         â””â”€â–¶ é¸æ“‡ä¸¦ kill ä¸€å€‹ Process                          â”‚
â”‚             â””â”€â–¶ é‡‹æ”¾å…¶è¨˜æ†¶é«”                                  â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 OOM Score è¨ˆç®—

```c
/* OOM Killer é¸æ“‡å—å®³è€…çš„ç®—æ³• */
/* mm/oom_kill.c (ç°¡åŒ–ç‰ˆ) */

/*
 * OOM Score è¨ˆç®—ï¼š
 * - åŸºç¤åˆ†æ•¸ï¼šProcess ä½¿ç”¨çš„è¨˜æ†¶é«”é‡
 * - èª¿æ•´å› å­ï¼šoom_score_adj (-1000 åˆ° 1000)
 * 
 * åˆ†æ•¸è¶Šé«˜ï¼Œè¶Šå®¹æ˜“è¢« kill
 */

unsigned long oom_badness(struct task_struct *p, 
                          unsigned long totalpages)
{
    long points;
    long adj;
    
    /* å–å¾— oom_score_adj */
    adj = (long)p->signal->oom_score_adj;
    
    /* ç‰¹æ®Šå€¼ï¼š-1000 è¡¨ç¤ºæ°¸é ä¸è¢« kill */
    if (adj == OOM_SCORE_ADJ_MIN)  /* -1000 */
        return 0;  /* è¿”å› 0ï¼Œä¸æœƒè¢«é¸ä¸­ */
    
    /* è¨ˆç®— RSS (Resident Set Size) */
    points = get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS);
    
    /* åŠ ä¸Š Page Table ä½”ç”¨ */
    points += mm_pgtables_bytes(p->mm) / PAGE_SIZE;
    
    /* å¥—ç”¨ oom_score_adj */
    /* adj = 1000 æ™‚ï¼Œpoints è®ŠæˆåŸä¾†çš„ 2 å€ */
    /* adj = -500 æ™‚ï¼Œpoints è®ŠæˆåŸä¾†çš„ 0.5 å€ */
    adj *= totalpages / 1000;
    points += adj;
    
    return max(points, 1L);  /* è‡³å°‘è¿”å› 1 */
}

/*
 * /proc/<pid>/oom_score ç¯„åœï¼š0 ~ 1000
 * /proc/<pid>/oom_score_adj ç¯„åœï¼š-1000 ~ 1000
 * 
 * å¸¸è¦‹è¨­å®šï¼š
 *   oom_score_adj = -1000  â†’ æ°¸é ä¸è¢« kill (å¦‚ init)
 *   oom_score_adj = -500   â†’ ä¸å¤ªæœƒè¢« kill
 *   oom_score_adj = 0      â†’ é è¨­å€¼
 *   oom_score_adj = 500    â†’ å„ªå…ˆè¢« kill
 *   oom_score_adj = 1000   â†’ æœ€å…ˆè¢« kill
 */
```

### 5.3 å¦‚ä½•é¿å… OOM

```c
/* æ–¹æ³• 1ï¼šè¨­å®š oom_score_adj */
/* ä¿è­·é—œéµ Process */
$ echo -1000 > /proc/<pid>/oom_score_adj

/* è®“æŸå€‹ Process å„ªå…ˆè¢« kill */
$ echo 500 > /proc/<pid>/oom_score_adj

/* åœ¨ç¨‹å¼ä¸­è¨­å®š */
#include <sys/prctl.h>
prctl(PR_SET_OOM_ADJUST, -17, 0, 0, 0);  /* èˆŠ APIï¼Œ-17 = ä¸è¢« kill */
prctl(PR_SET_OOM_SCORE_ADJ, -1000, 0, 0, 0);  /* æ–° API */

/* æ–¹æ³• 2ï¼šé—œé–‰ Overcommit */
/* /proc/sys/vm/overcommit_memory */
/*   0 = Heuristic overcommit (é è¨­)  */
/*   1 = Always overcommit (å±éšª)     */
/*   2 = Don't overcommit             */

$ echo 2 > /proc/sys/vm/overcommit_memory
$ echo 80 > /proc/sys/vm/overcommit_ratio  /* å…è¨±ä½¿ç”¨ 80% RAM + Swap */

/* æ–¹æ³• 3ï¼šä½¿ç”¨ cgroups é™åˆ¶è¨˜æ†¶é«” */
# cgroups v2
$ echo 1G > /sys/fs/cgroup/my_group/memory.max
$ echo 800M > /sys/fs/cgroup/my_group/memory.high
```

### 5.4 OOM Killer æ—¥èªŒåˆ†æ

```
/* dmesg ä¸­çš„ OOM Killer æ—¥èªŒç¯„ä¾‹ */

[ 1234.567890] java invoked oom-killer: gfp_mask=0x14200ca(GFP_HIGHUSER_MOVABLE)
[ 1234.567891] Mem-Info:
[ 1234.567892] active_anon:123456 inactive_anon:78901 isolated_anon:0
[ 1234.567893]  active_file:23456 inactive_file:45678 isolated_file:0
[ 1234.567894]  unevictable:0 dirty:123 writeback:0 slab_reclaimable:12345
[ 1234.567895]  slab_unreclaimable:6789 mapped:34567 shmem:8901
[ 1234.567896] ...
[ 1234.567900] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),
               cpuset=/,mems_allowed=0,global_oom,task_memcg=/,
               task=java,pid=12345,uid=1000
[ 1234.567901] Out of memory: Killed process 12345 (java) total-vm:8388608kB,
               anon-rss:4194304kB, file-rss:12345kB, shmem-rss:0kB

/*
 * é—œéµè³‡è¨Šè§£è®€ï¼š
 * - gfp_maskï¼šèª°è§¸ç™¼çš„ OOM
 * - task=java,pid=12345ï¼šè¢« kill çš„ Process
 * - total-vmï¼šè™›æ“¬è¨˜æ†¶é«”å¤§å°
 * - anon-rssï¼šåŒ¿åè¨˜æ†¶é«”ä½¿ç”¨é‡
 * - file-rssï¼šFile-backed è¨˜æ†¶é«”
 */
```

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šMemory Barrier

### 6.1 ç‚ºä»€éº¼éœ€è¦ Memory Barrierï¼Ÿ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               è¨˜æ†¶é«”é †åºå•é¡Œçš„ä¾†æº                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. ç·¨è­¯å™¨å„ªåŒ–ï¼šé‡æ’æŒ‡ä»¤é †åº                                   â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚     int a = 0, b = 0;                                        â”‚
â”‚     void foo() {                                             â”‚
â”‚         a = 1;  â† ç·¨è­¯å™¨å¯èƒ½æŠŠé€™å…©è¡Œ                          â”‚
â”‚         b = 2;  â† äº¤æ›é †åºåŸ·è¡Œ                               â”‚
â”‚     }                                                        â”‚
â”‚                                                              â”‚
â”‚  2. CPU äº‚åºåŸ·è¡Œ (Out-of-Order Execution)                    â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                       â”‚
â”‚     - ç¾ä»£ CPU ç‚ºäº†æ•ˆèƒ½æœƒäº‚åºåŸ·è¡ŒæŒ‡ä»¤                          â”‚
â”‚     - Store Buffer å°è‡´å¯«å…¥å»¶é²å¯è¦‹                           â”‚
â”‚                                                              â”‚
â”‚  3. Cache ä¸€è‡´æ€§å»¶é²                                          â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚     - å¤šæ ¸å¿ƒé–“çš„ Cache åŒæ­¥æœ‰å»¶é²                             â”‚
â”‚     - ä¸€å€‹æ ¸å¿ƒçš„å¯«å…¥ï¼Œå¦ä¸€å€‹æ ¸å¿ƒä¸ä¸€å®šç«‹åˆ»çœ‹åˆ°                 â”‚
â”‚                                                              â”‚
â”‚  4. Memory Modelï¼šä¸åŒæ¶æ§‹æœ‰ä¸åŒçš„ä¿è­‰                        â”‚
â”‚     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                         â”‚
â”‚     x86: è¼ƒå¼·çš„é †åºä¿è­‰ (TSO)                                â”‚
â”‚     ARM: è¼ƒå¼±çš„é †åºä¿è­‰ï¼Œéœ€è¦æ›´å¤š barrier                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 Memory Barrier é¡å‹

```c
/* Linux Kernel æä¾›çš„ Memory Barrier */
/* include/asm-generic/barrier.h */

/*
 * å®Œæ•´çš„ Memory Barrier
 * - ç¢ºä¿ barrier å‰çš„æ‰€æœ‰è®€å¯«éƒ½åœ¨ barrier å¾Œçš„è®€å¯«ä¹‹å‰å®Œæˆ
 */
mb();   /* Full memory barrier */

/*
 * Read Memory Barrier
 * - ç¢ºä¿ barrier å‰çš„æ‰€æœ‰è®€å–éƒ½åœ¨ barrier å¾Œçš„è®€å–ä¹‹å‰å®Œæˆ
 */
rmb();  /* Read barrier */

/*
 * Write Memory Barrier
 * - ç¢ºä¿ barrier å‰çš„æ‰€æœ‰å¯«å…¥éƒ½åœ¨ barrier å¾Œçš„å¯«å…¥ä¹‹å‰å®Œæˆ
 */
wmb();  /* Write barrier */

/*
 * SMP ç‰ˆæœ¬ (åªåœ¨ SMP ç³»çµ±æœ‰æ•ˆï¼ŒUP ç³»çµ±æ˜¯ç©ºæ“ä½œ)
 * æ•ˆèƒ½è¼ƒå¥½ï¼Œæ‡‰è©²å„ªå…ˆä½¿ç”¨
 */
smp_mb();
smp_rmb();
smp_wmb();

/*
 * Compiler Barrier (åªé˜²æ­¢ç·¨è­¯å™¨å„ªåŒ–ï¼Œä¸ç”¢ç”Ÿ CPU æŒ‡ä»¤)
 */
barrier();  /* ç­‰åŒ asm volatile("" ::: "memory") */
```

### 6.3 ARM64 çš„ Barrier æŒ‡ä»¤

```c
/* ARM64 æœ‰ä¸‰ç¨® Barrier æŒ‡ä»¤ */

/*
 * 1. DMB (Data Memory Barrier)
 *    - ç¢ºä¿ DMB å‰çš„è¨˜æ†¶é«”æ“ä½œå° DMB å¾Œçš„è¨˜æ†¶é«”æ“ä½œå¯è¦‹
 *    - ä¸å½±éŸ¿æŒ‡ä»¤åŸ·è¡Œé †åº
 */
__asm__ __volatile__("dmb sy" ::: "memory");

/*
 * 2. DSB (Data Synchronization Barrier)
 *    - æ¯” DMB æ›´å¼·ï¼šç­‰å¾…æ‰€æœ‰è¨˜æ†¶é«”æ“ä½œå®Œæˆ
 *    - DSB ä¹‹å¾Œçš„æŒ‡ä»¤ä¸æœƒåŸ·è¡Œï¼Œç›´åˆ° DSB ä¹‹å‰çš„æ“ä½œå®Œæˆ
 */
__asm__ __volatile__("dsb sy" ::: "memory");

/*
 * 3. ISB (Instruction Synchronization Barrier)
 *    - Flush instruction pipeline
 *    - ç”¨æ–¼éœ€è¦çœ‹åˆ°æ–°æŒ‡ä»¤æ•ˆæœçš„å ´æ™¯ï¼ˆå¦‚ä¿®æ”¹ Page Tableï¼‰
 */
__asm__ __volatile__("isb" ::: "memory");

/* Shareability Domain é¸é … */
/*
 * dmb sy   â†’ å…¨ç³»çµ± (System)
 * dmb ish  â†’ Inner Shareable (å¸¸ç”¨ï¼Œå¤šæ ¸å¿ƒä¹‹é–“)
 * dmb osh  â†’ Outer Shareable
 * dmb nsh  â†’ Non-shareable
 */

/* Linux Kernel å°æ‡‰ */
#define mb()     __asm__ __volatile__("dsb sy" ::: "memory")
#define rmb()    __asm__ __volatile__("dsb ld" ::: "memory")
#define wmb()    __asm__ __volatile__("dsb st" ::: "memory")
#define smp_mb() __asm__ __volatile__("dmb ish" ::: "memory")
```

### 6.4 Memory Barrier ä½¿ç”¨ç¯„ä¾‹

```c
/* ç¯„ä¾‹ 1ï¼šProducer-Consumer å•é¡Œ */

/* æ²’æœ‰ barrier çš„éŒ¯èª¤å¯«æ³• */
int data;
int ready = 0;

/* Producer */
void producer(void) {
    data = 42;       /* è¨­å®šè³‡æ–™ */
    ready = 1;       /* æ¨™è¨˜æº–å‚™å¥½äº† */
    /* å•é¡Œï¼šCPU å¯èƒ½å…ˆåŸ·è¡Œ ready = 1ï¼Œå†åŸ·è¡Œ data = 42 */
}

/* Consumer */
void consumer(void) {
    while (!ready);  /* ç­‰å¾…æº–å‚™å¥½ */
    int x = data;    /* è®€å–è³‡æ–™ */
    /* å•é¡Œï¼šå¯èƒ½è®€åˆ°èˆŠçš„ data å€¼ */
}

/* æ­£ç¢ºå¯«æ³•ï¼šä½¿ç”¨ barrier */
void producer(void) {
    data = 42;
    smp_wmb();       /* ç¢ºä¿ data å¯«å…¥åœ¨ ready ä¹‹å‰ */
    ready = 1;
}

void consumer(void) {
    while (!ready);
    smp_rmb();       /* ç¢ºä¿ ready è®€å–åœ¨ data ä¹‹å‰ */
    int x = data;
}

/* ç¯„ä¾‹ 2ï¼šRing Buffer */

struct ring_buffer {
    unsigned int head;  /* Producer æ›´æ–° */
    unsigned int tail;  /* Consumer æ›´æ–° */
    void *data[SIZE];
};

/* Producer */
void rb_push(struct ring_buffer *rb, void *item) {
    unsigned int head = rb->head;
    rb->data[head] = item;
    smp_wmb();  /* ç¢ºä¿ data å¯«å…¥åœ¨ head æ›´æ–°ä¹‹å‰ */
    rb->head = (head + 1) % SIZE;
}

/* Consumer */
void *rb_pop(struct ring_buffer *rb) {
    unsigned int tail = rb->tail;
    if (tail == rb->head)
        return NULL;
    smp_rmb();  /* ç¢ºä¿ head è®€å–åœ¨ data è®€å–ä¹‹å‰ */
    void *item = rb->data[tail];
    rb->tail = (tail + 1) % SIZE;
    return item;
}
```

---

## ğŸ”· ç¬¬ä¸ƒéƒ¨åˆ†ï¼šKernel è¨˜æ†¶é«”é…ç½®å™¨

### 7.1 Page Allocator (Buddy System)

```c
/*
 * Buddy Systemï¼šLinux çš„ Page é…ç½®å™¨
 * 
 * ä»¥ 2^n å€‹ Page ç‚ºå–®ä½é…ç½®
 * Order 0 = 1 page  (4KB)
 * Order 1 = 2 pages (8KB)
 * Order 2 = 4 pages (16KB)
 * ...
 * Order 10 = 1024 pages (4MBï¼Œé€šå¸¸æ˜¯æœ€å¤§)
 */

/* Page é…ç½® API */
struct page *alloc_pages(gfp_t gfp, unsigned int order);
unsigned long __get_free_pages(gfp_t gfp, unsigned int order);
unsigned long get_zeroed_page(gfp_t gfp);

/* ä½¿ç”¨ç¯„ä¾‹ */
struct page *page = alloc_pages(GFP_KERNEL, 0);  /* 1 page */
void *addr = page_address(page);  /* å–å¾—è™›æ“¬ä½å€ */

/* é‡‹æ”¾ */
__free_pages(page, 0);

/* GFP Flags (Get Free Pages) */
/*
 * GFP_KERNELï¼šå¯ç¡çœ ï¼Œç”¨æ–¼ä¸€èˆ¬ Kernel é…ç½®
 * GFP_ATOMICï¼šä¸å¯ç¡çœ ï¼Œç”¨æ–¼ Interrupt Context
 * GFP_DMAï¼šé…ç½® DMA å¯ç”¨çš„è¨˜æ†¶é«” (ä½ä½å€)
 * GFP_HIGHUSERï¼šé…ç½® User Space çš„ Page
 */
```

### 7.2 Slab Allocator

```c
/*
 * Slab Allocatorï¼šå°ç‰©ä»¶çš„è¨˜æ†¶é«”é…ç½®
 * 
 * å•é¡Œï¼šBuddy System æœ€å°å–®ä½æ˜¯ 4KBï¼Œé…ç½®å°ç‰©ä»¶å¤ªæµªè²»
 * è§£æ³•ï¼šSlab åœ¨ Page ä¸Šå†åˆ‡åˆ†æˆå°å¡Š
 * 
 * çµæ§‹ï¼š
 * Cache â†’ Slab â†’ Object
 *   â”‚       â”‚
 *   â”‚       â””â”€ ä¸€å€‹æˆ–å¤šå€‹ Pageï¼Œåˆ‡æˆå›ºå®šå¤§å°çš„ Object
 *   â”‚
 *   â””â”€ ç®¡ç†åŒé¡å‹ç‰©ä»¶çš„å¿«å–
 */

/* å»ºç«‹ Slab Cache */
struct kmem_cache *task_struct_cache;
task_struct_cache = kmem_cache_create(
    "task_struct",              /* åç¨± */
    sizeof(struct task_struct), /* Object å¤§å° */
    ARCH_SLAB_MINALIGN,         /* Alignment */
    SLAB_PANIC | SLAB_ACCOUNT,  /* Flags */
    NULL                        /* Constructor */
);

/* å¾ Cache é…ç½® */
struct task_struct *task = kmem_cache_alloc(task_struct_cache, GFP_KERNEL);

/* é‡‹æ”¾å› Cache */
kmem_cache_free(task_struct_cache, task);

/* kmalloc å°±æ˜¯ç”¨ Slab å¯¦ä½œçš„ */
/* Kernel é å»ºäº†å¤šç¨®å¤§å°çš„ Cacheï¼š8, 16, 32, 64, ... 4096 bytes */
void *ptr = kmalloc(100, GFP_KERNEL);  /* ä½¿ç”¨ 128-byte slab */
kfree(ptr);
```

### 7.3 vmalloc vs kmalloc

```c
/*
 * kmalloc vs vmalloc æ¯”è¼ƒ
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚            â”‚     kmalloc      â”‚     vmalloc      â”‚
 * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 * â”‚ å¯¦é«”è¨˜æ†¶é«”  â”‚ é€£çºŒ             â”‚ ä¸éœ€é€£çºŒ          â”‚
 * â”‚ è™›æ“¬è¨˜æ†¶é«”  â”‚ Linear Mapping   â”‚ vmalloc å€åŸŸ     â”‚
 * â”‚ æœ€å¤§å¤§å°    â”‚ é€šå¸¸ <= 4MB     â”‚ å¯ä»¥å¾ˆå¤§         â”‚
 * â”‚ æ•ˆèƒ½       â”‚ å¿«               â”‚ è¼ƒæ…¢ (TLB é–‹éŠ·)  â”‚
 * â”‚ ç”¨é€”       â”‚ Driver buffer    â”‚ å¤§å‹é…ç½®         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

/* kmalloc çš„å¯¦é«”è¨˜æ†¶é«”æ˜¯é€£çºŒçš„ */
void *buf = kmalloc(65536, GFP_KERNEL);  /* 64KBï¼Œå¯¦é«”é€£çºŒ */
/* å¯ä»¥ç”¨ virt_to_phys() å–å¾—å¯¦é«”ä½å€ */
phys_addr_t pa = virt_to_phys(buf);

/* vmalloc çš„å¯¦é«”è¨˜æ†¶é«”ä¸é€£çºŒ */
void *buf = vmalloc(1024 * 1024);  /* 1MBï¼Œå¯¦é«”ä¸é€£çºŒ */
/* ä¸èƒ½ç”¨ virt_to_phys()ï¼ */
/* DMA ä¸èƒ½ç›´æ¥ä½¿ç”¨ vmalloc çš„è¨˜æ†¶é«”ï¼ */

/* ä»€éº¼æ™‚å€™ç”¨ vmallocï¼Ÿ */
/* 1. éœ€è¦å¤§é‡è¨˜æ†¶é«”ä¸”ä¸éœ€è¦å¯¦é«”é€£çºŒ */
/* 2. æ¨¡çµ„è¼‰å…¥ (module code) */
/* 3. éœ€è¦å¤§çš„ buffer ä½†ä¸åš DMA */
```

---

## ğŸ“ é¢è©¦é¡Œåº«ï¼ˆç¬¬äºŒéƒ¨åˆ†ï¼‰

### Q4: è§£é‡‹ OOM Killer çš„é¸æ“‡æ©Ÿåˆ¶

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / AWS / æ™®é

**å•é¡Œ**ï¼š
ç•¶ç³»çµ±è¨˜æ†¶é«”ä¸è¶³æ™‚ï¼ŒOOM Killer å¦‚ä½•é¸æ“‡è¦ kill çš„ Processï¼Ÿå¦‚ä½•ä¿è­·é—œéµ Processï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**é¸æ“‡æ©Ÿåˆ¶**ï¼š
1. è¨ˆç®—æ¯å€‹ Process çš„ `oom_badness` åˆ†æ•¸
2. åˆ†æ•¸ = RSS + Swap + Page Table ä½”ç”¨
3. å¥—ç”¨ `oom_score_adj` èª¿æ•´
4. é¸æ“‡åˆ†æ•¸æœ€é«˜çš„ Process kill

**ä¿è­·é—œéµ Process**ï¼š
```bash
# è¨­å®š oom_score_adj = -1000
echo -1000 > /proc/<pid>/oom_score_adj
```

**å¸¸è¦‹è¨­å®š**ï¼š
- `-1000`ï¼šæ°¸é ä¸è¢« kill (å¦‚ init, sshd)
- `0`ï¼šé è¨­å€¼
- `1000`ï¼šæœ€å…ˆè¢« kill

**è¿½å•**ï¼šå¦‚ä½•å®Œå…¨é¿å… OOMï¼Ÿ
1. é—œé–‰ Overcommitï¼š`echo 2 > /proc/sys/vm/overcommit_memory`
2. ä½¿ç”¨ cgroups é™åˆ¶è¨˜æ†¶é«”ï¼š`memory.max`
3. å¢åŠ  Swap ç©ºé–“

---

### Q5: Memory Barrier çš„ä½œç”¨æ˜¯ä»€éº¼ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Intel / AMD

**å•é¡Œ**ï¼š
ç‚ºä»€éº¼åœ¨å¤šæ ¸å¿ƒç¨‹å¼è¨­è¨ˆä¸­éœ€è¦ Memory Barrierï¼ŸARM å’Œ x86 çš„å·®ç•°æ˜¯ä»€éº¼ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**éœ€è¦ Memory Barrier çš„åŸå› **ï¼š
1. **ç·¨è­¯å™¨å„ªåŒ–**ï¼šç·¨è­¯å™¨å¯èƒ½é‡æ’æŒ‡ä»¤
2. **CPU äº‚åºåŸ·è¡Œ**ï¼šç¾ä»£ CPU æœƒäº‚åºåŸ·è¡ŒæŒ‡ä»¤
3. **Store Buffer**ï¼šå¯«å…¥ä¸ç«‹å³å°å…¶ä»–æ ¸å¿ƒå¯è¦‹
4. **Cache ä¸€è‡´æ€§å»¶é²**ï¼šMESI å”è­°æœ‰å»¶é²

**ARM vs x86**ï¼š
| ç‰¹æ€§ | x86 (TSO) | ARM (Weak) |
|:---|:---|:---|
| Store-Store | æœ‰åº | éœ€è¦ barrier |
| Load-Load | æœ‰åº | éœ€è¦ barrier |
| Store-Load | éœ€è¦ barrier | éœ€è¦ barrier |
| Load-Store | æœ‰åº | éœ€è¦ barrier |

**ARM éœ€è¦æ›´å¤š barrierï¼**

**ç¯„ä¾‹**ï¼š
```c
/* ARM ä¸Šçš„æ­£ç¢ºå¯«æ³• */
void producer(void) {
    data = 42;
    smp_wmb();  /* ARM å¿…é ˆ */
    ready = 1;
}

void consumer(void) {
    while (!ready);
    smp_rmb();  /* ARM å¿…é ˆ */
    use(data);
}
```

---

### Q6: kmalloc å’Œ vmalloc çš„å·®åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
kmalloc() å’Œ vmalloc() æœ‰ä»€éº¼å·®åˆ¥ï¼Ÿä»€éº¼æ™‚å€™ç”¨å“ªå€‹ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | kmalloc | vmalloc |
|:---|:---|:---|
| å¯¦é«”è¨˜æ†¶é«” | é€£çºŒ | ä¸éœ€é€£çºŒ |
| æœ€å¤§å¤§å° | ~4MB | å¾ˆå¤§ |
| æ•ˆèƒ½ | å¿« | è¼ƒæ…¢ |
| DMA | å¯ä»¥ | ä¸å¯ä»¥ |
| ä½å€è½‰æ› | virt_to_phys() å¯ç”¨ | ä¸å¯ç”¨ |

**ä½¿ç”¨æ™‚æ©Ÿ**ï¼š
- **kmalloc**ï¼šDriver bufferã€éœ€è¦ DMAã€å°é…ç½®
- **vmalloc**ï¼šå¤§å‹é…ç½®ã€ä¸éœ€è¦å¯¦é«”é€£çºŒã€æ¨¡çµ„è¼‰å…¥

**ç¨‹å¼ç¢¼ç¯„ä¾‹**ï¼š
```c
/* DMA buffer ç”¨ kmalloc */
void *dma_buf = kmalloc(4096, GFP_KERNEL | GFP_DMA);
dma_addr_t pa = virt_to_phys(dma_buf);

/* å¤§å‹ lookup table ç”¨ vmalloc */
int *table = vmalloc(1024 * 1024 * sizeof(int));
/* æ³¨æ„ï¼šä¸èƒ½ç”¨ virt_to_phys()ï¼ */
```

---

### Q7: è§£é‡‹ ARM64 çš„å››ç´šé è¡¨çµæ§‹

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šARM / Apple / NVIDIA

**å•é¡Œ**ï¼š
è«‹è©³ç´°è§£é‡‹ ARM64 çš„å››ç´šé è¡¨çµæ§‹ï¼Œä¸¦èªªæ˜ Page Table Walk çš„éç¨‹ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**å››ç´šé è¡¨ (4KB Page, 48-bit VA)**ï¼š
```
Virtual Address [47:0]:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 47:39  â”‚ 38:30  â”‚ 29:21  â”‚ 20:12  â”‚    11:0        â”‚
â”‚ L0 idx â”‚ L1 idx â”‚ L2 idx â”‚ L3 idx â”‚   Offset       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  (PGD)    (PUD)    (PMD)    (PTE)     (Pageå…§åç§»)
```

**Page Table Walk éç¨‹**ï¼š
1. å¾ `TTBR0/TTBR1` å–å¾— L0 Table åŸºåº•
2. `L0[VA[47:39]]` â†’ L1 Table ä½å€
3. `L1[VA[38:30]]` â†’ L2 Table ä½å€
4. `L2[VA[29:21]]` â†’ L3 Table ä½å€
5. `L3[VA[20:12]]` â†’ Physical Page Frame
6. PFN + Offset = Physical Address

**TTBR é¸æ“‡**ï¼š
- `VA[63] = 0` â†’ ä½¿ç”¨ TTBR0 (User Space)
- `VA[63] = 1` â†’ ä½¿ç”¨ TTBR1 (Kernel Space)

---

### Q8: Demand Paging å¦‚ä½•é‹ä½œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
è§£é‡‹ Demand Paging æ©Ÿåˆ¶åŠå…¶å„ªé»ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**Demand Paging æ©Ÿåˆ¶**ï¼š
1. `mmap()`/`malloc()` åªå»ºç«‹ VMAï¼Œä¸é…ç½®å¯¦é«”è¨˜æ†¶é«”
2. ç¬¬ä¸€æ¬¡å­˜å–æ™‚è§¸ç™¼ Page Fault
3. Kernel é…ç½®å¯¦é«” Page ä¸¦å»ºç«‹ PTE
4. é‡è©¦å­˜å–ï¼ŒæˆåŠŸåŸ·è¡Œ

**å„ªé»**ï¼š
1. **æ¸›å°‘è¨˜æ†¶é«”æµªè²»**ï¼šæœªä½¿ç”¨çš„ Page ä¸é…ç½®
2. **åŠ å¿«ç¨‹å¼å•Ÿå‹•**ï¼šä¸éœ€ç­‰å¾…è¼‰å…¥æ‰€æœ‰ Page
3. **æ”¯æ´ COW**ï¼šfork() å¯ä»¥å¾ˆå¿«
4. **æ”¯æ´ Lazy Allocation**ï¼šmalloc å¤§å¡Šè¨˜æ†¶é«”å¾ˆå¿«

**ç¨‹å¼ç¢¼æµç¨‹**ï¼š
```c
/* mmap æ™‚ */
void *ptr = mmap(NULL, 4096, PROT_READ|PROT_WRITE, 
                 MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
/* æ­¤æ™‚æ²’æœ‰é…ç½®å¯¦é«”è¨˜æ†¶é«” */

/* ç¬¬ä¸€æ¬¡å¯«å…¥ */
*ptr = 42;  /* Page Fault! */
/* Kernel: é…ç½® Page, å»ºç«‹ PTE, è¿”å› */
/* ç¾åœ¨å¯ä»¥æ­£å¸¸å­˜å–äº† */
```

---

### Q9: ä»€éº¼æ˜¯ ASIDï¼Ÿç‚ºä»€éº¼éœ€è¦å®ƒï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šARM / Qualcomm

**å•é¡Œ**ï¼š
è§£é‡‹ ASID çš„ä½œç”¨åŠå…¶å°æ•ˆèƒ½çš„å½±éŸ¿ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**ASID (Address Space ID)**ï¼š
- 16-bit æ¨™è­˜ç¬¦ï¼ˆARM64 æœ€å¤š 65536 å€‹ï¼‰
- å­˜åœ¨æ¯å€‹ TLB entry ä¸­
- å€åˆ†ä¸åŒ Process çš„ Page Table

**æ²’æœ‰ ASID çš„å•é¡Œ**ï¼š
```
Context Switch:
Process A â†’ flush TLB â†’ Process B
           (æ¸…ç©ºæ‰€æœ‰ TLB entry)
```
æ¯æ¬¡ Context Switch éƒ½ flush TLB â†’ TLB warm-up æˆæœ¬é«˜

**æœ‰ ASID çš„å„ªåŒ–**ï¼š
```
Context Switch:
Process A (ASID=1) â†’ åˆ‡æ› TTBR + ASID â†’ Process B (ASID=2)
                     (TLB ä¿ç•™ï¼)
```
ä¸åŒ ASID çš„ TLB entry å¯ä»¥å…±å­˜

**æ•ˆèƒ½å½±éŸ¿**ï¼š
- æ¸›å°‘ TLB miss
- åŠ å¿« Context Switch
- ç•¶ ASID ç”¨å®Œæ™‚éœ€è¦ global flush

---

### Q10: å¦‚ä½• Debug OOM å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šAWS / Google Cloud

**å•é¡Œ**ï¼š
ç”Ÿç”¢ç’°å¢ƒç™¼ç”Ÿ OOMï¼Œå¦‚ä½•è¨ºæ–·å’Œè§£æ±ºï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**1. æŸ¥çœ‹ dmesg æ—¥èªŒ**ï¼š
```bash
dmesg | grep -i oom
# æ‰¾åˆ°è¢« kill çš„ process å’Œè¨˜æ†¶é«”ä½¿ç”¨æƒ…æ³
```

**2. åˆ†æ OOM æ—¥èªŒé—œéµè³‡è¨Š**ï¼š
```
Out of memory: Killed process 12345 (java)
  total-vm:8388608kB  â† è™›æ“¬è¨˜æ†¶é«”
  anon-rss:4194304kB  â† åŒ¿åè¨˜æ†¶é«”ï¼ˆä¸»è¦ï¼‰
  file-rss:12345kB    â† File-backed
```

**3. æŸ¥çœ‹ç³»çµ±è¨˜æ†¶é«”ç‹€æ…‹**ï¼š
```bash
cat /proc/meminfo
free -h
vmstat 1
```

**4. é é˜²æªæ–½**ï¼š
```bash
# ä¿è­·é—œéµæœå‹™
echo -1000 > /proc/$(pidof sshd)/oom_score_adj

# é™åˆ¶å•é¡Œ Process
echo 500 > /proc/$(pidof java)/oom_score_adj

# æˆ–ä½¿ç”¨ cgroups
echo 4G > /sys/fs/cgroup/myapp/memory.max
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **Linux Kernel Development** - Robert Love (Chapter 12: Memory Management)
2. **Understanding the Linux Virtual Memory Manager** - Mel Gorman
3. **Linux Kernel Source** - mm/memory.c, mm/oom_kill.c
4. **ARM Architecture Reference Manual** - Chapter D5 (Memory Management)
5. **LWN.net Articles**:
   - [The OOM killer](https://lwn.net/Kernel/Index/#OOM_killer)
   - [Memory barriers](https://lwn.net/Articles/573436/)


