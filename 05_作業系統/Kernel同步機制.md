# ğŸ”’ Linux Kernel åŒæ­¥æ©Ÿåˆ¶å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£ Spinlock çš„å¯¦ä½œåŸç†èˆ‡ä½¿ç”¨å ´æ™¯
> 2. æŒæ¡ Mutex èˆ‡ Spinlock çš„å·®ç•°åŠé¸æ“‡æ¨™æº–
> 3. ç†è§£ Semaphoreã€RCUã€Completion ç­‰é€²éšåŒæ­¥æ©Ÿåˆ¶
> 4. ç²¾é€š Deadlock çš„é é˜²èˆ‡ lockdep è¨ºæ–·å·¥å…·
> 5. èƒ½å¤ æ ¹æ“šå ´æ™¯é¸æ“‡æ­£ç¢ºçš„åŒæ­¥æ©Ÿåˆ¶

---

## ğŸ”· ç¬¬ä¸€éƒ¨åˆ†ï¼šç‚ºä»€éº¼éœ€è¦åŒæ­¥ï¼Ÿ

### 1.1 Race Condition å•é¡Œ

```c
/*
 * Race Conditionï¼ˆç«¶æ…‹æ¢ä»¶ï¼‰ç¯„ä¾‹
 * 
 * å•é¡Œå ´æ™¯ï¼šå…©å€‹ CPU åŒæ™‚æ“ä½œå…±äº«è®Šæ•¸
 */

/* å…¨åŸŸè¨ˆæ•¸å™¨ */
int counter = 0;

/* CPU 0 åŸ·è¡Œ */
void increment_cpu0(void) {
    int temp = counter;   /* è®€å–ï¼štemp = 0 */
    temp = temp + 1;      /* è¨ˆç®—ï¼štemp = 1 */
    counter = temp;       /* å¯«å…¥ï¼šcounter = 1 */
}

/* CPU 1 åŒæ™‚åŸ·è¡Œ */
void increment_cpu1(void) {
    int temp = counter;   /* è®€å–ï¼štemp = 0 (é‚„æ²’çœ‹åˆ° CPU 0 çš„æ›´æ–°) */
    temp = temp + 1;      /* è¨ˆç®—ï¼štemp = 1 */
    counter = temp;       /* å¯«å…¥ï¼šcounter = 1 */
}

/* çµæœï¼šcounter = 1ï¼Œè€Œä¸æ˜¯é æœŸçš„ 2ï¼ */
/* é€™å°±æ˜¯ Race Condition */
```

### 1.2 Critical Sectionï¼ˆè‡¨ç•Œå€ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è‡¨ç•Œå€æ¦‚å¿µ                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  è‡¨ç•Œå€ (Critical Section)ï¼š                                  â”‚
â”‚  - å­˜å–å…±äº«è³‡æºçš„ç¨‹å¼ç¢¼å€æ®µ                                    â”‚
â”‚  - ä¸€æ¬¡åªèƒ½æœ‰ä¸€å€‹åŸ·è¡Œè·¯å¾‘é€²å…¥                                  â”‚
â”‚  - éœ€è¦åŒæ­¥æ©Ÿåˆ¶ä¿è­·                                           â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚  spin_lock(&lock);        â† é€²å…¥è‡¨ç•Œå€  â”‚                â”‚
â”‚  â”‚                                          â”‚                â”‚
â”‚  â”‚  /* å­˜å–å…±äº«è³‡æ–™çš„ç¨‹å¼ç¢¼ */               â”‚                â”‚
â”‚  â”‚  shared_data++;                          â”‚                â”‚
â”‚  â”‚                                          â”‚                â”‚
â”‚  â”‚  spin_unlock(&lock);      â† é›¢é–‹è‡¨ç•Œå€  â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                                                              â”‚
â”‚  åŒæ­¥æ©Ÿåˆ¶çš„å·¥ä½œï¼š                                             â”‚
â”‚  - ç¢ºä¿è‡¨ç•Œå€çš„äº’æ–¥æ€§ (Mutual Exclusion)                      â”‚
â”‚  - ç¢ºä¿è¨˜æ†¶é«”å¯è¦‹æ€§ (Visibility)                              â”‚
â”‚  - ç¢ºä¿é †åºæ€§ (Ordering)                                      â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 Kernel ä¸­éœ€è¦åŒæ­¥çš„å ´æ™¯

```c
/*
 * Kernel ä¸­å¸¸è¦‹çš„éœ€è¦åŒæ­¥çš„å ´æ™¯
 */

/* 1. å¤š CPU åŒæ™‚å­˜å–å…±äº«è³‡æ–™ */
struct device_data {
    int status;
    char buffer[1024];
};
/* ä»»ä½• CPU éƒ½å¯èƒ½å­˜å– device_data */

/* 2. Process Context èˆ‡ Interrupt Context å…±äº«è³‡æ–™ */
static int irq_counter = 0;

/* Process Context */
void read_counter(void) {
    int val = irq_counter;  /* å¯èƒ½è¢«ä¸­æ–·æ‰“æ–· */
    printk("counter = %d\n", val);
}

/* Interrupt Handler */
irqreturn_t irq_handler(int irq, void *dev) {
    irq_counter++;  /* å¯èƒ½åŒæ™‚è¢« Process Context è®€å– */
    return IRQ_HANDLED;
}

/* 3. Softirq/Tasklet èˆ‡ Process Context */
/* 4. ä¸åŒ Softirq ä¹‹é–“ */
/* 5. Workqueue ä¸­çš„ä¸¦è¡Œä»»å‹™ */
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šSpinlockï¼ˆè‡ªæ—‹é–ï¼‰

### 2.1 Spinlock åŸºæœ¬åŸç†

```c
/*
 * Spinlock å·¥ä½œåŸç†ï¼š
 * - å˜—è©¦å–å¾—é–ï¼Œå¦‚æœå¤±æ•—å°±ã€Œè‡ªæ—‹ã€ç­‰å¾…
 * - è‡ªæ—‹ = ä¸åœåœ°æª¢æŸ¥é–çš„ç‹€æ…‹ï¼Œä¸è®“å‡º CPU
 * - é©åˆçŸ­æ™‚é–“æŒæœ‰çš„è‡¨ç•Œå€
 */

/* æ¦‚å¿µæ€§çš„ Spinlock å¯¦ä½œ */
typedef struct {
    volatile int locked;
} spinlock_t;

void spin_lock(spinlock_t *lock) {
    while (1) {
        /* å˜—è©¦å°‡ locked å¾ 0 æ”¹æˆ 1 */
        if (atomic_cmpxchg(&lock->locked, 0, 1) == 0) {
            /* æˆåŠŸå–å¾—é– */
            break;
        }
        /* å¤±æ•—ï¼Œç¹¼çºŒè‡ªæ—‹ */
        cpu_relax();  /* çµ¦ CPU ä¸€é»å–˜æ¯ */
    }
}

void spin_unlock(spinlock_t *lock) {
    lock->locked = 0;
}
```

### 2.2 Spinlock API

```c
/* Linux Kernel Spinlock API */
#include <linux/spinlock.h>

/* å®šç¾©èˆ‡åˆå§‹åŒ– */
spinlock_t my_lock;
spin_lock_init(&my_lock);

/* æˆ–éœæ…‹åˆå§‹åŒ– */
DEFINE_SPINLOCK(my_lock);

/* åŸºæœ¬æ“ä½œ */
spin_lock(&my_lock);      /* å–å¾—é– */
/* è‡¨ç•Œå€ */
spin_unlock(&my_lock);    /* é‡‹æ”¾é– */

/* å˜—è©¦å–å¾—ï¼ˆéé˜»å¡ï¼‰*/
if (spin_trylock(&my_lock)) {
    /* æˆåŠŸå–å¾— */
    spin_unlock(&my_lock);
}

/* æª¢æŸ¥æ˜¯å¦å·²è¢«é–å®š */
if (spin_is_locked(&my_lock)) {
    /* å·²è¢«é–å®š */
}
```

### 2.3 Spinlock èˆ‡ä¸­æ–·

```c
/*
 * å•é¡Œï¼šåœ¨ Process Context æŒæœ‰ Spinlock æ™‚è¢«ä¸­æ–·
 * 
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚  Timeline:                                              â”‚
 * â”‚                                                         â”‚
 * â”‚  Process Context:                                       â”‚
 * â”‚    spin_lock(&lock)    â”€â”€â”€ å–å¾—é–                       â”‚
 * â”‚    /* è‡¨ç•Œå€ */                                         â”‚
 * â”‚         â”‚                                               â”‚
 * â”‚         â†“ IRQ ç™¼ç”Ÿï¼                                    â”‚
 * â”‚                                                         â”‚
 * â”‚  Interrupt Handler:                                     â”‚
 * â”‚    spin_lock(&lock)    â”€â”€â”€ å˜—è©¦å–å¾—åŒä¸€å€‹é–              â”‚
 * â”‚    /* æ°¸é è‡ªæ—‹ï¼Deadlockï¼ */                           â”‚
 * â”‚                                                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 */

/* è§£æ³•ï¼šspin_lock_irq / spin_lock_irqsave */

/* æ–¹æ³• 1ï¼šspin_lock_irq (ç¢ºå®š IRQ æ˜¯é–‹å•Ÿçš„) */
spin_lock_irq(&my_lock);    /* å–å¾—é– + é—œé–‰ä¸­æ–· */
/* è‡¨ç•Œå€ */
spin_unlock_irq(&my_lock);  /* é‡‹æ”¾é– + é–‹å•Ÿä¸­æ–· */

/* æ–¹æ³• 2ï¼šspin_lock_irqsave (ä¿å­˜ IRQ ç‹€æ…‹) */
unsigned long flags;
spin_lock_irqsave(&my_lock, flags);  /* å–å¾—é– + ä¿å­˜ä¸¦é—œé–‰ IRQ */
/* è‡¨ç•Œå€ */
spin_unlock_irqrestore(&my_lock, flags);  /* é‡‹æ”¾é– + æ¢å¾© IRQ */

/* spin_lock_irqsave æ›´å®‰å…¨ï¼Œå› ç‚ºï¼š
 * - åœ¨åµŒå¥—å‘¼å«æ™‚æ­£ç¢ºæ¢å¾© IRQ ç‹€æ…‹
 * - è¢«ä¸­æ–·æ™‚ï¼ˆIRQ å·²é—œé–‰ï¼‰ä¹Ÿèƒ½æ­£å¸¸é‹ä½œ
 */
```

### 2.4 Spinlock çš„é¸æ“‡æŒ‡å—

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Spinlock è®Šé«”é¸æ“‡æŒ‡å—                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä½¿ç”¨å ´æ™¯          â”‚ æ‡‰è©²ç”¨å“ªå€‹ï¼Ÿ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Process Context  â”‚ spin_lock()                              â”‚
â”‚ (ç„¡ä¸­æ–·å…±äº«)      â”‚                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Process Context  â”‚ spin_lock_irqsave()                      â”‚
â”‚ + Hardirq å…±äº«   â”‚ â† æœ€å¸¸ç”¨ï¼                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Process Context  â”‚ spin_lock_bh()                           â”‚
â”‚ + Softirq å…±äº«   â”‚ é—œé–‰ Bottom-half                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Hardirq Handler  â”‚ spin_lock()                              â”‚
â”‚ (å–® CPU)         â”‚ IRQ å·²é—œé–‰                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Hardirq Handler  â”‚ spin_lock()                              â”‚
â”‚ + å…¶ä»– CPU       â”‚ å·²åœ¨ IRQ context                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.5 Spinlock å¯¦ä½œç´°ç¯€ (ARM64)

```c
/* ARM64 Spinlock å¯¦ä½œ (arch/arm64/include/asm/spinlock.h) */
/* Kernel v6.x ä½¿ç”¨ queued spinlock */

/* æ¦‚å¿µæ€§çš„ ARM64 spinlock å¯¦ä½œ */
static inline void arch_spin_lock(arch_spinlock_t *lock)
{
    unsigned int tmp;
    arch_spinlock_t lockval, newval;
    
    asm volatile(
    "   prfm    pstl1strm, %3\n"      /* Prefetch for store */
    "1: ldaxr   %w0, %3\n"            /* Load-Acquire Exclusive */
    "   add     %w1, %w0, #(1 << 16)\n" /* å¢åŠ  tail */
    "   stxr    %w2, %w1, %3\n"       /* Store Exclusive */
    "   cbnz    %w2, 1b\n"            /* å¤±æ•—å‰‡é‡è©¦ */
    /* ç¾åœ¨ lockval.tail æ˜¯æˆ‘å€‘çš„ ticket */
    : "=&r" (lockval), "=&r" (newval), "=&r" (tmp), "+Q" (*lock)
    :
    : "memory"
    );
    
    /* ç­‰å¾…æˆ‘å€‘çš„ ticket è¢« served */
    while (lockval.tail != lockval.head) {
        wfe();  /* Wait for Event - çœé›» */
        lockval.head = READ_ONCE(lock->head);
    }
}

static inline void arch_spin_unlock(arch_spinlock_t *lock)
{
    asm volatile(
    "   stlrh   %w1, %0\n"  /* Store-Releaseï¼šå¢åŠ  head */
    "   sev\n"               /* Send Eventï¼šå–šé†’ç­‰å¾…çš„ CPU */
    : "=Q" (lock->head)
    : "r" (lock->head + 1)
    : "memory"
    );
}
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šMutexï¼ˆäº’æ–¥é–ï¼‰

### 3.1 Mutex vs Spinlock

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Mutex vs Spinlock æ¯”è¼ƒ                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç‰¹æ€§           â”‚ Spinlock          â”‚ Mutex                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç­‰å¾…æ–¹å¼       â”‚ è‡ªæ—‹ï¼ˆå¿™ç­‰å¾…ï¼‰     â”‚ ç¡çœ ï¼ˆè®“å‡º CPUï¼‰         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¯ç¡çœ ï¼Ÿ       â”‚ âŒ ä¸å¯ä»¥          â”‚ âœ… å¯ä»¥                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Interrupt Context? â”‚ âœ… å¯ä»¥      â”‚ âŒ ä¸å¯ä»¥                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æŒæœ‰æ™‚é–“       â”‚ çŸ­ï¼ˆå¾®ç§’ç´šï¼‰       â”‚ é•·ï¼ˆå¯ä»¥å¾ˆé•·ï¼‰           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é©ç”¨å ´æ™¯       â”‚ ç°¡å–®çš„è³‡æ–™ä¿è­·    â”‚ è¤‡é›œæ“ä½œã€I/O            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CPU é–‹éŠ·       â”‚ é«˜ï¼ˆæŒçºŒä½”ç”¨ï¼‰     â”‚ ä½ï¼ˆç­‰å¾…æ™‚è®“å‡ºï¼‰         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è¨˜æ†¶é«”é…ç½®     â”‚ ä¸å¯               â”‚ å¯ä»¥ (GFP_KERNEL)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ copy_from_user â”‚ ä¸å¯               â”‚ å¯ä»¥                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Mutex API

```c
/* Linux Kernel Mutex API */
#include <linux/mutex.h>

/* å®šç¾©èˆ‡åˆå§‹åŒ– */
struct mutex my_mutex;
mutex_init(&my_mutex);

/* æˆ–éœæ…‹åˆå§‹åŒ– */
DEFINE_MUTEX(my_mutex);

/* åŸºæœ¬æ“ä½œ */
mutex_lock(&my_mutex);    /* å–å¾—é–ï¼ˆå¯èƒ½ç¡çœ ï¼‰*/
/* è‡¨ç•Œå€ï¼šå¯ä»¥åšæœƒç¡çœ çš„æ“ä½œ */
mutex_unlock(&my_mutex);  /* é‡‹æ”¾é– */

/* å¯ä¸­æ–·ç‰ˆæœ¬ */
if (mutex_lock_interruptible(&my_mutex)) {
    /* è¢« signal ä¸­æ–· */
    return -ERESTARTSYS;
}
/* è‡¨ç•Œå€ */
mutex_unlock(&my_mutex);

/* å˜—è©¦å–å¾—ï¼ˆéé˜»å¡ï¼‰*/
if (mutex_trylock(&my_mutex)) {
    /* æˆåŠŸå–å¾— */
    mutex_unlock(&my_mutex);
}

/* killable ç‰ˆæœ¬ï¼ˆåªéŸ¿æ‡‰ SIGKILLï¼‰*/
if (mutex_lock_killable(&my_mutex)) {
    return -EINTR;
}
```

### 3.3 Mutex ä½¿ç”¨è¦å‰‡

```c
/*
 * Mutex ä½¿ç”¨è¦å‰‡ï¼ˆé•åæœƒè¢« lockdep è­¦å‘Šï¼ï¼‰
 */

/* è¦å‰‡ 1ï¼šåŒä¸€å€‹ Context é‡‹æ”¾ */
void bad_usage(void) {
    mutex_lock(&my_mutex);
}
void bad_unlock(void) {
    mutex_unlock(&my_mutex);  /* âŒ ä¸åŒå‡½å¼é‡‹æ”¾ */
}

/* è¦å‰‡ 2ï¼šä¸èƒ½åœ¨ Interrupt Context ä½¿ç”¨ */
irqreturn_t bad_irq_handler(int irq, void *dev) {
    mutex_lock(&my_mutex);  /* âŒ IRQ ä¸­ä¸èƒ½ç¡çœ  */
    mutex_unlock(&my_mutex);
    return IRQ_HANDLED;
}

/* è¦å‰‡ 3ï¼šä¸èƒ½éè¿´å–å¾—ï¼ˆé™¤éç”¨ mutex_lock_nestedï¼‰*/
void bad_recursive(void) {
    mutex_lock(&my_mutex);
    mutex_lock(&my_mutex);  /* âŒ Deadlockï¼ */
}

/* è¦å‰‡ 4ï¼šæŒæœ‰è€…ä¸èƒ½ exit */
void bad_exit(void) {
    mutex_lock(&my_mutex);
    do_exit(0);  /* âŒ æ°¸é ä¸æœƒ unlock */
}
```

### 3.4 Priority Inversion å•é¡Œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Priority Inversionï¼ˆå„ªå…ˆæ¬Šåè½‰ï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  å•é¡Œæƒ…å¢ƒï¼š                                                   â”‚
â”‚                                                              â”‚
â”‚  Low Priority Task (L)ï¼šæŒæœ‰ Mutex                           â”‚
â”‚  Medium Priority Task (M)ï¼šä¸éœ€è¦ Mutexï¼Œä½†ä½”ç”¨ CPU          â”‚
â”‚  High Priority Task (H)ï¼šç­‰å¾… Mutex                          â”‚
â”‚                                                              â”‚
â”‚  Timeline:                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€            â”‚
â”‚  1. L å–å¾— Mutexï¼Œé–‹å§‹åŸ·è¡Œ                                   â”‚
â”‚  2. H å–šé†’ï¼Œå˜—è©¦å–å¾— Mutexï¼Œè¢« Block                         â”‚
â”‚  3. M å–šé†’ï¼Œæ¶ä½” Lï¼ˆM å„ªå…ˆæ¬Šè¼ƒé«˜ï¼‰                           â”‚
â”‚  4. H å¿…é ˆç­‰å¾… M åŸ·è¡Œå®Œï¼ŒM æ‰è®“çµ¦ Lï¼ŒL æ‰èƒ½é‡‹æ”¾ Mutex        â”‚
â”‚                                                              â”‚
â”‚  çµæœï¼šH (é«˜å„ªå…ˆæ¬Š) è¢« M (ä¸­å„ªå…ˆæ¬Š) é˜»æ“‹ï¼                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è§£æ³•ï¼šPriority Inheritanceï¼ˆå„ªå…ˆæ¬Šç¹¼æ‰¿ï¼‰

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  rt_mutexï¼šæ”¯æ´ Priority Inheritance çš„ Mutex                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  ç•¶ H ç­‰å¾… L æŒæœ‰çš„é–æ™‚ï¼š                                     â”‚
â”‚  â†’ L æš«æ™‚ç¹¼æ‰¿ H çš„å„ªå…ˆæ¬Š                                     â”‚
â”‚  â†’ M ç„¡æ³•æ¶ä½” L                                              â”‚
â”‚  â†’ L å®Œæˆå¾Œé‡‹æ”¾é–ï¼ŒH ç«‹å³åŸ·è¡Œ                                â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```c
/* rt_mutex API */
#include <linux/rtmutex.h>

struct rt_mutex my_rtmutex;
rt_mutex_init(&my_rtmutex);

rt_mutex_lock(&my_rtmutex);
/* è‡¨ç•Œå€ */
rt_mutex_unlock(&my_rtmutex);
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šSemaphoreï¼ˆä¿¡è™Ÿé‡ï¼‰

### 4.1 Semaphore æ¦‚å¿µ

```c
/*
 * Semaphoreï¼ˆä¿¡è™Ÿé‡ï¼‰
 * - è¨ˆæ•¸å™¨å‹çš„åŒæ­¥æ©Ÿåˆ¶
 * - å…è¨±å¤šå€‹ã€Œè³‡æºã€åŒæ™‚è¢«å­˜å–ï¼ˆcount > 1ï¼‰
 * - count = 1 æ™‚é¡ä¼¼ Mutexï¼ˆä½†æœ‰å·®ç•°ï¼‰
 */

/* æ¦‚å¿µæ€§å¯¦ä½œ */
struct semaphore {
    int count;              /* å¯ç”¨è³‡æºæ•¸ */
    struct list_head wait;  /* ç­‰å¾…ä½‡åˆ— */
    spinlock_t lock;        /* ä¿è­· count å’Œ wait */
};

void down(struct semaphore *sem) {
    spin_lock(&sem->lock);
    if (sem->count > 0) {
        sem->count--;  /* å–å¾—ä¸€å€‹è³‡æº */
        spin_unlock(&sem->lock);
    } else {
        /* åŠ å…¥ç­‰å¾…ä½‡åˆ—ï¼Œç¡çœ  */
        add_to_wait(&sem->wait);
        spin_unlock(&sem->lock);
        schedule();  /* è®“å‡º CPU */
    }
}

void up(struct semaphore *sem) {
    spin_lock(&sem->lock);
    if (list_empty(&sem->wait)) {
        sem->count++;  /* æ²’äººç­‰å¾…ï¼Œå¢åŠ è¨ˆæ•¸ */
    } else {
        /* å–šé†’ä¸€å€‹ç­‰å¾…è€… */
        wake_up_one(&sem->wait);
    }
    spin_unlock(&sem->lock);
}
```

### 4.2 Semaphore API

```c
/* Linux Kernel Semaphore API */
#include <linux/semaphore.h>

/* å®šç¾©èˆ‡åˆå§‹åŒ– */
struct semaphore my_sem;
sema_init(&my_sem, 3);  /* åˆå§‹è¨ˆæ•¸ = 3 */

/* æˆ–éœæ…‹åˆå§‹åŒ– */
DEFINE_SEMAPHORE(my_sem);  /* count = 1 */

/* åŸºæœ¬æ“ä½œ */
down(&my_sem);            /* P æ“ä½œï¼šå–å¾—è³‡æºï¼ˆå¯èƒ½ç¡çœ ï¼‰*/
/* ä½¿ç”¨è³‡æº */
up(&my_sem);              /* V æ“ä½œï¼šé‡‹æ”¾è³‡æº */

/* å¯ä¸­æ–·ç‰ˆæœ¬ */
if (down_interruptible(&my_sem)) {
    return -ERESTARTSYS;
}

/* å˜—è©¦å–å¾—ï¼ˆéé˜»å¡ï¼‰*/
if (down_trylock(&my_sem)) {
    /* æ²’æœ‰è³‡æºå¯ç”¨ */
}

/* killable ç‰ˆæœ¬ */
if (down_killable(&my_sem)) {
    return -EINTR;
}
```

### 4.3 Semaphore vs Mutex

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Semaphore vs Mutex                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç‰¹æ€§           â”‚ Semaphore         â”‚ Mutex                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è¨ˆæ•¸           â”‚ å¯ä»¥ > 1          â”‚ åªèƒ½ 0 æˆ– 1             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ“æœ‰è€…æ¦‚å¿µ     â”‚ âŒ ç„¡              â”‚ âœ… æœ‰                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å¯ç”±ä»–äººé‡‹æ”¾   â”‚ âœ… å¯ä»¥            â”‚ âŒ å¿…é ˆåŒä¸€ owner       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Priority Inheritâ”‚ âŒ ç„¡            â”‚ âœ… rt_mutex æ”¯æ´         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Debug æ”¯æ´     â”‚ è¼ƒå°‘              â”‚ lockdep å®Œæ•´æ”¯æ´        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å»ºè­°ç”¨é€”       â”‚ è³‡æºæ±             â”‚ äº’æ–¥å­˜å–                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç¾ä»£ Kernel å»ºè­°ï¼š
- äº’æ–¥å­˜å– â†’ ç”¨ Mutex
- å¤šè³‡æºç®¡ç† â†’ ç”¨ Semaphore
- æ–° code ä¸€èˆ¬å„ªå…ˆç”¨ Mutex
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šRCU (Read-Copy-Update)

### 5.1 RCU æ¦‚å¿µ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RCU (Read-Copy-Update) æ¦‚å¿µ                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  æƒ…å¢ƒï¼šè®€å¤šå¯«å°‘çš„è³‡æ–™çµæ§‹                                     â”‚
â”‚                                                              â”‚
â”‚  å‚³çµ±é–çš„å•é¡Œï¼š                                               â”‚
â”‚  - å³ä½¿è®€å–ä¸è¡çªï¼Œä¹Ÿéœ€è¦å–å¾—é–                               â”‚
â”‚  - é«˜é »è®€å–æœƒé€ æˆå¤§é‡é–ç«¶çˆ­                                   â”‚
â”‚                                                              â”‚
â”‚  RCU çš„è§£æ³•ï¼š                                                 â”‚
â”‚  - è®€å–å®Œå…¨ç„¡é–ï¼                                             â”‚
â”‚  - å¯«å…¥æ™‚å…ˆè¤‡è£½ã€ä¿®æ”¹ã€å†åŸå­æ›¿æ›                             â”‚
â”‚  - ç­‰å¾…æ‰€æœ‰é€²è¡Œä¸­çš„è®€å–å®Œæˆå¾Œï¼Œæ‰é‡‹æ”¾èˆŠè³‡æ–™                   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                     RCU æ›´æ–°æµç¨‹                        â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  1. Read (ç„¡é–)ï¼š                                       â”‚ â”‚
â”‚  â”‚     rcu_read_lock()                                     â”‚ â”‚
â”‚  â”‚     ptr = rcu_dereference(global_ptr)                   â”‚ â”‚
â”‚  â”‚     /* ä½¿ç”¨ ptr */                                      â”‚ â”‚
â”‚  â”‚     rcu_read_unlock()                                   â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  2. Update (è¤‡è£½-ä¿®æ”¹-æ›¿æ›)ï¼š                            â”‚ â”‚
â”‚  â”‚     new_ptr = kmalloc(...)                              â”‚ â”‚
â”‚  â”‚     copy_data(old_ptr, new_ptr)                         â”‚ â”‚
â”‚  â”‚     modify(new_ptr)                                     â”‚ â”‚
â”‚  â”‚     rcu_assign_pointer(global_ptr, new_ptr)  â† åŸå­æ›¿æ› â”‚ â”‚
â”‚  â”‚     synchronize_rcu()                        â† ç­‰å¾…è®€å– â”‚ â”‚
â”‚  â”‚     kfree(old_ptr)                           â† é‡‹æ”¾èˆŠçš„ â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 RCU API

```c
/* RCU è®€å–ç«¯ */
#include <linux/rcupdate.h>

struct my_data {
    int value;
    char name[32];
};

struct my_data __rcu *global_data;

void read_data(void) {
    struct my_data *ptr;
    
    rcu_read_lock();  /* é€²å…¥ RCU è®€å–è‡¨ç•Œå€ */
    
    /* ä»¥ RCU å®‰å…¨çš„æ–¹å¼å–å¾—æŒ‡æ¨™ */
    ptr = rcu_dereference(global_data);
    if (ptr) {
        printk("value = %d\n", ptr->value);
    }
    
    rcu_read_unlock();  /* é›¢é–‹ RCU è®€å–è‡¨ç•Œå€ */
}

/* RCU æ›´æ–°ç«¯ */
void update_data(int new_value) {
    struct my_data *old_ptr, *new_ptr;
    
    /* 1. é…ç½®æ–°çµæ§‹ */
    new_ptr = kmalloc(sizeof(*new_ptr), GFP_KERNEL);
    if (!new_ptr)
        return;
    
    /* 2. è¤‡è£½ä¸¦ä¿®æ”¹ */
    spin_lock(&update_lock);  /* ä¿è­·æ›´æ–°æ“ä½œ */
    old_ptr = rcu_dereference_protected(global_data, 
                                        lockdep_is_held(&update_lock));
    if (old_ptr)
        memcpy(new_ptr, old_ptr, sizeof(*new_ptr));
    new_ptr->value = new_value;
    
    /* 3. åŸå­æ›¿æ›æŒ‡æ¨™ */
    rcu_assign_pointer(global_data, new_ptr);
    spin_unlock(&update_lock);
    
    /* 4. ç­‰å¾…æ‰€æœ‰é€²è¡Œä¸­çš„è®€å–å®Œæˆ */
    synchronize_rcu();
    
    /* 5. å®‰å…¨é‡‹æ”¾èˆŠè³‡æ–™ */
    kfree(old_ptr);
}
```

### 5.3 RCU Grace Period

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RCU Grace Periodï¼ˆå¯¬é™æœŸï¼‰                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Timeline:                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚
â”‚    â”‚                                                         â”‚
â”‚    â”‚  CPU 0: rcu_read_lock() â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ rcu_read_unlock() â”‚
â”‚    â”‚                                                         â”‚
â”‚    â”‚  CPU 1:       rcu_read_lock() â”€â”€â”€ rcu_read_unlock()    â”‚
â”‚    â”‚                                                         â”‚
â”‚    â”‚  Writer:      rcu_assign_pointer()                      â”‚
â”‚    â”‚               â”‚                                         â”‚
â”‚    â”‚               â”‚ synchronize_rcu()                       â”‚
â”‚    â”‚               â”‚         â”‚                               â”‚
â”‚    â”‚               â–¼         â–¼                               â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€ Grace Period â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
â”‚    â”‚                                   â”‚                     â”‚
â”‚    â”‚                                   â”‚ kfree(old) å®‰å…¨ï¼   â”‚
â”‚    â–¼                                   â–¼                     â”‚
â”‚                                                              â”‚
â”‚  Grace Period çµæŸæ¢ä»¶ï¼š                                      â”‚
â”‚  - æ‰€æœ‰ CPU éƒ½ç¶“æ­·é context switch                          â”‚
â”‚  - æˆ–æ‰€æœ‰ CPU éƒ½é›¢é–‹ rcu_read_lock è‡¨ç•Œå€                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.4 call_rcu (éåŒæ­¥é‡‹æ”¾)

```c
/* synchronize_rcu() æœƒé˜»å¡ï¼Œæœ‰æ™‚å€™ä¸æ–¹ä¾¿ */
/* call_rcu() æä¾›éåŒæ­¥æ–¹å¼ */

struct my_data {
    int value;
    struct rcu_head rcu;  /* å¿…é ˆåŒ…å«æ­¤æˆå“¡ */
};

/* Callbackï¼šåœ¨ Grace Period çµæŸå¾Œè¢«å‘¼å« */
static void my_data_free(struct rcu_head *head) {
    struct my_data *ptr = container_of(head, struct my_data, rcu);
    kfree(ptr);
}

void update_data_async(int new_value) {
    struct my_data *old_ptr, *new_ptr;
    
    new_ptr = kmalloc(sizeof(*new_ptr), GFP_KERNEL);
    /* ... è¤‡è£½ã€ä¿®æ”¹ ... */
    
    spin_lock(&update_lock);
    old_ptr = rcu_dereference_protected(global_data,
                                        lockdep_is_held(&update_lock));
    rcu_assign_pointer(global_data, new_ptr);
    spin_unlock(&update_lock);
    
    /* éåŒæ­¥é‡‹æ”¾ï¼šä¸é˜»å¡ï¼ */
    call_rcu(&old_ptr->rcu, my_data_free);
    /* ç«‹å³è¿”å›ï¼ŒCallback æœƒåœ¨ Grace Period å¾ŒåŸ·è¡Œ */
}
```

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šCompletionï¼ˆå®Œæˆç­‰å¾…ï¼‰

### 6.1 Completion æ¦‚å¿µ

```c
/*
 * Completionï¼šç­‰å¾…æŸå€‹äº‹ä»¶å®Œæˆ
 * 
 * å…¸å‹ç”¨é€”ï¼š
 * - ç­‰å¾… Interrupt å®Œæˆ
 * - ç­‰å¾… DMA å‚³è¼¸å®Œæˆ
 * - Thread é–“çš„åŒæ­¥
 */

#include <linux/completion.h>

/* å®šç¾©èˆ‡åˆå§‹åŒ– */
struct completion my_completion;
init_completion(&my_completion);

/* æˆ–éœæ…‹åˆå§‹åŒ– */
DECLARE_COMPLETION(my_completion);

/* ç­‰å¾…æ–¹ */
void waiter(void) {
    /* é˜»å¡ç›´åˆ° complete() è¢«å‘¼å« */
    wait_for_completion(&my_completion);
    printk("Done!\n");
}

/* é€šçŸ¥æ–¹ */
void notifier(void) {
    /* ... å®ŒæˆæŸäº›å·¥ä½œ ... */
    complete(&my_completion);  /* å–šé†’ä¸€å€‹ç­‰å¾…è€… */
    /* æˆ– complete_all(&my_completion) å–šé†’æ‰€æœ‰ç­‰å¾…è€… */
}
```

### 6.2 Completion API

```c
/* ç­‰å¾…å‡½å¼ */
void wait_for_completion(struct completion *c);  /* ä¸å¯ä¸­æ–· */
int wait_for_completion_interruptible(struct completion *c);
int wait_for_completion_killable(struct completion *c);
unsigned long wait_for_completion_timeout(struct completion *c, 
                                          unsigned long timeout);

/* é€šçŸ¥å‡½å¼ */
void complete(struct completion *c);      /* å–šé†’ä¸€å€‹ */
void complete_all(struct completion *c);  /* å–šé†’æ‰€æœ‰ */

/* é‡ç½®ï¼ˆç”¨æ–¼é‡è¤‡ä½¿ç”¨ï¼‰*/
void reinit_completion(struct completion *c);

/* æª¢æŸ¥ç‹€æ…‹ */
bool completion_done(struct completion *c);
```

### 6.3 Completion ä½¿ç”¨ç¯„ä¾‹

```c
/* ç¯„ä¾‹ï¼šç­‰å¾… DMA å®Œæˆ */

struct dma_context {
    struct completion done;
    void *buffer;
    int status;
};

/* ç™¼èµ· DMA å‚³è¼¸ */
int start_dma_transfer(struct dma_context *ctx, void *dst, void *src, size_t len) {
    int ret;
    
    reinit_completion(&ctx->done);
    
    /* è¨­å®š DMA ä¸¦å•Ÿå‹• */
    setup_dma(dst, src, len);
    start_dma();
    
    /* ç­‰å¾…å®Œæˆï¼ˆæœ‰ timeoutï¼‰*/
    ret = wait_for_completion_timeout(&ctx->done, msecs_to_jiffies(5000));
    if (ret == 0) {
        /* Timeout! */
        return -ETIMEDOUT;
    }
    
    return ctx->status;
}

/* DMA å®Œæˆ Interrupt Handler */
irqreturn_t dma_irq_handler(int irq, void *dev_id) {
    struct dma_context *ctx = dev_id;
    
    ctx->status = get_dma_status();
    complete(&ctx->done);  /* å–šé†’ç­‰å¾…è€… */
    
    return IRQ_HANDLED;
}
```

---

## ğŸ”· ç¬¬ä¸ƒéƒ¨åˆ†ï¼šDeadlock èˆ‡ Lockdep

### 7.1 Deadlock çš„å››å€‹å¿…è¦æ¢ä»¶

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Deadlock å››å€‹å¿…è¦æ¢ä»¶                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1. Mutual Exclusionï¼ˆäº’æ–¥ï¼‰                                  â”‚
â”‚     - è³‡æºä¸€æ¬¡åªèƒ½è¢«ä¸€å€‹ Process æŒæœ‰                         â”‚
â”‚                                                              â”‚
â”‚  2. Hold and Waitï¼ˆæŒæœ‰ä¸¦ç­‰å¾…ï¼‰                               â”‚
â”‚     - æŒæœ‰è³‡æºçš„åŒæ™‚ï¼Œç­‰å¾…å…¶ä»–è³‡æº                            â”‚
â”‚                                                              â”‚
â”‚  3. No Preemptionï¼ˆä¸å¯æ¶ä½”ï¼‰                                 â”‚
â”‚     - è³‡æºåªèƒ½ç”±æŒæœ‰è€…ä¸»å‹•é‡‹æ”¾                                â”‚
â”‚                                                              â”‚
â”‚  4. Circular Waitï¼ˆå¾ªç’°ç­‰å¾…ï¼‰                                 â”‚
â”‚     - A ç­‰å¾… Bï¼ŒB ç­‰å¾… Cï¼ŒC ç­‰å¾… A                            â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç¶“å…¸ Deadlock ç¯„ä¾‹ï¼š                                    â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  Thread A                    Thread B                   â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚ â”‚
â”‚  â”‚  lock(A)                     lock(B)                    â”‚ â”‚
â”‚  â”‚  lock(B) â† ç­‰å¾…             lock(A) â† ç­‰å¾…              â”‚ â”‚
â”‚  â”‚                                                         â”‚ â”‚
â”‚  â”‚  äº’ç›¸ç­‰å¾…ï¼Œæ°¸é ç„¡æ³•å‰é€²ï¼                                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 Deadlock é é˜²æ–¹æ³•

```c
/* æ–¹æ³• 1ï¼šå›ºå®šåŠ é–é †åº */
/* æ‰€æœ‰åœ°æ–¹éƒ½ä»¥ç›¸åŒé †åºå–å¾—é– */

spinlock_t lock_a, lock_b;

void safe_func_1(void) {
    spin_lock(&lock_a);
    spin_lock(&lock_b);
    /* ... */
    spin_unlock(&lock_b);
    spin_unlock(&lock_a);
}

void safe_func_2(void) {
    spin_lock(&lock_a);  /* åŒæ¨£å…ˆå–å¾— A */
    spin_lock(&lock_b);  /* å†å–å¾— B */
    /* ... */
    spin_unlock(&lock_b);
    spin_unlock(&lock_a);
}

/* æ–¹æ³• 2ï¼šä½¿ç”¨ trylock + é€€å›é‡è©¦ */
void safe_with_trylock(void) {
retry:
    spin_lock(&lock_a);
    if (!spin_trylock(&lock_b)) {
        spin_unlock(&lock_a);
        cpu_relax();
        goto retry;
    }
    /* Got both locks */
    spin_unlock(&lock_b);
    spin_unlock(&lock_a);
}

/* æ–¹æ³• 3ï¼šä½¿ç”¨ lock ordering è¨»è§£ */
/* åœ¨ struct å®šç¾©ä¸­è¨˜éŒ„é–çš„å±¤ç´š */
struct my_device {
    spinlock_t config_lock;  /* Level 1 */
    spinlock_t data_lock;    /* Level 2ï¼Œå–å¾—æ™‚å¿…é ˆå…ˆæœ‰ Level 1 */
};
```

### 7.3 Lockdep å·¥å…·

```c
/*
 * Lockdepï¼šLinux Kernel çš„é–æ­£ç¢ºæ€§æª¢æŸ¥å·¥å…·
 * 
 * åŠŸèƒ½ï¼š
 * - æª¢æ¸¬å¯èƒ½çš„ Deadlock
 * - æª¢æ¸¬ä¸æ­£ç¢ºçš„é–ä½¿ç”¨
 * - é‹è¡Œæ™‚åˆ†æï¼Œç„¡éœ€å¯¦éš›ç™¼ç”Ÿ Deadlock
 * 
 * é–‹å•Ÿæ–¹å¼ï¼š
 *   CONFIG_PROVE_LOCKING=y
 *   CONFIG_DEBUG_LOCK_ALLOC=y
 */

/* Lockdep å¯ä»¥æª¢æ¸¬åˆ°çš„å•é¡Œ */

/* 1. AB-BA Deadlock */
/* Thread 1: lock(A), lock(B) */
/* Thread 2: lock(B), lock(A) */
/* Lockdep æœƒåœ¨ç¬¬ä¸€æ¬¡åŸ·è¡Œæ™‚åµæ¸¬åˆ°é€™å€‹æ¨¡å¼ä¸¦è­¦å‘Š */

/* 2. åœ¨ IRQ context ä½¿ç”¨ä¸å®‰å…¨çš„ lock */
spin_lock(&my_lock);  /* Process context */
/* ... IRQ ç™¼ç”Ÿ ... */
spin_lock(&my_lock);  /* IRQ handler: Lockdep è­¦å‘Šï¼ */

/* 3. éè¿´å–å¾—ééè¿´é– */
mutex_lock(&my_mutex);
mutex_lock(&my_mutex);  /* Lockdep è­¦å‘Šï¼ */
```

```
/* Lockdep è­¦å‘Šè¨Šæ¯ç¯„ä¾‹ */

============================================
WARNING: possible recursive locking detected
--------------------------------------------
kworker/0:1/123 is trying to acquire lock:
 (&my_mutex){+.+.}, at: my_function+0x10/0x50

but task is already holding lock:
 (&my_mutex){+.+.}, at: parent_function+0x20/0x80

other info that might help us debug this:
 Possible unsafe locking scenario:

       CPU0
       ----
  lock(&my_mutex);
  lock(&my_mutex);

 *** DEADLOCK ***
```

### 7.4 Lock Class èˆ‡ Nested Lock

```c
/* æœ‰æ™‚å€™åŒé¡å‹çš„é–éœ€è¦åµŒå¥—å–å¾— */
/* ä¾‹å¦‚ï¼šç›®éŒ„é– + æª”æ¡ˆé– */

/* Lockdep éœ€è¦çŸ¥é“é€™æ˜¯æœ‰æ„çš„åµŒå¥— */
mutex_lock(&dir->i_mutex);
mutex_lock_nested(&file->i_mutex, I_MUTEX_CHILD);
/* ... */
mutex_unlock(&file->i_mutex);
mutex_unlock(&dir->i_mutex);

/* Lock class å®šç¾© */
enum inode_i_mutex_lock_class {
    I_MUTEX_PARENT,
    I_MUTEX_CHILD,
    I_MUTEX_XATTR,
    I_MUTEX_QUOTA,
};

/* spin_lock ä¹Ÿæœ‰ nested ç‰ˆæœ¬ */
spin_lock_nested(&lock, SINGLE_DEPTH_NESTING);
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Spinlock å’Œ Mutex æœ‰ä»€éº¼å€åˆ¥ï¼Ÿä»€éº¼æ™‚å€™ç”¨å“ªå€‹ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
è§£é‡‹ Spinlock å’Œ Mutex çš„å€åˆ¥ï¼Œä¸¦èªªæ˜ä½¿ç”¨å ´æ™¯ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | Spinlock | Mutex |
|:---|:---|:---|
| ç­‰å¾…æ–¹å¼ | è‡ªæ—‹ï¼ˆå¿™ç­‰å¾…ï¼‰| ç¡çœ  |
| Interrupt Context | âœ… å¯ä»¥ | âŒ ä¸å¯ä»¥ |
| æŒæœ‰æ™‚é–“ | çŸ­ï¼ˆå¾®ç§’ç´šï¼‰| å¯ä»¥å¾ˆé•· |
| å¯ç¡çœ æ“ä½œ | âŒ | âœ… |

**ä½¿ç”¨å ´æ™¯**ï¼š
- **Spinlock**ï¼š
  - è‡¨ç•Œå€å¾ˆçŸ­
  - åœ¨ Interrupt Context
  - ä¸æœƒåšä»»ä½•å¯èƒ½ç¡çœ çš„æ“ä½œ

- **Mutex**ï¼š
  - è‡¨ç•Œå€è¼ƒé•·
  - éœ€è¦åš I/Oã€è¨˜æ†¶é«”é…ç½®
  - éœ€è¦å‘¼å«å¯èƒ½ç¡çœ çš„å‡½å¼

**è¿½å•**ï¼šåœ¨ Interrupt Context ç”¨ Mutex æœƒæ€æ¨£ï¼Ÿ
- Mutex éœ€è¦ç¡çœ ç­‰å¾…ï¼Œä½† Interrupt Context ä¸èƒ½ç¡çœ 
- æœƒé€ æˆ kernel panic æˆ– deadlock

---

### Q2: ä»€éº¼æ˜¯ spin_lock_irqsaveï¼Ÿç‚ºä»€éº¼éœ€è¦å®ƒï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Intel

**å•é¡Œ**ï¼š
è§£é‡‹ `spin_lock_irqsave` çš„ä½œç”¨å’Œä½¿ç”¨å ´æ™¯ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**ä½œç”¨**ï¼š
1. å–å¾— spinlock
2. ä¿å­˜ç•¶å‰ IRQ ç‹€æ…‹
3. é—œé–‰æœ¬åœ° CPU çš„ä¸­æ–·

**ç‚ºä»€éº¼éœ€è¦**ï¼š
```
æƒ…å¢ƒï¼šProcess Context æŒæœ‰é–æ™‚è¢«ä¸­æ–·
1. Process Context: spin_lock(&lock)
2. IRQ ç™¼ç”Ÿï¼
3. IRQ Handler: spin_lock(&lock) â† Deadlockï¼
```

**æ­£ç¢ºç”¨æ³•**ï¼š
```c
unsigned long flags;
spin_lock_irqsave(&lock, flags);
/* è‡¨ç•Œå€ */
spin_unlock_irqrestore(&lock, flags);
```

**ç‚ºä»€éº¼è¦ä¿å­˜ flags**ï¼š
- åœ¨åµŒå¥—å‘¼å«æ™‚æ­£ç¢ºæ¢å¾© IRQ ç‹€æ…‹
- å¦‚æœå·²ç¶“åœ¨ IRQ disabled ç‹€æ…‹è¢«å‘¼å«ï¼Œæ¢å¾©æ™‚ä¸æœƒèª¤é–‹ IRQ

---

### Q3: ä»€éº¼æ˜¯ RCUï¼Ÿå®ƒè§£æ±ºä»€éº¼å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / Meta

**å•é¡Œ**ï¼š
è§£é‡‹ RCU çš„åŸç†ï¼Œèªªæ˜å®ƒé©åˆä»€éº¼å ´æ™¯ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**RCU (Read-Copy-Update)** æ˜¯ä¸€ç¨®é‡å°è®€å¤šå¯«å°‘å ´æ™¯çš„åŒæ­¥æ©Ÿåˆ¶ã€‚

**åŸç†**ï¼š
1. **è®€å–ç„¡é–**ï¼š`rcu_read_lock()` åªæ˜¯ç¦æ­¢æ¶ä½”
2. **å¯«å…¥æ™‚è¤‡è£½**ï¼šå…ˆè¤‡è£½ã€ä¿®æ”¹ã€å†åŸå­æ›¿æ›æŒ‡æ¨™
3. **å»¶é²é‡‹æ”¾**ï¼šç­‰å¾…æ‰€æœ‰é€²è¡Œä¸­çš„è®€å–å®Œæˆå¾Œæ‰é‡‹æ”¾èˆŠè³‡æ–™

**ä½¿ç”¨å ´æ™¯**ï¼š
- è®€å–é »ç‡ >> å¯«å…¥é »ç‡
- è·¯ç”±è¡¨ã€é…ç½®è³‡æ–™ã€æ¨¡çµ„åˆ—è¡¨

**ç¨‹å¼ç¢¼ç¯„ä¾‹**ï¼š
```c
/* è®€å– */
rcu_read_lock();
ptr = rcu_dereference(global_ptr);
/* ä½¿ç”¨ ptr */
rcu_read_unlock();

/* æ›´æ–° */
new = kmalloc(...);
*new = *old;
new->field = new_value;
rcu_assign_pointer(global_ptr, new);
synchronize_rcu();
kfree(old);
```

---

### Q4: Deadlock çš„å››å€‹å¿…è¦æ¢ä»¶æ˜¯ä»€éº¼ï¼Ÿå¦‚ä½•é é˜²ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
èªªæ˜ Deadlock ç™¼ç”Ÿçš„æ¢ä»¶å’Œé é˜²æ–¹æ³•ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**å››å€‹å¿…è¦æ¢ä»¶**ï¼š
1. **Mutual Exclusion**ï¼šè³‡æºäº’æ–¥
2. **Hold and Wait**ï¼šæŒæœ‰ä¸¦ç­‰å¾…
3. **No Preemption**ï¼šä¸å¯æ¶ä½”
4. **Circular Wait**ï¼šå¾ªç’°ç­‰å¾…

**é é˜²æ–¹æ³•**ï¼š

1. **å›ºå®šåŠ é–é †åº**ï¼š
```c
/* æ°¸é å…ˆå–å¾— A å†å–å¾— B */
spin_lock(&lock_a);
spin_lock(&lock_b);
```

2. **ä½¿ç”¨ trylock**ï¼š
```c
spin_lock(&lock_a);
if (!spin_trylock(&lock_b)) {
    spin_unlock(&lock_a);
    goto retry;
}
```

3. **ä½¿ç”¨ Lockdep**ï¼ˆé–‹ç™¼éšæ®µï¼‰ï¼š
```
CONFIG_PROVE_LOCKING=y
```

---

### Q5: Priority Inversion æ˜¯ä»€éº¼ï¼Ÿå¦‚ä½•è§£æ±ºï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šReal-time ç³»çµ±

**å•é¡Œ**ï¼š
è§£é‡‹ Priority Inversion å•é¡ŒåŠå…¶è§£æ±ºæ–¹æ¡ˆã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**Priority Inversionï¼ˆå„ªå…ˆæ¬Šåè½‰ï¼‰**ï¼š
é«˜å„ªå…ˆæ¬Šä»»å‹™è¢«ä½å„ªå…ˆæ¬Šä»»å‹™é˜»æ“‹

**æƒ…å¢ƒ**ï¼š
1. Low priority (L) æŒæœ‰ Lock
2. High priority (H) ç­‰å¾… Lock
3. Medium priority (M) æ¶ä½” L
4. çµæœï¼šH ç­‰å¾… Mï¼

**è§£æ±ºæ–¹æ¡ˆï¼šPriority Inheritance**
- L æš«æ™‚ç¹¼æ‰¿ H çš„å„ªå…ˆæ¬Š
- M ç„¡æ³•æ¶ä½” L
- Linux æä¾› `rt_mutex` å¯¦ä½œæ­¤æ©Ÿåˆ¶

```c
struct rt_mutex my_rtmutex;
rt_mutex_init(&my_rtmutex);
rt_mutex_lock(&my_rtmutex);
/* è‡¨ç•Œå€ */
rt_mutex_unlock(&my_rtmutex);
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **Linux Kernel Development** - Robert Love (Chapter 8-9)
2. **Linux Device Drivers, 3rd Edition** - Corbet (Chapter 5)
3. **Understanding the Linux Kernel** - Bovet & Cesati (Chapter 5)
4. **Kernel Source**: kernel/locking/, include/linux/spinlock.h
5. **LWN.net Articles**:
   - [RCU concepts](https://lwn.net/Articles/262464/)
   - [Lockdep](https://lwn.net/Articles/185666/)
