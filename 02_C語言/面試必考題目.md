# ğŸ“‹ C èªè¨€é¢è©¦å¿…è€ƒé¡Œç›®

> é€™ä»½æ–‡ä»¶åŒ…å« IC éŸŒé«”é¢è©¦æœ€å¸¸è¦‹çš„ C èªè¨€é¡Œç›®  
> å»ºè­°ï¼šæ¯å¤©ç·´ç¿’ 3-5 é¡Œï¼ŒæŒçºŒ 4 é€±

---

## ğŸ”´ ç¬¬ä¸€é¡ï¼šæŒ‡æ¨™ï¼ˆPointerï¼‰â€” å¿…è€ƒï¼

### åŸºç¤æ¦‚å¿µ

**Q1ï¼šä»€éº¼æ˜¯æŒ‡æ¨™ï¼Ÿ**
```c
æŒ‡æ¨™æ˜¯ä¸€å€‹è®Šæ•¸ï¼Œå„²å­˜å¦ä¸€å€‹è®Šæ•¸çš„ã€Œè¨˜æ†¶é«”ä½å€ã€ã€‚

int a = 10;      // a æ˜¯ä¸€å€‹æ•´æ•¸è®Šæ•¸ï¼Œå€¼ç‚º 10
int *p = &a;     // p æ˜¯æŒ‡æ¨™ï¼Œå„²å­˜ a çš„ä½å€

// & å–å€é‹ç®—å­ï¼šå–å¾—è®Šæ•¸çš„ä½å€
// * å–å€¼é‹ç®—å­ï¼šå–å¾—ä½å€æŒ‡å‘çš„å€¼
```

**Q2ï¼šä»¥ä¸‹ç¨‹å¼ç¢¼çš„è¼¸å‡ºæ˜¯ä»€éº¼ï¼Ÿ**
```c
int a = 5;
int *p = &a;
int **pp = &p;

printf("%d\n", *p);      // è¼¸å‡ºï¼Ÿ
printf("%d\n", **pp);    // è¼¸å‡ºï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
5
5

è§£é‡‹ï¼š
- *p å–å¾— p æŒ‡å‘çš„å€¼ï¼Œå³ a çš„å€¼ = 5
- **pp å…ˆå–å¾— pp æŒ‡å‘çš„å€¼ï¼ˆå³ pï¼‰ï¼Œå†å–å¾— p æŒ‡å‘çš„å€¼ï¼ˆå³ aï¼‰= 5
```
</details>

---

**Q3ï¼šæŒ‡æ¨™ç®—è¡“**
```c
int arr[] = {10, 20, 30, 40, 50};
int *p = arr;

printf("%d\n", *p);        // è¼¸å‡ºï¼Ÿ
printf("%d\n", *(p+2));    // è¼¸å‡ºï¼Ÿ
printf("%d\n", p[3]);      // è¼¸å‡ºï¼Ÿ
p++;
printf("%d\n", *p);        // è¼¸å‡ºï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
10
30
40
20

è§£é‡‹ï¼š
- *p å–å¾— arr[0] = 10
- *(p+2) å–å¾— arr[2] = 30ï¼ˆæŒ‡æ¨™åŠ  2 è¡¨ç¤ºå‘å¾Œç§»å‹• 2 å€‹ int çš„å¤§å°ï¼‰
- p[3] ç­‰åƒ¹æ–¼ *(p+3) = arr[3] = 40
- p++ å¾Œï¼Œp æŒ‡å‘ arr[1]ï¼Œæ‰€ä»¥ *p = 20
```
</details>

---

**Q4ï¼šsizeof èˆ‡æŒ‡æ¨™**
```c
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;

printf("sizeof(arr) = %zu\n", sizeof(arr));  // è¼¸å‡ºï¼Ÿ
printf("sizeof(p) = %zu\n", sizeof(p));      // è¼¸å‡ºï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
sizeof(arr) = 20  ï¼ˆ5 å€‹ int * 4 bytes = 20ï¼‰
sizeof(p) = 8     ï¼ˆ64ä½å…ƒç³»çµ±çš„æŒ‡æ¨™å¤§å°ï¼‰

æ³¨æ„ï¼š
- sizeof(arr) å›å‚³æ•´å€‹é™£åˆ—çš„å¤§å°
- sizeof(p) å›å‚³æŒ‡æ¨™è®Šæ•¸æœ¬èº«çš„å¤§å°ï¼ˆå’Œç³»çµ±ä½å…ƒæ•¸æœ‰é—œï¼‰
```
</details>

---

**Q5ï¼šæŒ‡æ¨™èˆ‡é™£åˆ—çš„å·®ç•°**
```c
char str1[] = "Hello";
char *str2 = "Hello";

str1[0] = 'h';   // é€™è¡Œæœƒæ€æ¨£ï¼Ÿ
str2[0] = 'h';   // é€™è¡Œæœƒæ€æ¨£ï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
str1[0] = 'h';  â†’ åˆæ³•ï¼Œå¯ä»¥ä¿®æ”¹
str2[0] = 'h';  â†’ æœªå®šç¾©è¡Œç‚ºï¼ˆå¯èƒ½ Segmentation Faultï¼‰

æ·±å…¥è§£é‡‹ï¼ˆè¨˜æ†¶é«”ä½ˆå±€ï¼‰ï¼š

1. char str1[] = "Hello"; (é™£åˆ—åˆå§‹åŒ–)
   - è¨˜æ†¶é«”ä½ç½®ï¼šStack (æ£§å€)
   - è¡Œç‚ºï¼šç·¨è­¯å™¨æœƒåœ¨ Stack ä¸Šåˆ†é… 6 bytes çš„ç©ºé–“ï¼Œä¸¦åœ¨ç¨‹å¼åŸ·è¡Œåˆ°è©²è¡Œæ™‚ï¼Œå°‡å­—ä¸²å¸¸é‡ "Hello" å¾å”¯è®€å€æ‹·è² (Copy) åˆ° Stack ä¸­ã€‚
   - æ¬Šé™ï¼šStack ç©ºé–“æ˜¯å¯è®€å¯å¯«çš„ï¼Œå› æ­¤ä¿®æ”¹ str1[0] æ˜¯åˆæ³•æ“ä½œã€‚

2. char *str2 = "Hello"; (æŒ‡æ¨™æŒ‡å‘å­—ä¸²å¸¸é‡)
   - è¨˜æ†¶é«”ä½ç½®ï¼š
     - æŒ‡æ¨™è®Šæ•¸ str2 æœ¬èº«ï¼šStack (æ£§å€)
     - å­—ä¸²å¸¸é‡ "Hello"ï¼šText Segment / .rodata (ç¨‹å¼ç¢¼å€æˆ–å”¯è®€è³‡æ–™å€)
   - è¡Œç‚ºï¼šstr2 åƒ…æ˜¯ä¸€å€‹æŒ‡æ¨™ï¼Œå„²å­˜äº†ä½æ–¼å”¯è®€å€ä¹‹ "Hello" çš„èµ·å§‹ä½å€ã€‚
   - æ¬Šé™ï¼š.rodata å€åŸŸåœ¨ç¡¬é«”åˆ†é ä¿è­·ä¸‹æ˜¯å”¯è®€çš„ (Read-Only)ã€‚ä»»ä½•è©¦åœ–ä¿®æ”¹è©²å€åŸŸçš„æ“ä½œéƒ½æœƒè§¸ç™¼ä½œæ¥­ç³»çµ±çš„è¨˜æ†¶é«”ä¿è­·æ©Ÿåˆ¶ï¼Œå°è‡´ Segmentation Faultã€‚

åœ–è§£è¨˜æ†¶é«”ï¼š
[ Stack ]          [ .rodata (Read-only) ]
+-------+          +-------+
| 'H'.. | <---str1 | "Hello" | <--- str2 æŒ‡å‘é€™è£¡ (ä¸å¯å¯«)
+-------+          +-------+
| str2  | ---------^
+-------+

```
</details>

---

## ğŸ”´ ç¬¬äºŒé¡ï¼šè¨˜æ†¶é«”ç®¡ç† â€” å¿…è€ƒï¼

**Q6ï¼šStack vs Heap**
```
Stackï¼ˆå †ç–Šï¼‰ï¼š
- è‡ªå‹•ç®¡ç†ï¼ˆå‡½å¼çµæŸè‡ªå‹•é‡‹æ”¾ï¼‰
- é€Ÿåº¦å¿«
- å¤§å°æœ‰é™ï¼ˆé€šå¸¸ 1-8 MBï¼‰
- å€åŸŸè®Šæ•¸ã€å‡½å¼åƒæ•¸

Heapï¼ˆå †ç©ï¼‰ï¼š
- æ‰‹å‹•ç®¡ç†ï¼ˆmalloc/freeï¼‰
- é€Ÿåº¦è¼ƒæ…¢
- å¤§å°è¼ƒå¤§ï¼ˆå—é™æ–¼ç³»çµ±è¨˜æ†¶é«”ï¼‰
- å‹•æ…‹åˆ†é…çš„è³‡æ–™
```

**Q7ï¼šä»¥ä¸‹ç¨‹å¼ç¢¼æœ‰ä»€éº¼å•é¡Œï¼Ÿ**
```c
char* getString() {
    char str[] = "Hello";
    return str;
}

int main() {
    char *s = getString();
    printf("%s\n", s);
    return 0;
}
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
å•é¡Œï¼šå›å‚³æŒ‡å‘å€åŸŸè®Šæ•¸çš„æŒ‡æ¨™ï¼ˆDangling Pointerï¼‰

str æ˜¯å€åŸŸè®Šæ•¸ï¼Œå­˜åœ¨ stack ä¸Šã€‚
å‡½å¼çµæŸå¾Œï¼Œstr çš„è¨˜æ†¶é«”è¢«é‡‹æ”¾ã€‚
å›å‚³çš„æŒ‡æ¨™æŒ‡å‘å·²é‡‹æ”¾çš„è¨˜æ†¶é«” â†’ æœªå®šç¾©è¡Œç‚ºã€‚

ä¿®æ­£æ–¹å¼ï¼š
1. ä½¿ç”¨ staticï¼šstatic char str[] = "Hello";
2. ä½¿ç”¨ mallocï¼šchar *str = malloc(6); strcpy(str, "Hello");
3. å›å‚³å­—ä¸²å¸¸é‡ï¼šreturn "Hello"; ï¼ˆå› ç‚ºå­—ä¸²å¸¸é‡å­˜åœ¨ data sectionï¼‰
```
</details>

---

**Q8ï¼šMemory Leak ç¯„ä¾‹**
```c
void func() {
    int *p = (int*)malloc(10 * sizeof(int));
    // ä½¿ç”¨ p...
    // å‡½å¼çµæŸï¼Œä½†æ²’æœ‰ free(p)
}
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
å•é¡Œï¼šMemory Leakï¼ˆè¨˜æ†¶é«”æ´©æ¼ï¼‰

malloc åˆ†é…çš„è¨˜æ†¶é«”åœ¨ heap ä¸Šï¼Œä¸æœƒè‡ªå‹•é‡‹æ”¾ã€‚
å¦‚æœæ²’æœ‰ free()ï¼Œé€™å¡Šè¨˜æ†¶é«”æœƒä¸€ç›´è¢«ä½”ç”¨ã€‚
é•·æ™‚é–“é‹è¡Œçš„ç¨‹å¼ï¼ˆå¦‚ BMC éŸŒé«”ï¼‰æœƒå°è‡´è¨˜æ†¶é«”è€—ç›¡ã€‚

ä¿®æ­£ï¼šåœ¨ä¸éœ€è¦æ™‚ free(p);
```
</details>

---

## ğŸ”´ ç¬¬ä¸‰é¡ï¼šä½å…ƒé‹ç®— â€” å¿…è€ƒï¼

**Q9ï¼šåŸºæœ¬ä½å…ƒé‹ç®—**
```c
// å¸¸ç”¨é‹ç®—å­
& (AND)    |  (OR)     ^ (XOR)
~ (NOT)    << (å·¦ç§»)   >> (å³ç§»)

// ç¯„ä¾‹
unsigned char a = 0b11001010;  // 202
unsigned char b = 0b01100110;  // 102

a & b = ?
a | b = ?
a ^ b = ?
~a = ?
a << 2 = ?
a >> 3 = ?
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
a & b = 0b01000010 = 66   (å…©è€…éƒ½æ˜¯ 1 æ‰æ˜¯ 1)
a | b = 0b11101110 = 238  (ä»»ä¸€ç‚º 1 å°±æ˜¯ 1)
a ^ b = 0b10101100 = 172  (ä¸åŒç‚º 1ï¼Œç›¸åŒç‚º 0)
~a    = 0b00110101 = 53   (0 å’Œ 1 äº’æ›ï¼Œå‡è¨­ 8-bit)
a << 2 = 0b00101000 = 40  (å·¦ç§» 2 ä½ï¼Œç­‰æ–¼ *4ï¼Œä½†è¶…å‡ºçš„ä½å…ƒéºå¤±)
a >> 3 = 0b00011001 = 25  (å³ç§» 3 ä½ï¼Œç­‰æ–¼ /8)
```
</details>

---

**Q10ï¼šSETã€CLEARã€TOGGLE ç‰¹å®š bit**
```c
// é€™æ˜¯åµŒå…¥å¼é–‹ç™¼æœ€å¸¸ç”¨çš„æ“ä½œï¼

// å‡è¨­ reg æ˜¯ 8-bit æš«å­˜å™¨
unsigned char reg = 0b00000000;

// è¨­å®šç¬¬ 3 bit ç‚º 1 (SET)
reg = ?

// æ¸…é™¤ç¬¬ 5 bit ç‚º 0 (CLEAR)
reg = 0b11111111;
reg = ?

// åˆ‡æ›ç¬¬ 2 bit (TOGGLE)
reg = 0b00000100;
reg = ?
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```c
// SET bit nï¼šä½¿ç”¨ OR
reg = reg | (1 << 3);
// æˆ–ç°¡å¯«ï¼šreg |= (1 << 3);
// çµæœï¼š0b00001000

// CLEAR bit nï¼šä½¿ç”¨ AND + NOT
reg = reg & ~(1 << 5);
// æˆ–ç°¡å¯«ï¼šreg &= ~(1 << 5);
// çµæœï¼š0b11011111

// TOGGLE bit nï¼šä½¿ç”¨ XOR
reg = reg ^ (1 << 2);
// æˆ–ç°¡å¯«ï¼šreg ^= (1 << 2);
// çµæœï¼š0b00000000ï¼ˆå› ç‚ºåŸæœ¬æ˜¯ 1ï¼ŒXOR å¾Œè®Š 0ï¼‰

// å¸¸è¦‹å·¨é›†å®šç¾©
#define SET_BIT(reg, n)    ((reg) |= (1 << (n)))
#define CLEAR_BIT(reg, n)  ((reg) &= ~(1 << (n)))
#define TOGGLE_BIT(reg, n) ((reg) ^= (1 << (n)))
#define CHECK_BIT(reg, n)  ((reg) & (1 << (n)))
```
</details>

---

**Q11ï¼šåˆ¤æ–·æ•¸å­—æ˜¯å¦ç‚º 2 çš„å†ªæ¬¡**
```c
int isPowerOfTwo(unsigned int n) {
    // ä½ çš„ç­”æ¡ˆï¼Ÿ
}
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```c
int isPowerOfTwo(unsigned int n) {
    return n != 0 && (n & (n - 1)) == 0;
}

è§£é‡‹ï¼š
- 2 çš„å†ªæ¬¡åœ¨äºŒé€²ä½ä¸­åªæœ‰ä¸€å€‹ bit æ˜¯ 1
- ä¾‹å¦‚ï¼š8 = 0b1000ï¼Œ8-1 = 7 = 0b0111
- 8 & 7 = 0b1000 & 0b0111 = 0
- å¦‚æœ n & (n-1) == 0ï¼Œä»£è¡¨åªæœ‰ä¸€å€‹ bit æ˜¯ 1
```
</details>

---

**Q12ï¼šè¨ˆç®—äºŒé€²ä½ä¸­ 1 çš„å€‹æ•¸**
```c
int countSetBits(unsigned int n) {
    // ä½ çš„ç­”æ¡ˆï¼Ÿ
}
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```c
// æ–¹æ³•ä¸€ï¼šé€ä½æª¢æŸ¥
int countSetBits(unsigned int n) {
    int count = 0;
    while (n) {
        count += (n & 1);
        n >>= 1;
    }
    return count;
}

// æ–¹æ³•äºŒï¼šBrian Kernighan's Algorithmï¼ˆæ›´å¿«ï¼‰
int countSetBits(unsigned int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // æ¶ˆé™¤æœ€ä½ä½çš„ 1
        count++;
    }
    return count;
}
```
</details>

---

## ğŸ”´ ç¬¬å››é¡ï¼šé—œéµå­— â€” å¿…è€ƒï¼

**Q13ï¼švolatile çš„ç”¨é€”**
```
volatile å‘Šè¨´ç·¨è­¯å™¨ï¼šé€™å€‹è®Šæ•¸çš„å€¼å¯èƒ½è¢«å¤–éƒ¨å› ç´ æ”¹è®Šï¼Œ
ä¸è¦é€²è¡Œå„ªåŒ–ï¼Œæ¯æ¬¡éƒ½è¦å¾è¨˜æ†¶é«”è®€å–ã€‚

ä½¿ç”¨å ´æ™¯ï¼š
1. ç¡¬é«”æš«å­˜å™¨
2. ä¸­æ–·æœå‹™ç¨‹å¼ï¼ˆISRï¼‰ä¸­ä¿®æ”¹çš„è®Šæ•¸
3. å¤šåŸ·è¡Œç·’å…±äº«çš„è®Šæ•¸

ç¯„ä¾‹ï¼š
volatile int *hardware_reg = (volatile int *)0x40000000;
```

1. **ç¡¬é«”æš«å­˜å™¨**
```c
// å‡è¨­ 0x4000 æ˜¯æŸç¡¬é«”ç‹€æ…‹æš«å­˜å™¨ï¼Œç¡¬é«”æœƒè‡ªå‹•æ›´æ–°å…¶æ•¸å€¼
volatile uint32_t *status_reg = (uint32_t *)0x4000;

// è¿´åœˆç­‰å¾…ç¡¬é«”å®Œæˆä»»å‹™ï¼ˆç‹€æ…‹è®Šç‚º 1ï¼‰
while (*status_reg == 0); 

/* å„ªåŒ–å·®ç•°ï¼š
- ç„¡ volatileï¼šç·¨è­¯å™¨å¯èƒ½èªç‚ºè¿´åœˆå…§æ²’äººæ”¹ *status_regï¼Œ
    å› æ­¤åªå¾è¨˜æ†¶é«”è®€ä¸€æ¬¡åˆ°æš«å­˜å™¨ï¼Œå°è‡´ç„¡çª®è¿´åœˆã€‚
- æœ‰ volatileï¼šç·¨è­¯å™¨æ¯æ¬¡éƒ½æœƒé‡æ–°å¾è¨˜æ†¶é«” 0x4000 è®€å–æœ€æ–°ç‹€æ…‹ã€‚ */
```

2. **ä¸­æ–·æœå‹™ç¨‹å¼ (ISR) ä¿®æ”¹çš„å…¨åŸŸè®Šæ•¸**
```c
volatile int flag = 0;

void timer_isr() {
    flag = 1; // ç”±ç¡¬é«”è§¸ç™¼çš„ä¸­æ–·ä¿®æ”¹ flag
}

void main() {
    while (flag == 0); // ç­‰å¾…ä¸­æ–·ç™¼ç”Ÿå¾Œè·³å‡ºè¿´åœˆ
}
```

**Q14ï¼šstatic çš„ä¸‰ç¨®ç”¨æ³•**
```c
// 1. éœæ…‹å€åŸŸè®Šæ•¸ï¼šå€¼åœ¨å‡½å¼å‘¼å«é–“ä¿ç•™
void counter() {
    static int count = 0;
    count++;
    printf("%d\n", count);
}
// å¤šæ¬¡å‘¼å«æœƒè¼¸å‡º 1, 2, 3, 4...

// 2. éœæ…‹å…¨åŸŸè®Šæ•¸ï¼šé™åˆ¶ä½œç”¨åŸŸåœ¨è©²æª”æ¡ˆå…§
static int file_scope_var = 10;
// å…¶ä»– .c æª”æ¡ˆç„¡æ³•å­˜å–é€™å€‹è®Šæ•¸

// 3. éœæ…‹å‡½å¼ï¼šé™åˆ¶ä½œç”¨åŸŸåœ¨è©²æª”æ¡ˆå…§
static void helper_function() { }
// å…¶ä»– .c æª”æ¡ˆç„¡æ³•å‘¼å«é€™å€‹å‡½å¼
```

**Q15ï¼šconst çš„ç”¨æ³•**
```c
const int a = 10;           // a ä¸å¯ä¿®æ”¹
int const b = 20;           // åŒä¸Šï¼Œb ä¸å¯ä¿®æ”¹

const int *p1;              // p1 æŒ‡å‘çš„å€¼ä¸å¯ä¿®æ”¹ï¼Œä½† p1 å¯ä»¥æŒ‡å‘åˆ¥çš„åœ°æ–¹
int * const p2;             // p2 ä¸å¯æŒ‡å‘åˆ¥çš„åœ°æ–¹ï¼Œä½† p2 æŒ‡å‘çš„å€¼å¯ä»¥ä¿®æ”¹
const int * const p3;       // éƒ½ä¸å¯ä¿®æ”¹

// è¨˜æ†¶æ–¹æ³•ï¼šconst åœ¨ * å·¦é‚Š â†’ å€¼ä¸å¯æ”¹
//           const åœ¨ * å³é‚Š â†’ æŒ‡æ¨™ä¸å¯æ”¹
```

---

## ğŸ”´ ç¬¬äº”é¡ï¼šçµæ§‹é«”èˆ‡è¯é›† â€” å¸¸è€ƒ

**Q16ï¼šstruct padding**
```c
struct Example1 {
    char a;      // 1 byte
    int b;       // 4 bytes
    char c;      // 1 byte
};

struct Example2 {
    char a;      // 1 byte
    char c;      // 1 byte
    int b;       // 4 bytes
};

printf("sizeof(Example1) = %zu\n", sizeof(struct Example1));  // è¼¸å‡ºï¼Ÿ
printf("sizeof(Example2) = %zu\n", sizeof(struct Example2));  // è¼¸å‡ºï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
sizeof(Example1) = 12
sizeof(Example2) = 8

è§£é‡‹ï¼ˆå‡è¨­ 4-byte alignmentï¼‰ï¼š

Example1:
| a |pad|pad|pad| b  b  b  b | c |pad|pad|pad|
  1    3        4             1    3          = 12 bytes

Example2:
| a | c |pad|pad| b  b  b  b |
  1   1   2       4            = 8 bytes

çµè«–ï¼šé‡æ–°æ’åˆ—æˆå“¡é †åºå¯ä»¥æ¸›å°‘è¨˜æ†¶é«”æµªè²»
```
</details>

---

**Q17ï¼šunion çš„ç”¨é€”**
```c
// union æ‰€æœ‰æˆå“¡å…±ç”¨åŒä¸€å¡Šè¨˜æ†¶é«”

union Data {
    int i;
    float f;
    char str[20];
};

printf("sizeof(union Data) = %zu\n", sizeof(union Data));  // è¼¸å‡ºï¼Ÿ

// ç”¨é€”ï¼šè§£æç¡¬é«”æš«å­˜å™¨
union Register {
    uint32_t raw;
    struct {
        uint32_t bit0_3  : 4;
        uint32_t bit4_7  : 4;
        uint32_t bit8_15 : 8;
        uint32_t bit16_31: 16;
    } bits;
};
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```
sizeof(union Data) = 20

union çš„å¤§å° = æœ€å¤§æˆå“¡çš„å¤§å°ï¼ˆstr[20] = 20 bytesï¼‰

ç”¨é€”ï¼š
1. ç¯€çœè¨˜æ†¶é«”ï¼ˆç•¶ä¸€æ¬¡åªä½¿ç”¨ä¸€å€‹æˆå“¡æ™‚ï¼‰
2. åŒä¸€å¡Šè³‡æ–™ç”¨ä¸åŒæ–¹å¼è§£è®€ï¼ˆä¾‹å¦‚æš«å­˜å™¨çš„ raw value å’Œ bit fieldsï¼‰
```
</details>

---

## ğŸ”´ ç¬¬å…­é¡ï¼šé è™•ç†å™¨ â€” å¸¸è€ƒ

**Q18ï¼š#define é™·é˜±**
```c
#define SQUARE(x) x * x

int a = SQUARE(3);      // çµæœï¼Ÿ
int b = SQUARE(1 + 2);  // çµæœï¼Ÿ
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```c
int a = SQUARE(3);      // å±•é–‹ç‚º 3 * 3 = 9 âœ“
int b = SQUARE(1 + 2);  // å±•é–‹ç‚º 1 + 2 * 1 + 2 = 1 + 2 + 2 = 5 âœ—ï¼ˆæœŸæœ›æ˜¯ 9ï¼‰

æ­£ç¢ºå¯«æ³•ï¼š
#define SQUARE(x) ((x) * (x))

é€™æ¨£ SQUARE(1 + 2) å±•é–‹ç‚º ((1 + 2) * (1 + 2)) = 9 âœ“
```
</details>

---

**Q19ï¼š#define vs inline function**

é€™æ˜¯é¢è©¦å®˜éå¸¸å–œæ­¡å•çš„ç¶“å…¸é¡Œï¼Œæ ¸å¿ƒåœ¨æ–¼æ˜¯å¦ç†è§£ã€Œé è™•ç†å™¨ã€èˆ‡ã€Œç·¨è­¯å™¨ã€çš„è¡Œç‚ºå·®ç•°ã€‚

**1. æ ¸å¿ƒå·®ç•°æ¯”è¼ƒè¡¨**

| ç‰¹æ€§ | #define (å·¨é›†) | inline function (è¡Œå…§å‡½å¼) |
| :--- | :--- | :--- |
| **æœ¬è³ª** | åªæ˜¯**æ–‡å­—æ›¿æ›** (Text Substitution) | çœŸæ­£çš„**å‡½å¼** (Function) |
| **è™•ç†éšæ®µ** | é è™•ç†éšæ®µ (Preprocessor) | ç·¨è­¯éšæ®µ (Compilation) |
| **å‹åˆ¥æª¢æŸ¥** | âŒ ç„¡ (ä»»ä½•å‹åˆ¥éƒ½ç¡¬å¡ï¼Œæ˜“å‡ºéŒ¯) | âœ… æœ‰ (ç·¨è­¯å™¨æœƒæª¢æŸ¥å‹åˆ¥æ˜¯å¦åŒ¹é…) |
| **åƒæ•¸å‰¯ä½œç”¨** | âš ï¸ **æ¥µå±éšª** (å¦‚ `x++` å¯èƒ½è¢«ç®—å…©æ¬¡) | âœ… **å®‰å…¨** (åƒæ•¸å…ˆè¨ˆç®—å¥½æ‰å‚³å…¥) |
| **é™¤éŒ¯ (Debug)** | å›°é›£ (è¢«å±•é–‹äº†ï¼Œçœ‹ä¸åˆ°åŸå§‹åç¨±) | å®¹æ˜“ (å¯ä»¥åƒæ™®é€šå‡½å¼ä¸€æ¨£è¿½è¹¤) |

**2. ç‚ºä»€éº¼ #define å±éšªï¼Ÿ (Double Evaluation)**

å› ç‚º `#define` åªæ˜¯ç¬¨ç¬¨åœ°æŠŠæ–‡å­—è²¼ä¸Šå»ï¼Œä¸æœƒé‹ç®—ã€‚
ç•¶ä½ å¯« `#define MAX(a, b) ((a) > (b) ? (a) : (b))`ï¼Œä¸¦å‘¼å« `MAX(x++, y++)` æ™‚ï¼š

é è™•ç†å™¨æœƒæŠŠå®ƒå±•é–‹æˆï¼š
`((x++) > (y++) ? (x++) : (y++))`

é€™æœƒå°è‡´ï¼š
1. æ¯”è¼ƒ `(x++) > (y++)` æ™‚ï¼ŒåŸ·è¡Œäº†ä¸€æ¬¡ `++`ã€‚
2. æ¯”è¼ƒçµæœç‚ºçœŸï¼Œå›å‚³ `(x++)`ï¼Œ**åˆ**åŸ·è¡Œäº†ä¸€æ¬¡ `++`ã€‚
3. çµæœï¼š`x` è¢«åŠ äº†å…©æ¬¡ï¼

**3. ç¨‹å¼ç¢¼ç¯„ä¾‹**

```c
#define MAX(a, b) ((a) > (b) ? (a) : (b))

inline int max(int a, int b) {
    return a > b ? a : b;
}

// å¯¦éš›å·®ç•°æ¼”ç¤ºï¼š
int x = 5, y = 3;

// --- Case 1: #define (å±éšª) ---
// å±•é–‹ç¢¼ï¼š int m1 = ((x++) > (y++) ? (x++) : (y++));
// æ­¥é©Ÿ 1: æ¯”è¼ƒ 5 > 3 (True)ã€‚å‰¯ä½œç”¨ï¼šxè®Š6, yè®Š4ã€‚
// æ­¥é©Ÿ 2: å› ç‚º Trueï¼ŒåŸ·è¡Œå‰åŠæ®µ (x++)ã€‚å›å‚³ 6ã€‚å‰¯ä½œç”¨ï¼šxå†åŠ 1è®Š7ã€‚
int m1 = MAX(x++, y++);
// çµæœï¼šm1 = 6, x = 7 (éŒ¯èª¤ï¼å¤šåŠ äº†ä¸€æ¬¡), y = 4

// --- Case 2: inline function (å®‰å…¨) ---
// æ­¥é©Ÿ 1: è¨ˆç®—åƒæ•¸å€¼ã€‚x++ å›å‚³ 5 (xè®Š6)ï¼Œy++ å›å‚³ 3 (yè®Š4)ã€‚
// æ­¥é©Ÿ 2: å‘¼å« max(5, 3)ã€‚
// æ­¥é©Ÿ 3: å‡½å¼å…§åŸ·è¡Œ 5 > 3 ? 5 : 3ï¼Œå›å‚³ 5ã€‚
x = 5; y = 3; // é‡ç½®
int m2 = max(x++, y++);
// çµæœï¼šm2 = 5, x = 6, y = 4 (æ­£ç¢º)
```

---

## ğŸ”´ ç¬¬ä¸ƒé¡ï¼šLinked List â€” å¸¸è€ƒæ‰‹å¯«

**Q20ï¼šåè½‰ Linked List**

> âš ï¸ **æ³¨æ„ï¼šC èˆ‡ C++ çš„å¯«æ³•å·®ç•°**
> è¨±å¤šäººåœ¨ LeetCode åˆ·é¡Œæ™‚ç¿’æ…£ç”¨ C++ï¼ŒC++ çš„ `struct` å¯ä»¥ç›´æ¥ç•¶ä½œå‹åˆ¥åç¨±ä½¿ç”¨ï¼ˆå¦‚ `ListNode*`ï¼‰ã€‚
> ä½†åœ¨ **ç´” C èªè¨€** ä¸­ï¼Œé è¨­å¿…é ˆå¯«å®Œæ•´çš„ `struct Node*`ï¼Œé™¤éä½¿ç”¨ `typedef` å®šç¾©åˆ¥åã€‚é¢è©¦æ™‚è«‹å‹™å¿…å€åˆ†æ¸…æ¥šã€‚

*ä»¥ä¸‹æ¡ç”¨ typedef å¯«æ³•ï¼Œç¬¦åˆ C èªè¨€æ…£ä¾‹ï¼š*

```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* reverseList(Node *head) {
    // ä½ çš„ç­”æ¡ˆï¼Ÿ
}
```
<details>
<summary>é»æ“ŠæŸ¥çœ‹ç­”æ¡ˆ</summary>

```c
Node* reverseList(Node *head) {
    Node *prev = NULL;
    Node *curr = head;
    Node *next = NULL;
    
    while (curr != NULL) {
        next = curr->next;  // å…ˆå„²å­˜ä¸‹ä¸€å€‹ç¯€é»
        curr->next = prev;  // åè½‰æŒ‡æ¨™æ–¹å‘
        prev = curr;        // prev å‰é€²
        curr = next;        // curr å‰é€²
    }
    
    return prev;  // prev ç¾åœ¨æ˜¯æ–°çš„ head
}
```
</details>

---

## âœ… ç·´ç¿’è¨ˆåŠƒ

| é€± | é¡Œç›®ç¯„åœ | æ¯æ—¥ç·´ç¿’é‡ |
|---|---------|-----------|
| 1 | Q1-Q5ï¼ˆæŒ‡æ¨™ï¼‰| 2-3 é¡Œ |
| 2 | Q6-Q12ï¼ˆè¨˜æ†¶é«”ã€ä½å…ƒé‹ç®—ï¼‰| 2-3 é¡Œ |
| 3 | Q13-Q19ï¼ˆé—œéµå­—ã€structã€macroï¼‰| 2-3 é¡Œ |
| 4 | Q20 + ç¶œåˆè¤‡ç¿’ | æ¨¡æ“¬é¢è©¦ |
