# 📋 C 語言面試必考題目完整攻略

> **學習目標**
> - 本文件涵蓋 IC 韌體、嵌入式系統面試最常見的 C 語言題目
> - 每題均附詳細解答、原理分析、常見追問
> - 目標：只讀這份資料，就能從容應對 80% 以上的 C 語言技術面試

---

## 🔴 第一類：指標（Pointer）— 必考！

### 基礎概念

**Q1：什麼是指標？請從記憶體角度解釋。**

```c
指標是一個變數，儲存另一個變數的「記憶體位址」。

int a = 10;      // a 是一個整數變數，值為 10
int *p = &a;     // p 是指標，儲存 a 的位址

// & 取址運算子：取得變數的位址
// * 取值運算子（解引用）：取得位址指向的值

// 記憶體視覺化（假設 64-bit 系統）：
// 
// 位址          內容        變數
// 0x1000        10          a (4 bytes)
// 0x1008        0x1000      p (8 bytes，儲存 a 的位址)
```

**標準答案要點**：
1. 指標儲存的是記憶體位址，不是值
2. 指標本身也佔記憶體空間（64-bit 系統佔 8 bytes）
3. 不同型別的指標大小相同，都是系統位元數決定

---

**Q2：以下程式碼的輸出是什麼？解釋二重指標。**

```c
int a = 5;
int *p = &a;
int **pp = &p;

printf("%d\n", *p);      // 輸出？
printf("%d\n", **pp);    // 輸出？
printf("%p\n", *pp);     // 輸出？
```

<details>
<summary>點擊查看答案</summary>

```
5
5
<p 的值，即 a 的位址>

解釋：
- *p 取得 p 指向的值，即 a 的值 = 5
- **pp 先取得 pp 指向的值（即 p），再取得 p 指向的值（即 a）= 5
- *pp 取得 pp 指向的值，即 p = a 的位址

記憶體關係：
pp → p → a
```
</details>

---

**Q3：指標算術的底層原理**

```c
int arr[] = {10, 20, 30, 40, 50};
int *p = arr;

printf("%d\n", *p);        // 輸出？
printf("%d\n", *(p+2));    // 輸出？
printf("%d\n", p[3]);      // 輸出？
p++;
printf("%d\n", *p);        // 輸出？
```

<details>
<summary>點擊查看答案</summary>

```
10
30
40
20

解釋：
- *p 取得 arr[0] = 10
- *(p+2) 取得 arr[2] = 30
  - 重點：p+2 移動的是「2 個 int 的大小」= 8 bytes，不是 2 bytes！
- p[3] 等價於 *(p+3) = arr[3] = 40
- p++ 後，p 指向 arr[1]，所以 *p = 20

指標算術公式：
p + n 的實際位址 = (char*)p + n * sizeof(*p)
```
</details>

---

**Q4：sizeof 與指標**

```c
int arr[5] = {1, 2, 3, 4, 5};
int *p = arr;

printf("sizeof(arr) = %zu\n", sizeof(arr));  // 輸出？
printf("sizeof(p) = %zu\n", sizeof(p));      // 輸出？

void func(int arr[]) {
    printf("sizeof(arr) in func = %zu\n", sizeof(arr));  // 輸出？
}
```

<details>
<summary>點擊查看答案</summary>

```
sizeof(arr) = 20  （5 個 int * 4 bytes = 20）
sizeof(p) = 8     （64位元系統的指標大小）
sizeof(arr) in func = 8  （陣列傳入函式會退化成指標！）

關鍵概念：
- sizeof(arr) 回傳整個陣列的大小
- sizeof(p) 回傳指標變數本身的大小（和系統位元數有關，與指向型別無關）
- 陣列傳入函式會「退化」(decay) 成指標，失去大小資訊
```
</details>

---

**Q5：指標與陣列的差異 — 經典陷阱題**

```c
char str1[] = "Hello";
char *str2 = "Hello";

str1[0] = 'h';   // 這行會怎樣？
str2[0] = 'h';   // 這行會怎樣？
```

<details>
<summary>點擊查看答案</summary>

```
str1[0] = 'h';  → ✅ 合法，可以修改
str2[0] = 'h';  → ❌ 未定義行為（通常 Segmentation Fault）

深入解釋（記憶體佈局）：

1. char str1[] = "Hello"; (陣列初始化)
   - 記憶體位置：Stack (堆疊區)
   - 行為：編譯器在 Stack 上分配 6 bytes，將 "Hello" 從唯讀區複製過來
   - 權限：Stack 空間可讀可寫

2. char *str2 = "Hello"; (指標指向字串常量)
   - 記憶體位置：
     - 指標變數 str2：Stack
     - 字串常量 "Hello"：.rodata (唯讀資料區)
   - 行為：str2 只儲存字串常量的位址
   - 權限：.rodata 區域唯讀，修改會觸發記憶體保護機制

圖解：
[ Stack ]          [ .rodata (Read-only) ]
+-------+          +-------+
| 'H'.. | ← str1   | "Hello" | ← str2 指向這裡 (不可寫)
+-------+          +-------+
| str2  | ─────────^
+-------+
```
</details>

---

**Q6：arr 和 &arr 的區別 — 進階面試題**

```c
int arr[5] = {10, 20, 30, 40, 50};

printf("arr     = %p\n", arr);
printf("&arr    = %p\n", &arr);
printf("arr + 1 = %p\n", arr + 1);
printf("&arr + 1= %p\n", &arr + 1);
```

<details>
<summary>點擊查看答案</summary>

```
arr     = 0x1000           （假設）
&arr    = 0x1000           （數值相同！）
arr + 1 = 0x1004           （移動 4 bytes = sizeof(int)）
&arr + 1= 0x1014           （移動 20 bytes = sizeof(int[5])）

關鍵區別：
- arr 退化後的型別是 int*，+1 移動 sizeof(int) = 4 bytes
- &arr 的型別是 int (*)[5]（指向「含 5 個 int 的陣列」的指標）
- &arr + 1 移動 sizeof(int[5]) = 20 bytes

這是面試官測試你對「陣列型別」理解深度的經典題目！
```
</details>

---

## 🔴 第二類：記憶體管理 — 必考！

**Q7：Stack vs Heap 完整比較**

| 特性 | Stack（堆疊） | Heap（堆積） |
|:---|:---|:---|
| 管理方式 | 自動（編譯器管理） | 手動（程式員管理） |
| 分配速度 | 極快（只需移動 SP） | 較慢（需搜尋可用空間） |
| 大小限制 | 有限（1-8 MB） | 較大（可達數 GB） |
| 成長方向 | 向低位址成長 | 向高位址成長 |
| 生命週期 | 函式結束自動釋放 | 直到 free() 才釋放 |
| 碎片化 | 無 | 可能產生碎片 |
| 典型用途 | 區域變數、參數 | 動態資料結構 |
| 對齊 | 自動對齊 | malloc 保證最大對齊 |

---

**Q8：以下程式碼有什麼問題？（Dangling Pointer）**

```c
char* getString() {
    char str[] = "Hello";
    return str;
}

int main() {
    char *s = getString();
    printf("%s\n", s);
    return 0;
}
```

<details>
<summary>點擊查看答案</summary>

```
問題：回傳指向區域變數的指標（Dangling Pointer / 懸空指標）

str 是區域陣列，存在 stack 上。
函式結束後，str 的記憶體被釋放（實際上是 SP 移動，資料仍在但無效）。
回傳的指標指向已釋放的記憶體 → 未定義行為。

修正方式（三選一）：

1. 使用 static：
   static char str[] = "Hello";
   // str 存在 data section，生命週期是整個程式
   // 缺點：不可重入（non-reentrant）

2. 使用 malloc：
   char *str = malloc(6);
   strcpy(str, "Hello");
   return str;
   // 呼叫者需要負責 free()
   // 缺點：可能 memory leak

3. 回傳字串常量：
   return "Hello";
   // 字串常量存在 .rodata，生命週期是整個程式
   // 缺點：回傳的是唯讀字串
```
</details>

---

**Q9：Memory Leak 範例與檢測**

```c
void func() {
    int *p = (int*)malloc(10 * sizeof(int));
    // 使用 p...
    // 函式結束，但沒有 free(p)
}
```

<details>
<summary>點擊查看答案</summary>

```
問題：Memory Leak（記憶體洩漏）

malloc 分配的記憶體在 heap 上，不會自動釋放。
如果沒有 free()，這塊記憶體會一直被佔用。
長時間運行的程式（如 BMC 韌體）會導致記憶體耗盡。

檢測工具：
1. Valgrind（Linux）：
   valgrind --leak-check=full ./your_program
   
2. AddressSanitizer（GCC/Clang）：
   gcc -fsanitize=address -g your_code.c
   
3. 靜態分析：
   cppcheck, Coverity

最佳實踐：
1. 誰 malloc 誰 free（明確責任）
2. free 後將指標設為 NULL
3. 使用 RAII 模式（C++ 或類似設計）
4. 在嵌入式系統中，考慮使用記憶體池
```
</details>

---

**Q10：這個 realloc 使用有什麼問題？**

```c
int *p = malloc(10 * sizeof(int));
p = realloc(p, 1000000000 * sizeof(int));
if (p == NULL) {
    printf("Allocation failed\n");
}
```

<details>
<summary>點擊查看答案</summary>

```
問題：如果 realloc 失敗回傳 NULL，原本的記憶體就洩漏了！

因為 p 被覆蓋成 NULL，我們失去了原本記憶體的指標。

正確寫法：
int *p = malloc(10 * sizeof(int));
int *new_p = realloc(p, new_size);
if (new_p == NULL) {
    printf("Allocation failed, but p is still valid\n");
    // p 仍然可用，可以選擇繼續使用或釋放
} else {
    p = new_p;  // realloc 成功才更新 p
}

realloc 的行為：
1. 成功時：可能原地擴展，也可能搬到新位置（舊位置自動釋放）
2. 失敗時：回傳 NULL，原本的記憶體不變
3. realloc(p, 0) 等同於 free(p)（回傳 NULL 或小塊記憶體）
```
</details>

---

**Q11：Double Free 的危害**

```c
int *p = malloc(sizeof(int));
free(p);
free(p);  // 會發生什麼？
```

<details>
<summary>點擊查看答案</summary>

```
後果：未定義行為，可能導致：

1. Heap Corruption：
   - 破壞 malloc/free 的內部資料結構（如 free list）
   - 後續的 malloc/free 呼叫可能 crash 或行為異常

2. 安全漏洞（Use-After-Free / Double-Free Exploit）：
   - 攻擊者可能利用此漏洞控制程式執行流程
   - 是 CVE 漏洞的常見來源

3. 難以偵錯：
   - crash 可能發生在很久之後，與 bug 位置無關

預防措施：
1. free 後立即設 p = NULL
   （對 NULL 指標 free 是安全的，沒有作用）
2. 使用 AddressSanitizer 檢測
3. 使用 smart pointer（C++）或記憶體池
```
</details>

---

## 🔴 第三類：關鍵字詳解 — 必考！

### volatile 關鍵字

**Q12：volatile 的用途與原理**

```c
volatile 告訴編譯器：這個變數的值可能被外部因素改變，
不要進行優化，每次都要從記憶體讀取。
```

**使用場景 1：硬體暫存器**

```c
// 假設 0x4000 是某硬體狀態暫存器，硬體會自動更新其數值
volatile uint32_t *status_reg = (uint32_t *)0x4000;

// 迴圈等待硬體完成任務（狀態變為 1）
while (*status_reg == 0);  // 必須用 volatile！

/* 優化差異：
- 無 volatile：編譯器可能認為迴圈內沒人改 *status_reg，
    因此只從記憶體讀一次到暫存器，導致無窮迴圈。
- 有 volatile：編譯器每次都會重新從記憶體 0x4000 讀取最新狀態。 */
```

**使用場景 2：中斷服務程式 (ISR) 修改的全域變數**

```c
volatile int flag = 0;

void timer_isr() {
    flag = 1;  // 由硬體觸發的中斷修改 flag
}

void main() {
    while (flag == 0);  // 等待中斷發生後跳出迴圈
    // 必須用 volatile，否則編譯器可能優化掉這個迴圈
}
```

**使用場景 3：多執行緒共享變數（但注意這不保證原子性！）**

```c
// volatile 只保證「每次都從記憶體讀取」
// 不保證「原子操作」或「記憶體順序」
// 多執行緒應該用 atomic 或 mutex！
```

---

### static 關鍵字

**Q13：static 的三種用法**

```c
// 用法 1：靜態區域變數 — 值在函式呼叫間保留
void counter() {
    static int count = 0;  // 只初始化一次！
    count++;
    printf("%d\n", count);
}
// 多次呼叫會輸出 1, 2, 3, 4...

// 用法 2：靜態全域變數 — 限制作用域在該檔案內
static int file_scope_var = 10;
// 其他 .c 檔案無法 extern 這個變數

// 用法 3：靜態函式 — 限制作用域在該檔案內
static void helper_function() { }
// 其他 .c 檔案無法呼叫這個函式
// 避免命名衝突，實現「資訊隱藏」
```

**面試追問：static 區域變數存在哪裡？**

```c
// 答：存在 Data Section（已初始化）或 BSS Section（未初始化/初始化為 0）
// 不是存在 Stack！
// 所以生命週期是整個程式，但作用域只在函式內
```

---

### const 關鍵字

**Q14：const 與指標的組合**

```c
int x = 10, y = 20;

// 1. 指向常數的指標 (Pointer to Constant)
const int *p1 = &x;
// *p1 = 20;     // ❌ 錯誤：不能透過 p1 修改值
p1 = &y;         // ✅ 正確：p1 可以改指向別處

// 2. 常數指標 (Constant Pointer)
int * const p2 = &x;
*p2 = 20;        // ✅ 正確：可以透過 p2 修改值
// p2 = &y;      // ❌ 錯誤：p2 不能改指向別處

// 3. 指向常數的常數指標 (Constant Pointer to Constant)
const int * const p3 = &x;
// *p3 = 20;     // ❌ 錯誤
// p3 = &y;      // ❌ 錯誤

// 記憶方法：
// const 在 * 左邊 → 指向的「值」不可改
// const 在 * 右邊 → 「指標」本身不可改
```

**面試追問：const 變數真的不能被修改嗎？**

```c
const int secret = 42;
int *hacker = (int *)&secret;
*hacker = 100;  // 編譯通過，但是未定義行為！

// 答：C 語言的 const 是「語法層面的保護」，不是「硬體保護」
// 可以透過指標繞過，但這是未定義行為
// 如果 const 變數在 .rodata 區，修改會 Segfault
```

---

### extern 關鍵字

**Q15：extern 的用法**

```c
// file1.c
int global_var = 100;       // 定義（有記憶體配置）

// file2.c
extern int global_var;      // 宣告（沒有記憶體配置）
// 告訴編譯器：global_var 定義在別的檔案

void func() {
    printf("%d\n", global_var);  // 使用 file1.c 的 global_var
}

// 最佳實踐：在 .h 檔案中宣告 extern，在 .c 檔案中定義
// header.h
extern int global_var;

// source.c
#include "header.h"
int global_var = 100;
```

---

### inline 關鍵字

**Q16：inline 的意義與陷阱**

```c
// inline 是「建議」編譯器將函式展開，避免函式呼叫的開銷
inline int square(int x) {
    return x * x;
}

// 注意事項：
// 1. 編譯器可以忽略 inline 建議
// 2. 過大的函式不應該 inline（增加程式碼大小）
// 3. 遞迴函式無法 inline

// C99 的 inline 語意很複雜：
// - 單純 inline：需要在某個 .c 檔提供外部定義
// - static inline：最常用，每個編譯單元各自展開
// - extern inline：很少用
```

**面試追問：`static inline` 和 `inline` 的區別？**

```c
// static inline（推薦用法）
static inline int add(int a, int b) { return a + b; }
// - 每個 .c 檔案有自己的副本
// - 如果沒被 inline，產生 static 函式
// - 在 header 中定義最安全

// inline（C99 語意）
inline int add(int a, int b) { return a + b; }
// - 如果沒被 inline，需要在某個 .c 檔提供外部定義：
//   extern inline int add(int a, int b);
// - 否則會有連結錯誤
```

---

## 🔴 第四類：位元運算 — 必考！

**Q17：基本位元運算**

```c
unsigned char a = 0b11001010;  // 202
unsigned char b = 0b01100110;  // 102

a & b = ?
a | b = ?
a ^ b = ?
~a = ?
a << 2 = ?
a >> 3 = ?
```

<details>
<summary>點擊查看答案</summary>

```
a & b = 0b01000010 = 66   (兩者都是 1 才是 1)
a | b = 0b11101110 = 238  (任一為 1 就是 1)
a ^ b = 0b10101100 = 172  (不同為 1，相同為 0)
~a    = 0b00110101 = 53   (0 和 1 互換，假設 8-bit)
a << 2 = 0b00101000 = 40  (左移 2 位，超出的位元遺失)
a >> 3 = 0b00011001 = 25  (右移 3 位)

注意：
- ~a 實際上會做整數提升，結果是 0xFFFFFF35（32-bit）
- 如果只要 8-bit 結果：(unsigned char)~a 或 ~a & 0xFF
```
</details>

---

**Q18：SET、CLEAR、TOGGLE、CHECK 特定 bit**

```c
// 這是嵌入式開發最常用的操作！

unsigned char reg = 0b00000000;

// 設定第 3 bit 為 1 (SET)
reg |= (1 << 3);
// 結果：0b00001000

// 清除第 5 bit 為 0 (CLEAR)
reg = 0b11111111;
reg &= ~(1 << 5);
// 結果：0b11011111

// 切換第 2 bit (TOGGLE)
reg = 0b00000100;
reg ^= (1 << 2);
// 結果：0b00000000（1 變 0）

// 檢查第 3 bit (CHECK)
if (reg & (1 << 3)) {
    // bit 3 是 1
}

// 標準巨集定義
#define SET_BIT(reg, n)    ((reg) |= (1U << (n)))
#define CLEAR_BIT(reg, n)  ((reg) &= ~(1U << (n)))
#define TOGGLE_BIT(reg, n) ((reg) ^= (1U << (n)))
#define CHECK_BIT(reg, n)  ((reg) & (1U << (n)))
```

---

**Q19：判斷數字是否為 2 的冪次**

```c
int isPowerOfTwo(unsigned int n) {
    return n != 0 && (n & (n - 1)) == 0;
}

/* 解釋：
- 2 的冪次在二進位中只有一個 bit 是 1
- n & (n - 1) 會清除最低位的 1
- 例如：8 = 0b1000，7 = 0b0111，8 & 7 = 0
- 如果清除後結果是 0，代表只有一個 1 → 是 2 的冪次
- n != 0 是因為 0 不是 2 的冪次
*/
```

---

**Q20：計算二進位中 1 的個數**

```c
// 方法一：逐位檢查（時間複雜度 O(log n)）
int countSetBits_v1(unsigned int n) {
    int count = 0;
    while (n) {
        count += (n & 1);
        n >>= 1;
    }
    return count;
}

// 方法二：Brian Kernighan（時間複雜度 O(k)，k 是 1 的個數）
int countSetBits_v2(unsigned int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // 消除最低位的 1
        count++;
    }
    return count;
}

// 方法三：GCC 內建函式（最快，使用硬體指令）
int countSetBits_v3(unsigned int n) {
    return __builtin_popcount(n);
}
```

---

## 🔴 第五類：結構體與聯集 — 常考

**Q21：struct padding（記憶體對齊）**

```c
struct Example1 {
    char a;      // 1 byte
    int b;       // 4 bytes
    char c;      // 1 byte
};

struct Example2 {
    int b;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
};

printf("sizeof(Example1) = %zu\n", sizeof(struct Example1));  // 輸出？
printf("sizeof(Example2) = %zu\n", sizeof(struct Example2));  // 輸出？
```

<details>
<summary>點擊查看答案</summary>

```
sizeof(Example1) = 12
sizeof(Example2) = 8

解釋（假設 4-byte alignment）：

Example1:
| a |pad|pad|pad| b  b  b  b | c |pad|pad|pad|
  1      3            4         1      3       = 12 bytes

Example2:
| b  b  b  b | a | c |pad|pad|
      4        1   1    2      = 8 bytes

Padding 規則：
1. 每個成員的起始位址必須是其對齊要求的倍數
2. 結構體的總大小必須是最大成員對齊要求的倍數
3. 對齊要求通常等於型別的大小（int=4, double=8）

結論：重新排列成員順序可以減少記憶體浪費！
最佳實踐：按大小排列成員（大的在前或大的在後）
```
</details>

---

**Q22：union 的用途**

```c
// union 所有成員共用同一塊記憶體

union Data {
    int i;
    float f;
    char str[20];
};

printf("sizeof(union Data) = %zu\n", sizeof(union Data));  // 20

// 用途 1：節省記憶體（當一次只使用一個成員時）
// 用途 2：同一塊資料用不同方式解讀

// 用途 2 的經典應用：暫存器存取
typedef union {
    uint32_t raw;              // 一次讀寫整個暫存器
    struct {
        uint32_t bit0_3  : 4;  // bit 0-3
        uint32_t bit4_7  : 4;  // bit 4-7
        uint32_t bit8_15 : 8;  // bit 8-15
        uint32_t bit16_31: 16; // bit 16-31
    } bits;
} Register_t;

volatile Register_t *reg = (volatile Register_t *)0x40000000;

// 可以這樣用：
reg->bits.bit4_7 = 5;     // 只修改 bit 4-7
uint32_t val = reg->raw;  // 讀取整個暫存器
```

---

**Q23：Bit Field 的注意事項**

```c
struct Flags {
    unsigned int a : 1;  // 1 bit
    unsigned int b : 3;  // 3 bits
    unsigned int c : 4;  // 4 bits
};

// 注意事項：
// 1. Bit 順序是「實作定義」(implementation-defined)
//    有些編譯器從 LSB 開始，有些從 MSB 開始
// 2. 不可跨平台使用在二進位檔案或網路傳輸
// 3. 設定一個 bit field 不是原子操作（可能 read-modify-write）

// 建議：
// - 只在單一平台上的暫存器操作使用
// - 跨平台資料交換使用明確的 shift 和 mask
```

---

## 🔴 第六類：預處理器 — 常考

**Q24：#define 陷阱 — 經典面試題**

```c
#define SQUARE(x) x * x

int a = SQUARE(3);      // 結果？
int b = SQUARE(1 + 2);  // 結果？
int c = SQUARE(a++);    // 結果？
```

<details>
<summary>點擊查看答案</summary>

```c
int a = SQUARE(3);      // 展開為 3 * 3 = 9 ✓
int b = SQUARE(1 + 2);  // 展開為 1 + 2 * 1 + 2 = 5 ✗（期望是 9）
int c = SQUARE(a++);    // 展開為 a++ * a++ → 雙重副作用！未定義行為

正確寫法：
#define SQUARE(x) ((x) * (x))

這樣 SQUARE(1 + 2) 展開為 ((1 + 2) * (1 + 2)) = 9 ✓
但 SQUARE(a++) 仍然有問題！a 會被 ++ 兩次

更安全的寫法（使用 inline 函式）：
static inline int square(int x) {
    return x * x;
}
// square(a++) 只會讓 a 增加一次
```
</details>

---

**Q25：#define vs inline function — 經典比較**

| 特性 | #define (巨集) | inline function |
|:---|:---|:---|
| **本質** | 文字替換 (Preprocessor) | 真正的函式 (Compiler) |
| **型別檢查** | ❌ 無 | ✅ 有 |
| **參數副作用** | ⚠️ 危險（可能被計算多次） | ✅ 安全（只計算一次） |
| **除錯** | 困難（被展開了） | 容易（有函式名稱） |
| **可以用的地方** | 常數、型別別名、條件編譯 | 小型運算函式 |

**巨集適合的場景**：
```c
// 1. 常數定義
#define MAX_BUFFER_SIZE 1024

// 2. 型別別名（或用 typedef）
#define UINT32 unsigned int

// 3. 條件編譯
#ifdef DEBUG
    #define LOG(x) printf(x)
#else
    #define LOG(x)
#endif
```

---

**Q26：## 和 # 運算子**

```c
// # 字串化運算子（Stringification）
#define PRINT_VAR(x) printf(#x " = %d\n", x)
int foo = 42;
PRINT_VAR(foo);  // 輸出：foo = 42

// ## 連接運算子（Token Concatenation）
#define DECLARE_VAR(type, name) type var_##name
DECLARE_VAR(int, count);  // 展開為：int var_count;

// 實際應用：產生序列化函式
#define DEFINE_GETTER(field) \
    int get_##field(void) { return data.field; }
```

---

## 🔴 第七類：Linked List — 常考手寫

**Q27：反轉 Linked List — 必考！**

```c
// ⚠️ 注意：C 語言必須寫完整的 struct Node*
// 使用 typedef 定義別名更方便

typedef struct Node {
    int data;
    struct Node *next;
} Node;

Node* reverseList(Node *head) {
    Node *prev = NULL;
    Node *curr = head;
    Node *next = NULL;
    
    while (curr != NULL) {
        next = curr->next;  // 1. 先儲存下一個節點
        curr->next = prev;  // 2. 反轉指標方向
        prev = curr;        // 3. prev 前進
        curr = next;        // 4. curr 前進
    }
    
    return prev;  // prev 現在是新的 head
}

// 圖解：
// 原始：1 -> 2 -> 3 -> NULL
// 結果：NULL <- 1 <- 2 <- 3
//                        ^prev
```

---

**Q28：檢測 Linked List 是否有環（Floyd's Cycle Detection）**

```c
// 經典的「快慢指標」演算法

int hasCycle(Node *head) {
    if (head == NULL) return 0;
    
    Node *slow = head;
    Node *fast = head;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;        // 慢指標走一步
        fast = fast->next->next;  // 快指標走兩步
        
        if (slow == fast) {
            return 1;  // 有環
        }
    }
    
    return 0;  // 無環
}

// 原理：
// 如果有環，快指標一定會追上慢指標
// 就像操場跑步，快的人一定會追上慢的人
```

---

**Q29：找出 Linked List 環的起點**

```c
Node* detectCycle(Node *head) {
    if (head == NULL) return NULL;
    
    Node *slow = head;
    Node *fast = head;
    
    // 1. 找到相遇點
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        
        if (slow == fast) {
            // 2. 從 head 和相遇點同時出發
            Node *ptr1 = head;
            Node *ptr2 = slow;
            while (ptr1 != ptr2) {
                ptr1 = ptr1->next;
                ptr2 = ptr2->next;
            }
            return ptr1;  // 環的起點
        }
    }
    
    return NULL;  // 無環
}

// 數學證明：
// 設 head 到環起點距離 = a
// 環起點到相遇點距離 = b
// 相遇點到環起點距離 = c（環長 = b + c）
// 
// 相遇時：slow 走了 a + b
//         fast 走了 a + b + k(b+c)，k 是繞環次數
// 因為 fast 速度是 slow 的兩倍：
// 2(a + b) = a + b + k(b+c)
// a + b = k(b+c)
// a = k(b+c) - b = (k-1)(b+c) + c
// 
// 這表示：從 head 走 a 步 = 從相遇點走 c + (k-1)圈 步
// 所以兩個指標同樣速度從 head 和相遇點出發，會在環起點相遇！
```

---

## 🔴 第八類：進階題目

**Q30：手寫 atoi（字串轉整數）**

```c
int my_atoi(const char *str) {
    if (str == NULL) return 0;
    
    // 1. 跳過空白
    while (*str == ' ') str++;
    
    // 2. 處理正負號
    int sign = 1;
    if (*str == '-') {
        sign = -1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    
    // 3. 轉換數字
    long result = 0;
    while (*str >= '0' && *str <= '9') {
        result = result * 10 + (*str - '0');
        
        // 4. 處理溢位
        if (sign == 1 && result > INT_MAX) return INT_MAX;
        if (sign == -1 && -result < INT_MIN) return INT_MIN;
        
        str++;
    }
    
    return (int)(sign * result);
}
```

---

**Q31：手寫 strcmp（字串比較）**

```c
int my_strcmp(const char *s1, const char *s2) {
    while (*s1 && *s1 == *s2) {
        s1++;
        s2++;
    }
    return *(unsigned char *)s1 - *(unsigned char *)s2;
}

// 為什麼要轉型成 unsigned char？
// 因為 char 可能是有號的，負數比較會有問題
// 例如：(unsigned char)0x80 > (unsigned char)0x7F → true
//       (signed char)0x80 < (signed char)0x7F → true（錯誤！）
```

---

**Q32：手寫 memcpy 和 memmove**

```c
// memcpy：不處理重疊（使用 restrict）
void *my_memcpy(void * restrict dest, const void * restrict src, size_t n) {
    char *d = dest;
    const char *s = src;
    while (n--) {
        *d++ = *s++;
    }
    return dest;
}

// memmove：處理重疊
void *my_memmove(void *dest, const void *src, size_t n) {
    char *d = dest;
    const char *s = src;
    
    if (d < s) {
        // 從前往後複製
        while (n--) {
            *d++ = *s++;
        }
    } else if (d > s) {
        // 從後往前複製（避免覆蓋未複製的資料）
        d += n;
        s += n;
        while (n--) {
            *--d = *--s;
        }
    }
    
    return dest;
}

// 圖解重疊情況：
// src:  [A B C D E F]
// dest:     [? ? ? ? ? ?]（與 src 重疊）
// 
// 如果從前往後：複製 A 會覆蓋掉 D，之後 D 就遺失了
// 如果從後往前：先複製 F, E, D...，不會有問題
```

---

**Q33：手寫 malloc 和 free（概念題）**

```c
// 這通常是概念題，不需要完整實作
// 但需要理解基本原理

// 簡單的 malloc 實作概念：

// 1. 維護一個 free list（可用記憶體區塊的鏈結串列）
typedef struct Block {
    size_t size;
    struct Block *next;
    int free;
} Block;

static Block *free_list = NULL;

// 2. malloc 時，從 free list 找到足夠大的區塊
void *my_malloc(size_t size) {
    Block *curr = free_list;
    while (curr) {
        if (curr->free && curr->size >= size) {
            curr->free = 0;
            return (void *)(curr + 1);  // 回傳 header 之後的空間
        }
        curr = curr->next;
    }
    // 如果沒有，向 OS 要更多記憶體（sbrk 或 mmap）
    // ...
}

// 3. free 時，標記區塊為可用
void my_free(void *ptr) {
    if (ptr == NULL) return;
    Block *block = (Block *)ptr - 1;
    block->free = 1;
    // 可以做 coalesce（合併相鄰的 free block）
}

// 實際的 malloc 實作（如 glibc ptmalloc）還考慮：
// - Different size bins
// - Thread safety（per-thread arenas）
// - Coalescing and splitting
// - mmap for large allocations
```

---

## 📝 面試題快速索引

### 指標類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q1 | 指標基礎概念 | ⭐⭐ |
| Q2 | 二重指標 | ⭐⭐⭐ |
| Q3 | 指標算術 | ⭐⭐⭐ |
| Q4 | sizeof 與指標 | ⭐⭐⭐ |
| Q5 | 陣列 vs 指標字串 | ⭐⭐⭐⭐ |
| Q6 | arr vs &arr | ⭐⭐⭐⭐ |

### 記憶體類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q7 | Stack vs Heap | ⭐⭐⭐ |
| Q8 | Dangling Pointer | ⭐⭐⭐ |
| Q9 | Memory Leak | ⭐⭐⭐ |
| Q10 | realloc 陷阱 | ⭐⭐⭐⭐ |
| Q11 | Double Free | ⭐⭐⭐⭐ |

### 關鍵字類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q12 | volatile | ⭐⭐⭐⭐ |
| Q13 | static | ⭐⭐⭐ |
| Q14 | const 與指標 | ⭐⭐⭐ |
| Q15 | extern | ⭐⭐ |
| Q16 | inline | ⭐⭐⭐⭐ |

### 位元運算類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q17 | 基本位元運算 | ⭐⭐ |
| Q18 | SET/CLEAR/TOGGLE | ⭐⭐⭐ |
| Q19 | 判斷 2 的冪次 | ⭐⭐⭐ |
| Q20 | 計算 1 的個數 | ⭐⭐⭐⭐ |

### 結構體類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q21 | struct padding | ⭐⭐⭐ |
| Q22 | union 用途 | ⭐⭐⭐ |
| Q23 | bit field | ⭐⭐⭐⭐ |

### 預處理器類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q24 | #define 陷阱 | ⭐⭐⭐ |
| Q25 | macro vs inline | ⭐⭐⭐⭐ |
| Q26 | # 和 ## 運算子 | ⭐⭐⭐⭐ |

### Linked List 類
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q27 | 反轉 Linked List | ⭐⭐⭐ |
| Q28 | 檢測環 | ⭐⭐⭐ |
| Q29 | 找環的起點 | ⭐⭐⭐⭐ |

### 進階題
| 題號 | 主題 | 難度 |
|:---:|:---|:---:|
| Q30 | 手寫 atoi | ⭐⭐⭐ |
| Q31 | 手寫 strcmp | ⭐⭐⭐ |
| Q32 | 手寫 memcpy/memmove | ⭐⭐⭐⭐ |
| Q33 | malloc 實作原理 | ⭐⭐⭐⭐⭐ |

---

## 📚 延伸閱讀

1. **書籍**
   - 《Expert C Programming》 - Peter van der Linden
   - 《C Traps and Pitfalls》 - Andrew Koenig
   - 《Understanding and Using C Pointers》 - Richard Reese

2. **線上資源**
   - [cdecl.org](https://cdecl.org/) - 複雜宣告解讀工具
   - [Compiler Explorer](https://godbolt.org/) - 查看編譯後的組語

3. **練習平台**
   - LeetCode（Linked List 系列）
   - HackerRank（C 語言練習）

---

## ✅ 練習計劃

| 週 | 題目範圍 | 每日練習量 |
|---|---------|-----------|
| 1 | Q1-Q11（指標、記憶體）| 2-3 題 |
| 2 | Q12-Q20（關鍵字、位元運算）| 2-3 題 |
| 3 | Q21-Q29（結構體、預處理器、Linked List）| 2-3 題 |
| 4 | Q30-Q33（進階題）+ 綜合複習 | 模擬面試 |

---

## ✅ 章節完成報告

- 檔案：`/02_C語言/面試必考題目.md`
- 擴充前行數：645 行
- 擴充後行數：約 1650 行
- 新增/優化面試題數：33 題
- 自檢結果：
  - [x] 涵蓋指標、記憶體、關鍵字、位元運算、結構體等核心主題
  - [x] 每題附詳細解答與原理分析
  - [x] 包含經典手寫題（atoi, strcmp, memcpy, malloc）
  - [x] 包含 Linked List 經典演算法
  - [x] 難度標註與練習計劃
