# 🔧 指標與記憶體進階詳解

> 這是 C 語言面試必考中的必考！

---

## 📌 指標基礎回顧

### 什麼是指標？

```c
// 指標是儲存「記憶體位址」的變數

int a = 10;        // a 是一個 int，值是 10
int *p = &a;       // p 是指標，儲存 a 的位址

printf("a 的值: %d\n", a);      // 10
printf("a 的位址: %p\n", &a);   // 如 0x7ffd12345678
printf("p 的值: %p\n", p);      // 同上，p 儲存 a 的位址
printf("p 指向的值: %d\n", *p); // 10，透過 p 取得 a 的值
```

### 記憶體視覺化
| 記憶體位址 | 內容 | 變數 / 說明 |
| :--- | :--- | :--- |
| 0x1000 ~ 0x1003 | 10 | `int a` (佔 4 bytes) |
| 0x1004 ~ 0x1007 | [Padding] | 記憶體填充 (4 bytes，確保 8-byte 對齊) |
| 0x1008 ~ 0x100F | 0x1000 | `int *p` (在 64-bit 系統佔 8 bytes，儲存 `a` 的位址) |

---

## 🔷 指標運算

### 指標算術

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // p 指向 arr[0]

// 指標 +1 會移動一個元素的大小（int = 4 bytes）
printf("*p = %d\n", *p);         // 10
printf("*(p+1) = %d\n", *(p+1)); // 20
printf("*(p+2) = %d\n", *(p+2)); // 30

// 指標前進
p++;
printf("*p = %d\n", *p);         // 20

// 指標後退
p--;
printf("*p = %d\n", *p);         // 10
```

### 指標相減

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];  // 指向 arr[1]
int *p2 = &arr[4];  // 指向 arr[4]

// 指標相減得到兩者間的元素個數（不是 bytes）
// ptrdiff_t 是定義在 <stddef.h> 的帶正負號整數型別，專門用於儲存指標相減的結果
ptrdiff_t diff = p2 - p1;
printf("diff = %td\n", diff);  // %td 是 ptrdiff_t 專用的格式化字串，此處輸出 3
```

---

## 🔷 多重指標

### 二重指標

```c
int a = 10;
int *p = &a;      // p 是指向 int 的指標
int **pp = &p;    // pp 是指向「指向 int 的指標」的指標

printf("a = %d\n", a);       // 10
printf("*p = %d\n", *p);     // 10
printf("**pp = %d\n", **pp); // 10

// 記憶體視覺化：
// a:  [10]     位址 0x1000
// p:  [0x1000] 位址 0x1008
// pp: [0x1008] 位址 0x1010
//
// **pp：先取 pp 的值 (0x1008)，再取該位址的值 (0x1000)，
//       再取該位址的值 (10)
```

### 二重指標的用途

```c
// 用途 1：在函式中修改指標本身 (Pass by Address of Pointer)
// 技巧說明：
// C 語言只有「傳值」(Pass by Value)。若傳入 int *p，函式內只會得到 p 的副本。
// 修改副本的指向位置（如 malloc）不會影響到外部原本的 p。
// 因此必須傳入「指標的位址」，也就是二重指標 int **pp，才能在函式內修改外部指標的指向。

void allocate(int **pp) {
    *pp = (int*)malloc(sizeof(int)); // 修改外部指標 p 的值（位址）
    **pp = 100;                      // 修改該位址儲存的數值
}

int main() {
    int *p = NULL;
    allocate(&p);             // 傳入「指標 p 的位址」
    printf("*p = %d\n", *p);  // 輸出 100
    free(p);
    return 0;
}

// 用途 2：指向指標的陣列
char *names[] = {"Alice", "Bob", "Charlie"};
char **pp = names;  // pp 指向 names[0]
printf("%s\n", *pp);     // Alice
printf("%s\n", *(pp+1)); // Bob
```

---

## 🔷 指標與陣列

### 陣列名是「常數指標」

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // arr 退化成指向第一個元素的指標

// 這兩個等價：
printf("%d\n", arr[2]);   // 30
printf("%d\n", *(arr+2)); // 30

// 但 arr 是常數，不能 arr++
// p++ 是合法的
```

### 陣列傳入函式

```c
// 當陣列傳入函式，會退化成指標
void printArray(int *arr, int size) {  // 或 int arr[]
    // 在這裡 sizeof(arr) 是指標大小，不是陣列大小！
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printf("sizeof(arr) = %zu\n", sizeof(arr));  // 20 (%zu 是 size_t 專用的格式化字串)
    printArray(arr, 5);  // 傳入後變成指標
}
```

### 二維陣列與指標

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// arr 是「指向 int[4] 的指標」
// arr[0] 是「指向 int 的指標」

int (*p)[4] = arr;  // p 是指向 int[4] 的指標

printf("arr[1][2] = %d\n", arr[1][2]);     // 7
printf("*(*(p+1)+2) = %d\n", *(*(p+1)+2)); // 7
```

---

## 🔷 函式指標

### 基本使用

```c
// 函式指標：指向函式的指標

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    // 宣告函式指標
    int (*fp)(int, int);  // fp 是指標，指向接受兩個 int 回傳 int 的函式
    
    fp = add;  // 指向 add 函式
    printf("%d\n", fp(3, 4));  // 7
    
    fp = sub;  // 指向 sub 函式
    printf("%d\n", fp(3, 4));  // -1
    
    return 0;
}
```

### Callback 函式

```c
// 用函式指標實作 callback
// Callback (回呼) 是一種程式設計模式，核心概念是「將函式指標作為參數傳入另一個函式」。
// 這能實現「邏輯解耦」：主函式負責控制「執行的流程」，而 Callback 則定義「具體的操作」。

void processArray(int *arr, int size, void (*callback)(int)) {
    for (int i = 0; i < size; i++) {
        callback(arr[i]);
    }
}

void printValue(int x) {
    printf("%d ", x);
}

void doubleValue(int x) {
    printf("%d ", x * 2);
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    
    printf("原始: ");
    processArray(arr, 5, printValue);  // 1 2 3 4 5
    
    printf("\n加倍: ");
    processArray(arr, 5, doubleValue); // 2 4 6 8 10
    
    return 0;
}
```

### 函式指標陣列

```c
// 計算機範例
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int div(int a, int b) { return a / b; }

int main() {
    // 函式指標陣列：將多個簽章 (Signature) 相同的函式收集到陣列中，方便透過索引呼叫
    // 語法：回傳型別 (*陣列名稱[大小])(參數列表)
    int (*operations[4])(int, int) = {add, sub, mul, div};
    char *names[] = {"add", "sub", "mul", "div"};
    
    int a = 10, b = 3;
    for (int i = 0; i < 4; i++) {
        printf("%s(%d, %d) = %d\n", names[i], a, b, operations[i](a, b));
    }
    
    return 0;
}
```

---

## 🔷 動態記憶體管理

### malloc / calloc / realloc / free

```c
#include <stdlib.h>

// malloc：分配未初始化的記憶體
int *p1 = (int*)malloc(10 * sizeof(int));
// 在 C 語言中，(int*) 強制轉型是可選的（void* 會自動轉換），但在 C++ 是必要的。
// 加上轉型可增加明確性並相容 C++，但現代 C 實務中常省略以保持簡潔，並避免掩蓋未 include <stdlib.h> 的錯誤。
// 內容是垃圾值

// calloc：分配並初始化為 0
int *p2 = (int*)calloc(10, sizeof(int));
// 內容全是 0

// realloc：重新分配大小
p1 = (int*)realloc(p1, 20 * sizeof(int));
// 擴大到 20 個 int

// free：釋放記憶體
free(p1);
free(p2);

// 重要！free 後將指標設為 NULL
p1 = NULL;
p2 = NULL;
// 註：若不設為 NULL，該指標會指向已釋放的記憶體，稱為「懸空指標」(Dangling Pointer)。
// 設為 NULL 可以避免 Use After Free 錯誤，且在 C 語言中對 NULL 指標執行 free() 是安全的。
```

### 常見錯誤

```c
// 錯誤 1：Memory Leak（記憶體洩漏）
void func() {
    int *p = (int*)malloc(10 * sizeof(int));
    // 沒有 free 就 return 了！
    return;
}

// 錯誤 2：Use After Free
int *p = (int*)malloc(sizeof(int));
*p = 10;
free(p);
*p = 20;  // 危險！p 已經被 free 了

// 錯誤 3：Double Free（重複釋放）
int *p = (int*)malloc(sizeof(int));
free(p);
free(p);  // ❌ 嚴重錯誤！
// 危害：
// 1. Heap Corruption：重複釋放會破壞記憶體管理器的內部資料結構（如 free list），導致後續的 malloc/free 呼叫引發崩潰。
// 2. 安全漏洞：這是一種經典的安全性漏洞，攻擊者可能藉此操控記憶體分配邏輯，達成「任意程式碼執行」。
// 預防：在 free(p) 後立即執行 p = NULL;，因為對 NULL 指標執行 free() 是安全的。

// 錯誤 4：野指標（未初始化的指標）
int *p;
*p = 10;  // 危險！p 沒有指向有效記憶體
```

---

## 🔷 記憶體佈局

### Stack vs Heap

```
Stack（堆疊）：
- 自動管理
- LIFO（後進先出）
- 大小有限（通常 1-8 MB）
- 存放：區域變數、函式參數、返回位址

Heap（堆積）：
- 手動管理（malloc/free）
- 大小較大（可達數 GB）
- 存放：動態分配的資料

記憶體佈局：
┌─────────────────┐ 高位址
│     Stack       │ ↓ 向下成長
├─────────────────┤
│       ↓         │
│                 │
│       ↑         │
├─────────────────┤
│     Heap        │ ↑ 向上成長
├─────────────────┤
│     BSS         │ 未初始化全域變數
├─────────────────┤
│     Data        │ 已初始化全域變數
├─────────────────┤
│     Text        │ 程式碼
└─────────────────┘ 低位址
```

### 變數的存放位置

```c
int global_init = 100;     // Data section
int global_uninit;         // BSS section
static int static_var = 5; // Data section

void func() {
    int local = 10;                    // Stack
    static int static_local = 20;      // Data section
    int *heap_ptr = (int*)malloc(4);   // 指標在 Stack，指向的資料在 Heap
    char *str = "Hello";               // 指標在 Stack，字串常量在 Text/Rodata
}
```

---

## 📝 面試高頻問題

**Q1：`int *p` 和 `int* p` 有什麼差別？**
```c
// 語意上沒有差別，都是指向 int 的指標
// 但風格不同

// 風格 1：* 靠近變數名
int *p, *q;  // p 和 q 都是指標

// 風格 2：* 靠近型別名
int* p, q;   // 只有 p 是指標，q 是 int！

// 建議：每行只宣告一個變數
int *p;
int *q;
```

**Q2：NULL 和 野指標？**
```c
// NULL 指標：明確指向「空」
int *p = NULL;
if (p == NULL) {
    // 可以安全檢查
}

// 野指標：未初始化，指向未知位址
int *q;  // q 的值是垃圾，指向未知位址
*q = 10; // 危險！可能造成 segfault 或記憶體損壞
```

**Q3：const 和指標**
```c
const int *p;       // 不能透過 p 修改值，但 p 可以指向別的地方
int * const p;      // p 不能指向別的地方，但可以透過 p 修改值
const int * const p;// 都不行

// 記憶方法：const 在 * 左邊 → 值不可改
//           const 在 * 右邊 → 指標不可改
```
```c
int x = 10, y = 20;

// 1. 指向常數的指標 (Pointer to Constant)
const int *p1 = &x; 
// *p1 = 20;      // ❌ 錯誤：不能透過 p1 修改值 (唯讀)
p1 = &y;          // ✅ 正確：p1 可以改指向別的位址

// 2. 常數指標 (Constant Pointer)
int * const p2 = &x;
*p2 = 20;         // ✅ 正確：可以修改 x 的值
// p2 = &y;       // ❌ 錯誤：p2 已經綁定位址，不能改指向 y

// 3. 指向常數的常數指標 (Constant Pointer to Constant)
const int * const p3 = &x;
// *p3 = 20;      // ❌ 錯誤
// p3 = &y;       // ❌ 錯誤

```
