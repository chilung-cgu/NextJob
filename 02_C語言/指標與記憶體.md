# ğŸ”§ æŒ‡æ¨™èˆ‡è¨˜æ†¶é«”é€²éšè©³è§£

> **å­¸ç¿’ç›®æ¨™**
> å®Œæˆæœ¬ç« å¾Œï¼Œä½ æ‡‰è©²èƒ½å¤ ï¼š
> 1. æ·±å…¥ç†è§£æŒ‡æ¨™çš„åº•å±¤é‹ä½œåŸç†èˆ‡è¨˜æ†¶é«”æ¨¡å‹
> 2. ç†Ÿç·´ä½¿ç”¨å¤šé‡æŒ‡æ¨™ã€å‡½å¼æŒ‡æ¨™ã€`restrict` é—œéµå­—
> 3. æŒæ¡è¨˜æ†¶é«”å°é½ŠåŸç†ï¼Œä¸¦èƒ½æ‰‹å¯« `aligned_malloc()` / `aligned_free()`
> 4. ç†è§£ ARM AAPCS Calling Convention èˆ‡ ABI æ¦‚å¿µ
> 5. åœ¨é¢è©¦ä¸­è‡ªä¿¡åœ°å›ç­” NVIDIA/Google ç´šåˆ¥çš„æŒ‡æ¨™èˆ‡è¨˜æ†¶é«”å•é¡Œ

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šæŒ‡æ¨™åŸºç¤èˆ‡é€²éš

### 1.1 ä»€éº¼æ˜¯æŒ‡æ¨™ï¼Ÿ

æŒ‡æ¨™æ˜¯ C èªè¨€çš„éˆé­‚ï¼Œä¹Ÿæ˜¯é¢è©¦å¿…è€ƒçš„æ ¸å¿ƒã€‚

```c
// æŒ‡æ¨™æ˜¯å„²å­˜ã€Œè¨˜æ†¶é«”ä½å€ã€çš„è®Šæ•¸

int a = 10;        // a æ˜¯ä¸€å€‹ intï¼Œå€¼æ˜¯ 10
int *p = &a;       // p æ˜¯æŒ‡æ¨™ï¼Œå„²å­˜ a çš„ä½å€

printf("a çš„å€¼: %d\n", a);      // 10
printf("a çš„ä½å€: %p\n", &a);   // å¦‚ 0x7ffd12345678
printf("p çš„å€¼: %p\n", p);      // åŒä¸Šï¼Œp å„²å­˜ a çš„ä½å€
printf("p æŒ‡å‘çš„å€¼: %d\n", *p); // 10ï¼Œé€é p å–å¾— a çš„å€¼
```

### 1.2 è¨˜æ†¶é«”è¦–è¦ºåŒ–

ç†è§£æŒ‡æ¨™çš„é—œéµåœ¨æ–¼ç†è§£è¨˜æ†¶é«”ä½ˆå±€ï¼š

| è¨˜æ†¶é«”ä½å€ | å…§å®¹ | è®Šæ•¸ / èªªæ˜ |
| :--- | :--- | :--- |
| 0x1000 ~ 0x1003 | 10 | `int a` (ä½” 4 bytes) |
| 0x1004 ~ 0x1007 | [Padding] | è¨˜æ†¶é«”å¡«å…… (4 bytesï¼Œç¢ºä¿ 8-byte å°é½Š) |
| 0x1008 ~ 0x100F | 0x1000 | `int *p` (åœ¨ 64-bit ç³»çµ±ä½” 8 bytesï¼Œå„²å­˜ `a` çš„ä½å€) |

### 1.3 æŒ‡æ¨™çš„å¤§å°

```c
// æŒ‡æ¨™å¤§å°å–æ±ºæ–¼ç³»çµ±ä½å…ƒæ•¸ï¼Œèˆ‡æŒ‡å‘çš„å‹åˆ¥ç„¡é—œ

// åœ¨ 64-bit ç³»çµ±ï¼š
sizeof(char *)   == 8  // 8 bytes
sizeof(int *)    == 8  // 8 bytes
sizeof(double *) == 8  // 8 bytes
sizeof(void *)   == 8  // 8 bytes

// åœ¨ 32-bit ç³»çµ±ï¼š
sizeof(char *)   == 4  // 4 bytes
sizeof(int *)    == 4  // 4 bytes
```

**é¢è©¦é™·é˜±é¡Œ**ï¼š`sizeof(int *)` å’Œ `sizeof(int)` ä¸€æ¨£å—ï¼Ÿ

ç­”ï¼šä¸ä¸€å®šï¼åœ¨ 64-bit ç³»çµ±ä¸Šï¼Œ`int` æ˜¯ 4 bytesï¼Œä½† `int *` æ˜¯ 8 bytesã€‚

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šæŒ‡æ¨™é‹ç®— (Pointer Arithmetic)

### 2.1 æŒ‡æ¨™ç®—è¡“åŸºç¤

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // p æŒ‡å‘ arr[0]

// æŒ‡æ¨™ +1 æœƒç§»å‹•ã€Œä¸€å€‹å…ƒç´ çš„å¤§å°ã€ï¼ˆint = 4 bytesï¼‰
// é€™æ˜¯ C èªè¨€è‡ªå‹•è™•ç†çš„ï¼ä½ ä¸éœ€è¦æ‰‹å‹• +4
printf("*p = %d\n", *p);         // 10
printf("*(p+1) = %d\n", *(p+1)); // 20
printf("*(p+2) = %d\n", *(p+2)); // 30

// å¯¦éš›è¨˜æ†¶é«”ä½å€
printf("p     = %p\n", p);       // 0x1000
printf("p + 1 = %p\n", p + 1);   // 0x1004 (å¢åŠ  4 bytes)
printf("p + 2 = %p\n", p + 2);   // 0x1008 (å¢åŠ  8 bytes)
```

### 2.2 æ·±å…¥ç†è§£ï¼šæŒ‡æ¨™ç®—è¡“çš„åº•å±¤

```c
// ç•¶ä½ å¯« p + nï¼Œç·¨è­¯å™¨å¯¦éš›åŸ·è¡Œçš„æ˜¯ï¼š
// (char *)p + n * sizeof(*p)

int *p = (int *)0x1000;

p + 1;  // ç·¨è­¯å™¨è¨ˆç®—ï¼š0x1000 + 1 * 4 = 0x1004
p + 2;  // ç·¨è­¯å™¨è¨ˆç®—ï¼š0x1000 + 2 * 4 = 0x1008

// ä¸åŒå‹åˆ¥æŒ‡æ¨™çš„å·®ç•°ï¼š
char *pc = (char *)0x1000;
int *pi = (int *)0x1000;
double *pd = (double *)0x1000;

pc + 1;  // 0x1001 (+1 byte)
pi + 1;  // 0x1004 (+4 bytes)
pd + 1;  // 0x1008 (+8 bytes)
```

### 2.3 æŒ‡æ¨™ç›¸æ¸›

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];  // æŒ‡å‘ arr[1]
int *p2 = &arr[4];  // æŒ‡å‘ arr[4]

// æŒ‡æ¨™ç›¸æ¸›å¾—åˆ°ã€Œå…ƒç´ å€‹æ•¸ã€ï¼Œä¸æ˜¯ bytesï¼
// ptrdiff_t æ˜¯å®šç¾©åœ¨ <stddef.h> çš„å¸¶æ­£è² è™Ÿæ•´æ•¸å‹åˆ¥
ptrdiff_t diff = p2 - p1;
printf("diff = %td\n", diff);  // 3 (ä¸æ˜¯ 12 bytesï¼)

// åº•å±¤è¨ˆç®—ï¼š
// (p2 - p1) / sizeof(int) = (0x1010 - 0x1004) / 4 = 12 / 4 = 3
```

### 2.4 æŒ‡æ¨™æ¯”è¼ƒ

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];
int *p2 = &arr[3];

// å¯ä»¥æ¯”è¼ƒæŒ‡å‘åŒä¸€é™£åˆ—çš„æŒ‡æ¨™
if (p1 < p2) {
    printf("p1 åœ¨ p2 å‰é¢\n");  // æœƒå°å‡º
}

// âš ï¸ æ³¨æ„ï¼šæ¯”è¼ƒä¸åŒé™£åˆ—çš„æŒ‡æ¨™æ˜¯ã€Œæœªå®šç¾©è¡Œç‚ºã€
int arr2[5];
int *p3 = arr2;
// if (p1 < p3) {} // æœªå®šç¾©è¡Œç‚ºï¼
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¤šé‡æŒ‡æ¨™ (Pointer to Pointer)

### 3.1 äºŒé‡æŒ‡æ¨™åŸºç¤

```c
int a = 10;
int *p = &a;      // p æ˜¯æŒ‡å‘ int çš„æŒ‡æ¨™
int **pp = &p;    // pp æ˜¯æŒ‡å‘ã€ŒæŒ‡å‘ int çš„æŒ‡æ¨™ã€çš„æŒ‡æ¨™

printf("a = %d\n", a);       // 10
printf("*p = %d\n", *p);     // 10
printf("**pp = %d\n", **pp); // 10

// è¨˜æ†¶é«”è¦–è¦ºåŒ–ï¼ˆ64-bit ç³»çµ±ï¼‰ï¼š
//
// a:  [     10     ]     ä½å€ 0x1000 (4 bytes)
// p:  [   0x1000   ]     ä½å€ 0x1008 (8 bytes, å„²å­˜ a çš„ä½å€)
// pp: [   0x1008   ]     ä½å€ 0x1010 (8 bytes, å„²å­˜ p çš„ä½å€)
//
// **pp çš„è§£æéç¨‹ï¼š
// 1. *pp  = å–å¾— pp æŒ‡å‘çš„å€¼ = 0x1008 (å°±æ˜¯ p)
// 2. **pp = å†å–ä¸€æ¬¡ = å–å¾— 0x1008 æŒ‡å‘çš„å€¼ = 10
```

### 3.2 äºŒé‡æŒ‡æ¨™çš„ç”¨é€”ä¸€ï¼šåœ¨å‡½å¼ä¸­ä¿®æ”¹æŒ‡æ¨™æœ¬èº«

é€™æ˜¯æœ€å¸¸è¦‹çš„ç”¨é€”ï¼Œä¹Ÿæ˜¯é¢è©¦å¿…è€ƒï¼

```c
// ç¶“å…¸éŒ¯èª¤ç¤ºç¯„ï¼šè©¦åœ–åœ¨å‡½å¼ä¸­åˆ†é…è¨˜æ†¶é«”
void allocate_wrong(int *p) {
    p = (int*)malloc(sizeof(int));  // p æ˜¯å‰¯æœ¬ï¼
    *p = 100;
}

int main() {
    int *ptr = NULL;
    allocate_wrong(ptr);
    printf("*ptr = %d\n", *ptr);  // ğŸ’¥ Segfaultï¼ptr é‚„æ˜¯ NULL
    return 0;
}

// âœ… æ­£ç¢ºåšæ³•ï¼šä½¿ç”¨äºŒé‡æŒ‡æ¨™
void allocate_correct(int **pp) {
    *pp = (int*)malloc(sizeof(int));  // ä¿®æ”¹å¤–éƒ¨æŒ‡æ¨™çš„å€¼
    **pp = 100;                        // ä¿®æ”¹è©²ä½å€å„²å­˜çš„æ•¸å€¼
}

int main() {
    int *ptr = NULL;
    allocate_correct(&ptr);  // å‚³å…¥ã€ŒæŒ‡æ¨™ ptr çš„ä½å€ã€
    printf("*ptr = %d\n", *ptr);  // 100 âœ“
    free(ptr);
    return 0;
}
```

**ç‚ºä»€éº¼éœ€è¦äºŒé‡æŒ‡æ¨™ï¼Ÿ**

C èªè¨€åªæœ‰ã€Œå‚³å€¼ã€(Pass by Value)ã€‚ç•¶ä½ å‚³å…¥ `int *p`ï¼Œå‡½å¼å…§åªæœƒå¾—åˆ° `p` çš„**å‰¯æœ¬**ã€‚
ä¿®æ”¹å‰¯æœ¬ä¸æœƒå½±éŸ¿å¤–éƒ¨çš„ `p`ã€‚å› æ­¤å¿…é ˆå‚³å…¥ã€ŒæŒ‡æ¨™çš„ä½å€ã€ï¼Œä¹Ÿå°±æ˜¯ `int **pp`ã€‚

### 3.3 äºŒé‡æŒ‡æ¨™çš„ç”¨é€”äºŒï¼šå‹•æ…‹äºŒç¶­é™£åˆ—

```c
// åˆ†é… 3x4 çš„äºŒç¶­é™£åˆ—
int rows = 3, cols = 4;

// æ–¹æ³• 1ï¼šæŒ‡æ¨™é™£åˆ— (Jagged Array)
int **matrix = (int**)malloc(rows * sizeof(int*));
for (int i = 0; i < rows; i++) {
    matrix[i] = (int*)malloc(cols * sizeof(int));
}

// ä½¿ç”¨
matrix[1][2] = 42;

// é‡‹æ”¾ï¼ˆé †åºé‡è¦ï¼å…ˆé‡‹æ”¾å…§å±¤ï¼‰
for (int i = 0; i < rows; i++) {
    free(matrix[i]);
}
free(matrix);
```

### 3.4 äºŒé‡æŒ‡æ¨™çš„ç”¨é€”ä¸‰ï¼šå­—ä¸²é™£åˆ—

```c
// å­—ä¸²é™£åˆ—æœ¬è³ªä¸Šå°±æ˜¯äºŒé‡æŒ‡æ¨™
char *names[] = {"Alice", "Bob", "Charlie"};
char **pp = names;

printf("%s\n", *pp);       // Alice
printf("%s\n", *(pp + 1)); // Bob
printf("%c\n", **pp);      // 'A' (ç¬¬ä¸€å€‹å­—ä¸²çš„ç¬¬ä¸€å€‹å­—å…ƒ)
printf("%c\n", *(*pp + 1)); // 'l' (ç¬¬ä¸€å€‹å­—ä¸²çš„ç¬¬äºŒå€‹å­—å…ƒ)
```

### 3.5 ä¸‰é‡æŒ‡æ¨™

é›–ç„¶è¼ƒå°‘è¦‹ï¼Œä½†åœ¨ç‰¹å®šå ´æ™¯ï¼ˆå¦‚å‹•æ…‹åˆ†é…äºŒç¶­æŒ‡æ¨™é™£åˆ—ï¼‰æœƒç”¨åˆ°ï¼š

```c
int ***ppp;

// å¯¦éš›æ‡‰ç”¨ï¼šåœ¨å‡½å¼ä¸­åˆ†é…äºŒç¶­é™£åˆ—
void alloc_2d_array(int ***arr, int rows, int cols) {
    *arr = (int**)malloc(rows * sizeof(int*));
    for (int i = 0; i < rows; i++) {
        (*arr)[i] = (int*)malloc(cols * sizeof(int));
    }
}

int main() {
    int **matrix;
    alloc_2d_array(&matrix, 3, 4);
    matrix[1][2] = 42;
    // ... free logic
}
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šæŒ‡æ¨™èˆ‡é™£åˆ—çš„æ·±åº¦è§£æ

### 4.1 é™£åˆ—åæ˜¯ã€Œå¸¸æ•¸æŒ‡æ¨™ã€å—ï¼Ÿ

é€™æ˜¯å€‹å¸¸è¦‹çš„èª¤è§£ã€‚æ›´ç²¾ç¢ºåœ°èªªï¼š

```c
int arr[5] = {10, 20, 30, 40, 50};

// arr æ˜¯ã€Œé™£åˆ—ã€ï¼Œä½†åœ¨å¤§å¤šæ•¸è¡¨é”å¼ä¸­æœƒã€Œé€€åŒ–ã€(decay) æˆæŒ‡æ¨™
int *p = arr;  // arr é€€åŒ–æˆæŒ‡å‘ç¬¬ä¸€å€‹å…ƒç´ çš„æŒ‡æ¨™

// ä¾‹å¤–æƒ…æ³ï¼ˆarr ä¸æœƒé€€åŒ–ï¼‰ï¼š
sizeof(arr);    // å›å‚³æ•´å€‹é™£åˆ—å¤§å° = 20
&arr;          // å›å‚³æŒ‡å‘æ•´å€‹é™£åˆ—çš„æŒ‡æ¨™ï¼Œå‹åˆ¥æ˜¯ int (*)[5]
```

### 4.2 `arr` å’Œ `&arr` çš„å€åˆ¥

é€™æ˜¯é€²éšé¢è©¦é¡Œï¼

```c
int arr[5] = {10, 20, 30, 40, 50};

printf("arr     = %p\n", arr);      // 0x1000
printf("&arr    = %p\n", &arr);     // 0x1000 (æ•¸å€¼ç›¸åŒï¼)
printf("arr + 1 = %p\n", arr + 1);  // 0x1004 (ç§»å‹• 4 bytes)
printf("&arr + 1= %p\n", &arr + 1); // 0x1014 (ç§»å‹• 20 bytesï¼)

// è§£é‡‹ï¼š
// arr çš„å‹åˆ¥æ˜¯ int* (é€€åŒ–å¾Œ)ï¼Œ+1 ç§»å‹• sizeof(int) = 4 bytes
// &arr çš„å‹åˆ¥æ˜¯ int (*)[5]ï¼Œ+1 ç§»å‹• sizeof(int[5]) = 20 bytes
```

### 4.3 é™£åˆ—å‚³å…¥å‡½å¼

```c
// ç•¶é™£åˆ—å‚³å…¥å‡½å¼ï¼Œæœƒé€€åŒ–æˆæŒ‡æ¨™
void printArray(int *arr, int size) {
    // åœ¨å‡½å¼å…§ï¼Œsizeof(arr) åªæœƒå¾—åˆ°æŒ‡æ¨™å¤§å°ï¼
    printf("sizeof(arr) in func = %zu\n", sizeof(arr));  // 8 (64-bit)
    
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printf("sizeof(arr) in main = %zu\n", sizeof(arr));  // 20
    printArray(arr, 5);
}
```

### 4.4 äºŒç¶­é™£åˆ—èˆ‡æŒ‡æ¨™

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// arr çš„å‹åˆ¥æ˜¯ int (*)[4]ï¼ˆæŒ‡å‘ã€Œå« 4 å€‹ int çš„é™£åˆ—ã€çš„æŒ‡æ¨™ï¼‰
int (*p)[4] = arr;

// å­˜å–æ–¹å¼ï¼š
printf("arr[1][2] = %d\n", arr[1][2]);       // 7
printf("*(*(p+1)+2) = %d\n", *(*(p+1)+2));   // 7
printf("p[1][2] = %d\n", p[1][2]);           // 7

// è¨˜æ†¶é«”ä½ˆå±€ï¼ˆé€£çºŒçš„ï¼‰ï¼š
// 1 2 3 4 | 5 6 7 8 | 9 10 11 12
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šå‡½å¼æŒ‡æ¨™ (Function Pointer)

### 5.1 åŸºæœ¬ä½¿ç”¨

```c
// å‡½å¼æŒ‡æ¨™ï¼šå„²å­˜å‡½å¼çš„ä½å€

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    // å®£å‘Šå‡½å¼æŒ‡æ¨™
    // int (*fp)(int, int) è®€ä½œï¼š
    // fp æ˜¯ä¸€å€‹æŒ‡æ¨™ï¼ŒæŒ‡å‘ã€Œæ¥å—å…©å€‹ int åƒæ•¸ä¸¦å›å‚³ intã€çš„å‡½å¼
    int (*fp)(int, int);
    
    fp = add;  // æŒ‡å‘ add å‡½å¼ï¼ˆä¹Ÿå¯å¯«æˆ fp = &addï¼‰
    printf("%d\n", fp(3, 4));  // 7
    
    fp = sub;  // æŒ‡å‘ sub å‡½å¼
    printf("%d\n", fp(3, 4));  // -1
    
    return 0;
}
```

### 5.2 ä½¿ç”¨ typedef ç°¡åŒ–

```c
// å®šç¾©å‡½å¼æŒ‡æ¨™å‹åˆ¥
typedef int (*operation_t)(int, int);

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    operation_t op = add;  // æ›´æ˜“è®€ï¼
    printf("%d\n", op(10, 3));  // 13
    
    op = sub;
    printf("%d\n", op(10, 3));  // 7
}
```

### 5.3 Callback å‡½å¼

Callback æ˜¯åµŒå…¥å¼é–‹ç™¼ä¸­éå¸¸é‡è¦çš„è¨­è¨ˆæ¨¡å¼ï¼š

```c
// Callback (å›å‘¼) çš„æ ¸å¿ƒæ¦‚å¿µï¼š
// å°‡å‡½å¼æŒ‡æ¨™ä½œç‚ºåƒæ•¸å‚³å…¥å¦ä¸€å€‹å‡½å¼ï¼Œå¯¦ç¾ã€Œé‚è¼¯è§£è€¦ã€

// å®šç¾© callback å‹åˆ¥
typedef void (*event_handler_t)(int event_code);

// è¨»å†Š callback çš„å‡½å¼
void register_handler(event_handler_t handler) {
    // æ¨¡æ“¬äº‹ä»¶ç™¼ç”Ÿ
    handler(42);  // å‘¼å«ä½¿ç”¨è€…æä¾›çš„å‡½å¼
}

// ä½¿ç”¨è€…å®šç¾©çš„ callback å‡½å¼
void my_handler(int code) {
    printf("æ”¶åˆ°äº‹ä»¶: %d\n", code);
}

int main() {
    register_handler(my_handler);  // å‚³å…¥å‡½å¼æŒ‡æ¨™
    return 0;
}
```

### 5.4 å‡½å¼æŒ‡æ¨™é™£åˆ—

```c
// è¨ˆç®—æ©Ÿç¯„ä¾‹ - ç”¨å‡½å¼æŒ‡æ¨™é™£åˆ—å–ä»£ switch-case

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int divide(int a, int b) { return b ? a / b : 0; }

typedef int (*operation_t)(int, int);

int main() {
    // å‡½å¼æŒ‡æ¨™é™£åˆ—
    operation_t ops[4] = {add, sub, mul, divide};
    const char *names[] = {"add", "sub", "mul", "div"};
    
    int a = 10, b = 3;
    for (int i = 0; i < 4; i++) {
        printf("%s(%d, %d) = %d\n", names[i], a, b, ops[i](a, b));
    }
    
    return 0;
}

// è¼¸å‡ºï¼š
// add(10, 3) = 13
// sub(10, 3) = 7
// mul(10, 3) = 30
// div(10, 3) = 3
```

### 5.5 å›å‚³å‡½å¼æŒ‡æ¨™çš„å‡½å¼

é€™æ˜¯é€²éšç”¨æ³•ï¼Œåœ¨ç‹€æ…‹æ©Ÿè¨­è¨ˆä¸­å¾ˆå¸¸è¦‹ï¼š

```c
typedef void (*state_handler_t)(void);

void state_idle(void) { printf("Idle state\n"); }
void state_running(void) { printf("Running state\n"); }
void state_error(void) { printf("Error state\n"); }

// å›å‚³å‡½å¼æŒ‡æ¨™çš„å‡½å¼
state_handler_t get_handler(int state) {
    switch (state) {
        case 0: return state_idle;
        case 1: return state_running;
        default: return state_error;
    }
}

int main() {
    state_handler_t handler = get_handler(1);
    handler();  // Running state
    return 0;
}
```

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šrestrict é—œéµå­—

### 6.1 ä»€éº¼æ˜¯ restrictï¼Ÿ

`restrict` æ˜¯ C99 å¼•å…¥çš„é—œéµå­—ï¼Œå‘Šè¨´ç·¨è­¯å™¨ï¼šã€Œé€™å€‹æŒ‡æ¨™æ˜¯å­˜å–è©²è¨˜æ†¶é«”çš„**å”¯ä¸€é€”å¾‘**ã€ã€‚

```c
// æ²’æœ‰ restrictï¼šç·¨è­¯å™¨å¿…é ˆå‡è¨­ a å’Œ b å¯èƒ½æŒ‡å‘åŒä¸€å¡Šè¨˜æ†¶é«”
void copy_slow(int *a, int *b, int n) {
    for (int i = 0; i < n; i++) {
        a[i] = b[i];  // ç·¨è­¯å™¨ç„¡æ³•å„ªåŒ–ï¼Œå› ç‚º a[i] å¯èƒ½å½±éŸ¿ b[j]
    }
}

// æœ‰ restrictï¼šç·¨è­¯å™¨å¯ä»¥å¤§è†½å„ªåŒ–
void copy_fast(int * restrict a, int * restrict b, int n) {
    for (int i = 0; i < n; i++) {
        a[i] = b[i];  // ç·¨è­¯å™¨çŸ¥é“ a å’Œ b ä¸é‡ç–Šï¼Œå¯ä»¥å‘é‡åŒ–
    }
}
```

### 6.2 ç‚ºä»€éº¼éœ€è¦ restrictï¼Ÿ

è€ƒæ…®é€™å€‹ä¾‹å­ï¼š

```c
void update(int *a, int *b) {
    *a = 5;
    *b = 6;
    printf("%d\n", *a);  // è¼¸å‡ºä»€éº¼ï¼Ÿ
}

int x = 0;
update(&x, &x);  // a å’Œ b æŒ‡å‘åŒä¸€å€‹ xï¼
// è¼¸å‡º 6ï¼Œä¸æ˜¯ 5ï¼

// å¦‚æœä½¿ç”¨ restrictï¼Œç¨‹å¼å“¡ä¿è­‰ä¸æœƒé€™æ¨£å‘¼å«
void update_fast(int * restrict a, int * restrict b) {
    *a = 5;
    *b = 6;
    printf("%d\n", *a);  // ç·¨è­¯å™¨å¯ä»¥å„ªåŒ–ç‚ºç›´æ¥å° 5
}
```

### 6.3 restrict åœ¨æ¨™æº–åº«ä¸­çš„æ‡‰ç”¨

```c
// memcpy ä½¿ç”¨ restrictï¼ˆä¾†æºå’Œç›®çš„ä¸å¯é‡ç–Šï¼‰
void *memcpy(void * restrict dest, const void * restrict src, size_t n);

// memmove ä¸ä½¿ç”¨ restrictï¼ˆå…è¨±é‡ç–Šï¼‰
void *memmove(void *dest, const void *src, size_t n);

// é€™å°±æ˜¯ç‚ºä»€éº¼ memcpy æ¯” memmove å¿«ï¼
```

### 6.4 ä½¿ç”¨ restrict çš„æ³¨æ„äº‹é …

```c
// âš ï¸ é•å restrict ç´„å®šæ˜¯æœªå®šç¾©è¡Œç‚º
void bad_usage(void) {
    int arr[10] = {0};
    int * restrict p1 = arr;
    int * restrict p2 = arr;  // éŒ¯èª¤ï¼å…©å€‹ restrict æŒ‡æ¨™æŒ‡å‘åŒä¸€å¡Šè¨˜æ†¶é«”
    
    *p1 = 1;
    *p2 = 2;  // æœªå®šç¾©è¡Œç‚ºï¼
}
```

---

## ğŸ”· ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå‹•æ…‹è¨˜æ†¶é«”ç®¡ç†

### 7.1 malloc / calloc / realloc / free

```c
#include <stdlib.h>

// mallocï¼šåˆ†é…æœªåˆå§‹åŒ–çš„è¨˜æ†¶é«”
int *p1 = (int*)malloc(10 * sizeof(int));
// å…§å®¹æ˜¯ã€Œåƒåœ¾å€¼ã€ï¼ˆæœªåˆå§‹åŒ–ï¼‰
// åœ¨ C++ ä¸­å¿…é ˆå¼·åˆ¶è½‰å‹ï¼ŒC ä¸­å¯é¸ï¼ˆvoid* è‡ªå‹•è½‰æ›ï¼‰

// callocï¼šåˆ†é…ä¸¦åˆå§‹åŒ–ç‚ºå…¨ 0
int *p2 = (int*)calloc(10, sizeof(int));
// æ‰€æœ‰ bytes éƒ½æ˜¯ 0

// reallocï¼šé‡æ–°åˆ†é…å¤§å°
p1 = (int*)realloc(p1, 20 * sizeof(int));
// å¯èƒ½åŸåœ°æ“´å±•ï¼Œä¹Ÿå¯èƒ½æ¬åˆ°æ–°ä½ç½®

// freeï¼šé‡‹æ”¾è¨˜æ†¶é«”
free(p1);
free(p2);

// âš ï¸ æœ€ä½³å¯¦è¸ï¼šfree å¾Œå°‡æŒ‡æ¨™è¨­ç‚º NULL
p1 = NULL;
p2 = NULL;
```

### 7.2 realloc çš„ç´°ç¯€

```c
// realloc æœ‰å¤šç¨®æƒ…æ³ï¼š

// æƒ…æ³ 1ï¼šåŸåœ°æ“´å±•ï¼ˆæœ‰è¶³å¤ ç©ºé–“ï¼‰
int *p = malloc(10 * sizeof(int));
p = realloc(p, 20 * sizeof(int));  // p çš„ä½å€å¯èƒ½ä¸è®Š

// æƒ…æ³ 2ï¼šæ¬åˆ°æ–°ä½ç½®
// å¦‚æœåŸä½ç½®æ²’æœ‰è¶³å¤ ç©ºé–“ï¼Œrealloc æœƒï¼š
// 1. åœ¨æ–°ä½ç½®åˆ†é…æ›´å¤§çš„ç©ºé–“
// 2. è¤‡è£½èˆŠè³‡æ–™åˆ°æ–°ä½ç½®
// 3. é‡‹æ”¾èˆŠä½ç½®
// 4. å›å‚³æ–°ä½å€

// æƒ…æ³ 3ï¼šå¤±æ•—å›å‚³ NULL
// âš ï¸ å¸¸è¦‹éŒ¯èª¤ï¼
int *p = malloc(10 * sizeof(int));
p = realloc(p, HUGE_SIZE);  // å¦‚æœå¤±æ•—ï¼Œp = NULLï¼ŒåŸæœ¬çš„è¨˜æ†¶é«”æ´©æ¼ï¼

// âœ… æ­£ç¢ºå¯«æ³•
int *p = malloc(10 * sizeof(int));
int *new_p = realloc(p, HUGE_SIZE);
if (new_p != NULL) {
    p = new_p;
} else {
    // è™•ç†å¤±æ•—ï¼Œp ä»ç„¶æœ‰æ•ˆ
}

// æƒ…æ³ 4ï¼šrealloc(p, 0) ç­‰åŒæ–¼ free(p)ï¼ˆä½†ä¸å»ºè­°é€™æ¨£ç”¨ï¼‰
```

### 7.3 å¸¸è¦‹è¨˜æ†¶é«”éŒ¯èª¤

```c
// éŒ¯èª¤ 1ï¼šMemory Leakï¼ˆè¨˜æ†¶é«”æ´©æ¼ï¼‰
void memory_leak() {
    int *p = (int*)malloc(10 * sizeof(int));
    // æ²’æœ‰ free(p) å°± return äº†ï¼
    // é€™å¡Šè¨˜æ†¶é«”æ°¸é ç„¡æ³•é‡‹æ”¾
}

// éŒ¯èª¤ 2ï¼šUse After Free
void use_after_free() {
    int *p = malloc(sizeof(int));
    *p = 10;
    free(p);
    *p = 20;  // ğŸ’¥ æœªå®šç¾©è¡Œç‚ºï¼
}

// éŒ¯èª¤ 3ï¼šDouble Freeï¼ˆé‡è¤‡é‡‹æ”¾ï¼‰
void double_free() {
    int *p = malloc(sizeof(int));
    free(p);
    free(p);  // ğŸ’¥ åš´é‡éŒ¯èª¤ï¼å¯èƒ½å°è‡´å®‰å…¨æ¼æ´
}
// å±å®³ï¼š
// 1. Heap Corruptionï¼šç ´å£è¨˜æ†¶é«”ç®¡ç†å™¨çš„å…§éƒ¨çµæ§‹
// 2. å®‰å…¨æ¼æ´ï¼šæ”»æ“Šè€…å¯èƒ½åˆ©ç”¨æ­¤æ¼æ´åŸ·è¡Œä»»æ„ç¨‹å¼ç¢¼

// éŒ¯èª¤ 4ï¼šé‡æŒ‡æ¨™ï¼ˆæœªåˆå§‹åŒ–çš„æŒ‡æ¨™ï¼‰
void wild_pointer() {
    int *p;      // p çš„å€¼æ˜¯åƒåœ¾
    *p = 10;     // ğŸ’¥ å¯«å…¥æœªçŸ¥ä½å€
}

// éŒ¯èª¤ 5ï¼šBuffer Overflow
void buffer_overflow() {
    int *p = malloc(5 * sizeof(int));  // åˆ†é… 5 å€‹ int
    p[10] = 100;  // ğŸ’¥ è¶Šç•Œå¯«å…¥ï¼
    free(p);
}
```

---

## ğŸ”· ç¬¬å…«éƒ¨åˆ†ï¼šè¨˜æ†¶é«”å°é½Š (Memory Alignment)

### 8.1 ä»€éº¼æ˜¯è¨˜æ†¶é«”å°é½Šï¼Ÿ

```c
// ç¾ä»£ CPU è¦æ±‚è³‡æ–™åœ¨ã€Œå°é½Šã€çš„ä½å€ä¸Šæ‰èƒ½é«˜æ•ˆå­˜å–
// ä¾‹å¦‚ï¼š4-byte çš„ int æ‡‰è©²æ”¾åœ¨ 4 çš„å€æ•¸ä½å€

// æœªå°é½Šçš„å­˜å–ï¼š
// - æŸäº›æ¶æ§‹ï¼ˆå¦‚ ARM7ï¼‰æœƒç›´æ¥ crash
// - å…¶ä»–æ¶æ§‹å¯èƒ½éœ€è¦å¤šæ¬¡è¨˜æ†¶é«”å­˜å–ï¼Œæ•ˆèƒ½ä¸‹é™

// å°é½Šè¦å‰‡ï¼š
// - char:   1-byte å°é½Šï¼ˆä»»ä½•ä½å€éƒ½å¯ä»¥ï¼‰
// - short:  2-byte å°é½Š
// - int:    4-byte å°é½Š
// - double: 8-byte å°é½Š
// - pointer: 4 æˆ– 8-byte å°é½Šï¼ˆå–æ±ºæ–¼ç³»çµ±ï¼‰
```

### 8.2 Struct Padding

```c
// ç·¨è­¯å™¨æœƒè‡ªå‹•æ’å…¥ padding ä»¥æ»¿è¶³å°é½Šè¦æ±‚

struct BadLayout {
    char a;     // 1 byte
                // 3 bytes paddingï¼ˆç‚ºäº†è®“ b å°é½Šåˆ° 4 çš„å€æ•¸ï¼‰
    int b;      // 4 bytes
    char c;     // 1 byte
                // 3 bytes paddingï¼ˆçµæ§‹é«”å¤§å°å¿…é ˆæ˜¯æœ€å¤§æˆå“¡å°é½Šçš„å€æ•¸ï¼‰
};  // ç¸½å…± 12 bytes

struct GoodLayout {
    int b;      // 4 bytes
    char a;     // 1 byte
    char c;     // 1 byte
                // 2 bytes padding
};  // ç¸½å…± 8 bytes

printf("sizeof(BadLayout) = %zu\n", sizeof(struct BadLayout));   // 12
printf("sizeof(GoodLayout) = %zu\n", sizeof(struct GoodLayout)); // 8
```

### 8.3 `__attribute__((aligned))` å’Œ `__attribute__((packed))`

```c
// GCC æ“´å±•ï¼šå¼·åˆ¶ç‰¹å®šå°é½Š

// alignedï¼šå¢åŠ å°é½Šè¦æ±‚
struct AlignedStruct {
    char data[3];
} __attribute__((aligned(16)));  // å¼·åˆ¶ 16-byte å°é½Š

printf("sizeof = %zu\n", sizeof(struct AlignedStruct));  // 16

// packedï¼šå–æ¶ˆ padding
struct PackedStruct {
    char a;     // 1 byte
    int b;      // 4 bytes
    char c;     // 1 byte
} __attribute__((packed));

printf("sizeof = %zu\n", sizeof(struct PackedStruct));  // 6ï¼ˆç„¡ paddingï¼‰

// âš ï¸ æ³¨æ„ï¼špacked å¯èƒ½å°è‡´æœªå°é½Šå­˜å–ï¼Œæ•ˆèƒ½ä¸‹é™æˆ–åœ¨æŸäº›å¹³å° crash
```

### 8.4 C11 alignas å’Œ alignof

```c
#include <stdalign.h>

// æŸ¥è©¢å‹åˆ¥çš„å°é½Šè¦æ±‚
printf("alignof(int) = %zu\n", alignof(int));        // 4
printf("alignof(double) = %zu\n", alignof(double));  // 8

// æŒ‡å®šè®Šæ•¸å°é½Š
alignas(16) int arr[4];  // arr å¿…é ˆæ”¾åœ¨ 16-byte å°é½Šçš„ä½å€
```

---

## ğŸ”· ç¬¬ä¹éƒ¨åˆ†ï¼šæ‰‹å¯« aligned_malloc / aligned_free

é€™æ˜¯ **NVIDIA/Google ç´šåˆ¥çš„ç¶“å…¸é¢è©¦é¡Œ**ï¼

### 9.1 å•é¡Œæè¿°

å¯¦ä½œ `aligned_malloc(size_t size, size_t alignment)` å’Œ `aligned_free(void *ptr)`ï¼š
- å›å‚³çš„æŒ‡æ¨™å¿…é ˆæ˜¯ `alignment` çš„å€æ•¸
- `alignment` å¿…é ˆæ˜¯ 2 çš„å†ªæ¬¡

### 9.2 å®Œæ•´å¯¦ä½œ

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/**
 * aligned_malloc - åˆ†é…å°é½Šçš„è¨˜æ†¶é«”
 * @size:      éœ€è¦çš„è¨˜æ†¶é«”å¤§å°
 * @alignment: å°é½Šè¦æ±‚ï¼ˆå¿…é ˆæ˜¯ 2 çš„å†ªæ¬¡ï¼‰
 *
 * æ¼”ç®—æ³•ï¼š
 * 1. å¤šåˆ†é… (alignment - 1) + sizeof(void*) çš„ç©ºé–“
 * 2. å°‡å¯¦éš›ä½å€å°é½Šåˆ° alignment çš„å€æ•¸
 * 3. åœ¨å°é½Šä½å€å‰é¢å„²å­˜åŸå§‹ä½å€ï¼ˆç”¨æ–¼ freeï¼‰
 *
 * è¨˜æ†¶é«”ä½ˆå±€ï¼š
 * |-- sizeof(void*) --|-- padding --|-- aligned user data --|
 * ^                   ^             ^
 * raw_ptr             stored_ptr    returned_ptr
 */
void *aligned_malloc(size_t size, size_t alignment) {
    // åƒæ•¸æª¢æŸ¥
    if (size == 0 || alignment == 0) return NULL;
    if ((alignment & (alignment - 1)) != 0) return NULL;  // ç¢ºä¿æ˜¯ 2 çš„å†ªæ¬¡
    
    // éœ€è¦é¡å¤–ç©ºé–“ï¼šalignment - 1ï¼ˆå°é½Šç”¨ï¼‰+ sizeof(void*)ï¼ˆå„²å­˜åŸå§‹æŒ‡æ¨™ï¼‰
    size_t extra = alignment - 1 + sizeof(void*);
    
    // åˆ†é…è¨˜æ†¶é«”
    void *raw_ptr = malloc(size + extra);
    if (raw_ptr == NULL) return NULL;
    
    // è¨ˆç®—å°é½Šå¾Œçš„ä½å€
    // æŠ€å·§ï¼š(ptr + alignment - 1) & ~(alignment - 1) å‘ä¸Šå°é½Šåˆ° alignment
    uintptr_t raw_addr = (uintptr_t)raw_ptr + sizeof(void*);
    uintptr_t aligned_addr = (raw_addr + alignment - 1) & ~(alignment - 1);
    
    // åœ¨å°é½Šä½å€å‰é¢å„²å­˜åŸå§‹ä½å€
    void **ptr_storage = (void**)(aligned_addr - sizeof(void*));
    *ptr_storage = raw_ptr;
    
    return (void*)aligned_addr;
}

/**
 * aligned_free - é‡‹æ”¾ç”± aligned_malloc åˆ†é…çš„è¨˜æ†¶é«”
 * @ptr: aligned_malloc å›å‚³çš„æŒ‡æ¨™
 */
void aligned_free(void *ptr) {
    if (ptr == NULL) return;
    
    // å–å‡ºå„²å­˜çš„åŸå§‹æŒ‡æ¨™
    void *raw_ptr = *((void**)ptr - 1);
    free(raw_ptr);
}

// æ¸¬è©¦
int main() {
    // æ¸¬è©¦ 16-byte å°é½Š
    void *p = aligned_malloc(100, 16);
    printf("Aligned ptr: %p\n", p);
    printf("Is aligned: %s\n", ((uintptr_t)p % 16 == 0) ? "Yes" : "No");
    
    aligned_free(p);
    
    // æ¸¬è©¦ 128-byte å°é½Š
    p = aligned_malloc(256, 128);
    printf("Aligned ptr: %p\n", p);
    printf("Is aligned: %s\n", ((uintptr_t)p % 128 == 0) ? "Yes" : "No");
    
    aligned_free(p);
    
    return 0;
}
```

### 9.3 å°é½Šå…¬å¼çš„è©³ç´°è§£é‡‹

```c
// å‘ä¸Šå°é½Šåˆ° alignment çš„å€æ•¸ï¼š
// aligned = (addr + alignment - 1) & ~(alignment - 1)

// ç‚ºä»€éº¼é€™æ¨£åšï¼Ÿ
// å‡è¨­ alignment = 16 (0b10000)
// alignment - 1 = 15 (0b01111)
// ~(alignment - 1) = 0b...11110000

// ç¯„ä¾‹ï¼šaddr = 0x1003ï¼Œè¦å°é½Šåˆ° 16
// Step 1: 0x1003 + 15 = 0x1012
// Step 2: 0x1012 & 0xFFF0 = 0x1010
// çµæœï¼š0x1010 æ˜¯ 16 çš„å€æ•¸ âœ“
```

### 9.4 ä½¿ç”¨ POSIX posix_memalign

å¯¦éš›é–‹ç™¼ä¸­ï¼Œå„ªå…ˆä½¿ç”¨æ¨™æº–åº«å‡½å¼ï¼š

```c
#include <stdlib.h>

void *ptr;
int ret = posix_memalign(&ptr, 16, 100);  // 16-byte å°é½Šï¼Œåˆ†é… 100 bytes
if (ret == 0) {
    // ä½¿ç”¨ ptr
    free(ptr);  // æ™®é€š free å³å¯
}

// C11 ä¹Ÿæœ‰ aligned_alloc
void *ptr2 = aligned_alloc(16, 100);
free(ptr2);
```

---

## ğŸ”· ç¬¬åéƒ¨åˆ†ï¼šè¨˜æ†¶é«”ä½ˆå±€ (Memory Layout)

### 10.1 ç¨‹å¼çš„è¨˜æ†¶é«”å€æ®µ

```
                    é«˜ä½å€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       Stack             â”‚  â† å€åŸŸè®Šæ•¸ã€å‡½å¼åƒæ•¸ã€è¿”å›ä½å€
â”‚         â†“               â”‚    å¤§å°æœ‰é™ï¼ˆé€šå¸¸ 1-8 MBï¼‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                         â”‚
â”‚      å¯æˆé•·ç©ºé–“          â”‚  â† Stack å‘ä¸‹æˆé•·ï¼ŒHeap å‘ä¸Šæˆé•·
â”‚                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         â†‘               â”‚
â”‚       Heap              â”‚  â† malloc/calloc åˆ†é…çš„è¨˜æ†¶é«”
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   BSS (Block Started    â”‚  â† æœªåˆå§‹åŒ–çš„å…¨åŸŸ/éœæ…‹è®Šæ•¸
â”‚    by Symbol)           â”‚    ï¼ˆç¨‹å¼è¼‰å…¥æ™‚ç”± OS æ¸…ç‚º 0ï¼‰
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Data              â”‚  â† å·²åˆå§‹åŒ–çš„å…¨åŸŸ/éœæ…‹è®Šæ•¸
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Text              â”‚  â† ç¨‹å¼ç¢¼ï¼ˆå”¯è®€ï¼‰
â”‚      (Code)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    ä½ä½å€
```

### 10.2 è®Šæ•¸çš„å­˜æ”¾ä½ç½®

```c
#include <stdio.h>
#include <stdlib.h>

int global_init = 100;          // Data section
int global_uninit;              // BSS sectionï¼ˆè‡ªå‹•æ¸…ç‚º 0ï¼‰
static int static_global = 5;   // Data section

void func() {
    int local = 10;                         // Stack
    static int static_local = 20;           // Data section
    int *heap_ptr = (int*)malloc(4);        // æŒ‡æ¨™åœ¨ Stack
                                            // æŒ‡å‘çš„è³‡æ–™åœ¨ Heap
    char *str_literal = "Hello";            // æŒ‡æ¨™åœ¨ Stack
                                            // "Hello" åœ¨ Text/Rodataï¼ˆå”¯è®€ï¼‰
    const int local_const = 30;             // Stackï¼ˆconst ä¸å½±éŸ¿ä½ç½®ï¼‰
    
    free(heap_ptr);
}
```

### 10.3 Stack vs Heap è©³ç´°æ¯”è¼ƒ

| ç‰¹æ€§ | Stack | Heap |
|:---|:---|:---|
| ç®¡ç†æ–¹å¼ | è‡ªå‹•ï¼ˆç·¨è­¯å™¨ç®¡ç†ï¼‰ | æ‰‹å‹•ï¼ˆç¨‹å¼å“¡ç®¡ç†ï¼‰ |
| åˆ†é…é€Ÿåº¦ | æ¥µå¿«ï¼ˆåªéœ€ç§»å‹• SPï¼‰ | è¼ƒæ…¢ï¼ˆéœ€è¦æœå°‹å¯ç”¨ç©ºé–“ï¼‰ |
| å¤§å°é™åˆ¶ | æœ‰é™ï¼ˆ1-8 MBï¼‰ | è¼ƒå¤§ï¼ˆå¯é”æ•¸ GBï¼‰ |
| æˆé•·æ–¹å‘ | å‘ä½ä½å€æˆé•· | å‘é«˜ä½å€æˆé•· |
| ç”Ÿå‘½é€±æœŸ | å‡½å¼çµæŸè‡ªå‹•é‡‹æ”¾ | ç›´åˆ° free() æ‰é‡‹æ”¾ |
| ç¢ç‰‡åŒ– | ç„¡ | å¯èƒ½ç”¢ç”Ÿç¢ç‰‡ |
| å…¸å‹ç”¨é€” | å€åŸŸè®Šæ•¸ã€åƒæ•¸ | å‹•æ…‹è³‡æ–™çµæ§‹ |

---

## ğŸ”· ç¬¬åä¸€éƒ¨åˆ†ï¼šABI èˆ‡ Calling Convention

### 11.1 ä»€éº¼æ˜¯ ABIï¼Ÿ

ABI (Application Binary Interface) å®šç¾©äº†ï¼š
1. å‡½å¼å¦‚ä½•å‚³éåƒæ•¸
2. è¿”å›å€¼å¦‚ä½•å‚³é
3. æš«å­˜å™¨å¦‚ä½•ä½¿ç”¨
4. Stack å¦‚ä½•ä½ˆå±€
5. çµæ§‹é«”å¦‚ä½•åœ¨è¨˜æ†¶é«”ä¸­æ’åˆ—

### 11.2 ARM AAPCS (ARM Architecture Procedure Call Standard)

é€™æ˜¯ ARM å¹³å°çš„æ¨™æº– Calling Conventionï¼š

```c
// ARM 64-bit (AArch64) çš„æš«å­˜å™¨ä½¿ç”¨ï¼š

// åƒæ•¸å‚³éï¼šX0-X7ï¼ˆå‰ 8 å€‹æ•´æ•¸/æŒ‡æ¨™åƒæ•¸ï¼‰
// è¿”å›å€¼ï¼šX0ï¼ˆæ•´æ•¸è¿”å›å€¼ï¼‰
// Caller-savedï¼ˆå‘¼å«è€…ä¿å­˜ï¼‰ï¼šX0-X18
// Callee-savedï¼ˆè¢«å‘¼å«è€…ä¿å­˜ï¼‰ï¼šX19-X28
// ç‰¹æ®Šç”¨é€”ï¼š
//   X29 (FP): Frame Pointer
//   X30 (LR): Link Registerï¼ˆè¿”å›ä½å€ï¼‰
//   SP: Stack Pointer

// ç¯„ä¾‹ï¼š
int add(int a, int b) {  // a åœ¨ W0ï¼Œb åœ¨ W1
    return a + b;        // çµæœæ”¾åœ¨ W0
}

// å°æ‡‰çš„çµ„èªï¼š
// add w0, w0, w1
// ret
```

### 11.3 Caller-saved vs Callee-saved

```c
// Caller-saved registers (X0-X18)ï¼š
// - å‘¼å«å‡½å¼å‰ï¼Œå‘¼å«è€…ï¼ˆcallerï¼‰å¿…é ˆè‡ªå·±ä¿å­˜é€™äº›æš«å­˜å™¨
// - è¢«å‘¼å«å‡½å¼å¯ä»¥è‡ªç”±ä¿®æ”¹

// Callee-saved registers (X19-X28)ï¼š
// - è¢«å‘¼å«å‡½å¼å¦‚æœè¦ä½¿ç”¨ï¼Œå¿…é ˆå…ˆä¿å­˜ã€ç”¨å®Œå¾Œæ¢å¾©
// - å‘¼å«è€…å¯ä»¥å‡è¨­é€™äº›æš«å­˜å™¨çš„å€¼åœ¨å‡½å¼å‘¼å«å¾Œä¸è®Š

void caller() {
    int x = 5;  // å‡è¨­ x æ”¾åœ¨ X19ï¼ˆcallee-savedï¼‰
    foo();      // foo() ä¿è­‰ä¸æœƒç ´å£ X19
    use(x);     // x ä»ç„¶æ˜¯ 5
}

void callee() {
    // å¦‚æœéœ€è¦ä½¿ç”¨ X19
    // 1. å…ˆæŠŠ X19 çš„å€¼ push åˆ° stack
    // 2. ä½¿ç”¨ X19
    // 3. pop æ¢å¾© X19
}
```

### 11.4 Stack Frame çµæ§‹

```
                é«˜ä½å€
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ä¸Šä¸€å€‹å‡½å¼çš„ Stack     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Return Address (LR)    â”‚  â† ç”± caller push
â”‚  Previous FP (X29)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â† Current FP points here
â”‚  Saved Callee-saved     â”‚
â”‚  Registers (X19-X28)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Local Variables        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Outgoing Parameters    â”‚  â† è¶…é 8 å€‹çš„åƒæ•¸æ”¾é€™è£¡
â”‚  (if > 8 args)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â† SP points here
                ä½ä½å€
```

---

## ğŸ”· ç¬¬åäºŒéƒ¨åˆ†ï¼šç·¨è­¯èˆ‡é€£çµ

### 12.1 ç·¨è­¯å››éšæ®µ

```
C åŸå§‹ç¢¼ç¶“éå››å€‹éšæ®µæ‰è®Šæˆå¯åŸ·è¡Œæª”ï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  éšæ®µ       â”‚ èªªæ˜                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. é è™•ç†   â”‚ gcc -Eï¼šå±•é–‹ #includeã€#defineã€å·¨é›†                 â”‚
â”‚ Preprocess â”‚ è¼¸å‡ºï¼š.i æª”æ¡ˆ                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. ç·¨è­¯    â”‚ gcc -Sï¼šå°‡ C è½‰æˆçµ„åˆèªè¨€                            â”‚
â”‚ Compile    â”‚ è¼¸å‡ºï¼š.s æª”æ¡ˆ                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. çµ„è­¯    â”‚ gcc -cï¼šå°‡çµ„èªè½‰æˆæ©Ÿå™¨ç¢¼                             â”‚
â”‚ Assemble   â”‚ è¼¸å‡ºï¼š.o æª”æ¡ˆï¼ˆObject Fileï¼‰                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. é€£çµ    â”‚ gccï¼ˆç„¡é¸é …ï¼‰ï¼šåˆä½µå¤šå€‹ .oï¼Œè§£æç¬¦è™Ÿ                  â”‚
â”‚ Link       â”‚ è¼¸å‡ºï¼šå¯åŸ·è¡Œæª”æˆ– .so/.a                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# ç¯„ä¾‹å‘½ä»¤
gcc -E main.c -o main.i    # é è™•ç†
gcc -S main.i -o main.s    # ç·¨è­¯
gcc -c main.s -o main.o    # çµ„è­¯
gcc main.o -o main         # é€£çµ
```

### 12.2 Symbol èˆ‡ Symbol Table

```c
// Symbolï¼ˆç¬¦è™Ÿï¼‰= å‡½å¼åæˆ–å…¨åŸŸè®Šæ•¸å

// æŸ¥çœ‹ object file çš„ symbol table
// nm main.o

// Symbol é¡å‹ï¼š
// T (text) - å‡½å¼ï¼Œå®šç¾©åœ¨æ­¤æª”æ¡ˆ
// U (undefined) - æœªå®šç¾©ï¼Œéœ€è¦é€£çµæ™‚è§£æ
// D (data) - å·²åˆå§‹åŒ–çš„å…¨åŸŸè®Šæ•¸
// B (bss) - æœªåˆå§‹åŒ–çš„å…¨åŸŸè®Šæ•¸

// ç¯„ä¾‹è¼¸å‡ºï¼š
// 0000000000000000 T main
// 0000000000000000 D global_var
//                  U printf
```

### 12.3 Symbol Visibility

```c
// æ§åˆ¶ symbol æ˜¯å¦å°å¤–å¯è¦‹

// é è¨­ï¼šæ‰€æœ‰å‡½å¼å’Œå…¨åŸŸè®Šæ•¸éƒ½æ˜¯ exported
void public_func(void) { }

// ä½¿ç”¨ staticï¼šåªåœ¨æœ¬æª”æ¡ˆå¯è¦‹
static void private_func(void) { }

// GCC æ“´å±•ï¼šæ›´ç´°ç·»çš„æ§åˆ¶
__attribute__((visibility("hidden")))
void internal_func(void) { }

__attribute__((visibility("default")))
void exported_func(void) { }

// ç·¨è­¯æ™‚è¨­å®šé è¨­å€¼
// gcc -fvisibility=hidden main.c
// æ­é… __attribute__((visibility("default"))) åªå°å‡ºéœ€è¦çš„
```

### 12.4 Linker Script åŸºç¤

```ld
/* åµŒå…¥å¼ç³»çµ±å¸¸è¦‹çš„ Linker Script çµæ§‹ */
/* æª”æ¡ˆï¼šlinker.ld */

MEMORY
{
    FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 512K
    SRAM  (rwx) : ORIGIN = 0x20000000, LENGTH = 128K
}

SECTIONS
{
    /* ç¨‹å¼ç¢¼æ”¾åœ¨ Flash */
    .text : {
        *(.isr_vector)      /* ä¸­æ–·å‘é‡è¡¨æ”¾æœ€å‰é¢ */
        *(.text)            /* æ‰€æœ‰ç¨‹å¼ç¢¼ */
        *(.text*)
        *(.rodata)          /* å”¯è®€è³‡æ–™ï¼ˆå­—ä¸²å¸¸é‡ç­‰ï¼‰ */
    } > FLASH

    /* å·²åˆå§‹åŒ–è³‡æ–™ï¼šå­˜åœ¨ Flashï¼ŒåŸ·è¡Œæ™‚è¼‰å…¥åˆ° SRAM */
    .data : {
        _sdata = .;         /* data å€æ®µèµ·å§‹ */
        *(.data)
        *(.data*)
        _edata = .;         /* data å€æ®µçµæŸ */
    } > SRAM AT> FLASH

    /* æœªåˆå§‹åŒ–è³‡æ–™ï¼šåœ¨ SRAMï¼Œå•Ÿå‹•æ™‚æ¸…é›¶ */
    .bss : {
        _sbss = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        _ebss = .;
    } > SRAM
    
    /* Stack æ”¾åœ¨ SRAM æœ€é«˜ä½å€ */
    _estack = ORIGIN(SRAM) + LENGTH(SRAM);
}

/* ç¬¦è™Ÿ _sdata, _edata, _sbss, _ebss ç”¨æ–¼ startup code */
```

### 12.5 éœæ…‹åº« vs å‹•æ…‹åº«

```bash
# éœæ…‹åº« (.a)ï¼šé€£çµæ™‚è¤‡è£½åˆ°å¯åŸ·è¡Œæª”
ar rcs libmath.a math.o        # å»ºç«‹éœæ…‹åº«
gcc main.c -L. -lmath -o main  # é€£çµ

# å‹•æ…‹åº« (.so)ï¼šåŸ·è¡Œæ™‚è¼‰å…¥
gcc -shared -fPIC -o libmath.so math.c  # å»ºç«‹å‹•æ…‹åº«
gcc main.c -L. -lmath -o main           # é€£çµ
# åŸ·è¡Œæ™‚éœ€è¦ LD_LIBRARY_PATH æˆ–å®‰è£åˆ°ç³»çµ±è·¯å¾‘
```

| ç‰¹æ€§ | éœæ…‹åº« (.a) | å‹•æ…‹åº« (.so) |
|:---|:---|:---|
| å¤§å° | å¯åŸ·è¡Œæª”è¼ƒå¤§ | å¯åŸ·è¡Œæª”è¼ƒå° |
| æ›´æ–° | éœ€é‡æ–°ç·¨è­¯ | åªéœ€æ›¿æ› .so |
| è¼‰å…¥æ™‚é–“ | è¼ƒå¿« | éœ€è¼‰å…¥ .so |
| è¨˜æ†¶é«”å…±äº« | ä¸å…±äº« | å¤šç¨‹å¼å¯å…±äº« |
| åµŒå…¥å¼å¸¸ç”¨ | âœ“ | è¼ƒå°‘ |

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: `static inline` å’Œ `extern inline` æœ‰ä»€éº¼å€åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Google

**å•é¡Œ**ï¼š
è§£é‡‹ `static inline`ã€`inline`ã€`extern inline` çš„å€åˆ¥ã€‚å¦‚æœåœ¨ header file ä¸­å®šç¾© inline functionï¼Œæœƒç™¼ç”Ÿä»€éº¼äº‹ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
// 1. static inlineï¼ˆæœ€å¸¸ç”¨ï¼‰
// - æ¯å€‹ .c æª”æ¡ˆéƒ½æœ‰è‡ªå·±çš„å‰¯æœ¬
// - å¦‚æœæ²’è¢« inlineï¼Œç·¨è­¯å™¨æœƒç”¢ç”Ÿ static å‡½å¼
static inline int add(int a, int b) { return a + b; }

// 2. inlineï¼ˆC99 èªæ„ï¼‰
// - åªæ˜¯ã€Œå»ºè­°ã€ç·¨è­¯å™¨ inline
// - å¦‚æœæ²’è¢« inlineï¼Œéœ€è¦åœ¨æŸå€‹ .c æª”æ¡ˆæä¾›ã€Œå¤–éƒ¨å®šç¾©ã€
inline int mul(int a, int b) { return a * b; }
// éœ€è¦åœ¨æŸå€‹ .c æª”æ¡ˆåŠ ä¸Š extern å®£å‘Šï¼š
// extern inline int mul(int a, int b);

// 3. extern inlineï¼ˆGNU èˆŠèªæ„ / C99 çš„ inline + å¤–éƒ¨å®šç¾©ï¼‰
// å¾ˆå°‘ç”¨ï¼Œè¡Œç‚ºè¤‡é›œï¼Œä¸å»ºè­°ä½¿ç”¨

// æœ€ä½³å¯¦è¸ï¼šåœ¨ header ä¸­ä½¿ç”¨ static inline
// file: math.h
static inline int safe_add(int a, int b) {
    return a + b;
}
```

**é¢è©¦å®˜å¯èƒ½çš„è¿½å•**ï¼š
Q: ç‚ºä»€éº¼ `static inline` æ¯å€‹æª”æ¡ˆéƒ½æœ‰å‰¯æœ¬ä¸æœƒé€ æˆ code bloatï¼Ÿ
A: å°æ–¼å°å‡½å¼ï¼Œç·¨è­¯å™¨æœƒçœŸçš„ inlineï¼Œä¸ç”¢ç”Ÿç¨ç«‹å‡½å¼ã€‚å¦‚æœå‡½å¼å¤§åˆ°ç„¡æ³• inlineï¼Œä»£è¡¨å®ƒä¸è©²æ˜¯ inline functionã€‚

---

### Q2: æ‰‹å¯« `aligned_malloc(size_t size, size_t alignment)`

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Google / Apple

**å•é¡Œ**ï¼š
å¯¦ä½œ `aligned_malloc` å’Œ `aligned_free`ã€‚alignment ä¿è­‰æ˜¯ 2 çš„å†ªæ¬¡ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š
ï¼ˆåƒè¦‹ç¬¬ä¹éƒ¨åˆ†çš„å®Œæ•´å¯¦ä½œï¼‰

æ ¸å¿ƒè¦é»ï¼š
1. å¤šåˆ†é… `alignment - 1 + sizeof(void*)` ç©ºé–“
2. å°é½Šå…¬å¼ï¼š`(addr + alignment - 1) & ~(alignment - 1)`
3. åœ¨å°é½Šä½å€å‰å„²å­˜åŸå§‹ä½å€

---

### Q3: Pointer Aliasing å•é¡Œ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šç·¨è­¯å™¨åœ˜éšŠ / æ•ˆèƒ½å„ªåŒ–è·ä½

**å•é¡Œ**ï¼š
ä»¥ä¸‹ç¨‹å¼ç¢¼ï¼Œç·¨è­¯å™¨èƒ½å¦å°‡ `*a` çš„è®€å–å„ªåŒ–ç‚ºåªè®€ä¸€æ¬¡ï¼Ÿ

```c
void copy(int *a, int *b, int n) {
    for (int i = 0; i < n; i++) {
        b[i] = *a;  // å¯ä»¥æŠŠ *a æå‡ºè¿´åœˆå—ï¼Ÿ
    }
}
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š
ä¸èƒ½ï¼å› ç‚º `a` å’Œ `b` å¯èƒ½æŒ‡å‘é‡ç–Šçš„è¨˜æ†¶é«”ã€‚ä¾‹å¦‚ï¼š
```c
int arr[10];
copy(&arr[5], arr, 10);  // a åœ¨ b çš„ç¯„åœå…§ï¼
```
ç•¶ `i = 5` æ™‚ï¼Œ`b[5]` æœƒä¿®æ”¹ `*a`ï¼Œæ‰€ä»¥æ¯æ¬¡éƒ½å¿…é ˆé‡æ–°è®€å–ã€‚

ä½¿ç”¨ `restrict` å¯ä»¥è®“ç·¨è­¯å™¨å„ªåŒ–ï¼š
```c
void copy(int * restrict a, int * restrict b, int n) {
    // ç·¨è­¯å™¨å¯ä»¥æŠŠ *a æå‡ºè¿´åœˆ
}
```

---

### Q4: Stack Overflow çš„åŸå› 

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šåµŒå…¥å¼é¢è©¦

**å•é¡Œ**ï¼š
ä»€éº¼æƒ…æ³æœƒå°è‡´ Stack Overflowï¼Ÿå¦‚ä½•é¿å…ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

åŸå› ï¼š
1. **ç„¡é™éè¿´**ï¼šæ²’æœ‰çµ‚æ­¢æ¢ä»¶çš„éè¿´
2. **éå¤§çš„å€åŸŸè®Šæ•¸**ï¼š`char buf[1000000];`
3. **éè¿´å¤ªæ·±**ï¼šå³ä½¿æœ‰çµ‚æ­¢æ¢ä»¶ï¼Œéè¿´æ·±åº¦å¤ªå¤§

é¿å…æ–¹æ³•ï¼š
1. ç¢ºä¿éè¿´æœ‰æ­£ç¢ºçš„çµ‚æ­¢æ¢ä»¶
2. å¤§å‹è³‡æ–™ä½¿ç”¨ heapï¼ˆmallocï¼‰
3. ä½¿ç”¨å°¾éè¿´å„ªåŒ–ï¼ˆç·¨è­¯å™¨æ”¯æ´ï¼‰
4. å¢åŠ  stack å¤§å°ï¼ˆä¸æ˜¯æ ¹æœ¬è§£æ±ºæ–¹æ¡ˆï¼‰

åµŒå…¥å¼ç³»çµ±ä¸­ï¼š
- Stack æ›´å°ï¼ˆå¯èƒ½åªæœ‰å¹¾ KBï¼‰
- å¯ä»¥è¨­å®š stack canary æª¢æ¸¬æº¢ä½
- ä½¿ç”¨éœæ…‹åˆ†æå·¥å…·è¨ˆç®—æœ€å¤§ stack ä½¿ç”¨é‡

---

### Q5: é€™æ®µç¨‹å¼ç¢¼æœ‰ä»€éº¼å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
```c
char *getString() {
    char str[] = "Hello";
    return str;
}
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š
å›å‚³æŒ‡å‘å€åŸŸè®Šæ•¸çš„æŒ‡æ¨™ï¼ˆDangling Pointerï¼‰ã€‚

`str` æ˜¯å€åŸŸé™£åˆ—ï¼Œå­˜åœ¨ stack ä¸Šã€‚å‡½å¼çµæŸå¾Œï¼Œstack ç©ºé–“è¢«å›æ”¶ï¼Œå›å‚³çš„æŒ‡æ¨™æŒ‡å‘ç„¡æ•ˆè¨˜æ†¶é«”ã€‚

ä¿®æ­£æ–¹å¼ï¼š
1. `static char str[] = "Hello";`ï¼ˆå­˜åœ¨ data sectionï¼‰
2. `char *str = "Hello"; return str;`ï¼ˆå›å‚³æŒ‡å‘ rodata çš„æŒ‡æ¨™ï¼‰
3. `char *str = malloc(6); strcpy(str, "Hello"); return str;`ï¼ˆcaller éœ€ freeï¼‰

---

### Q6: `const int *` vs `int * const` vs `const int * const`

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
è§£é‡‹é€™ä¸‰è€…çš„å€åˆ¥ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
int x = 10, y = 20;

// 1. æŒ‡å‘å¸¸æ•¸çš„æŒ‡æ¨™ï¼ˆPointer to Constantï¼‰
const int *p1 = &x;
// *p1 = 20;     // âŒ ä¸èƒ½é€é p1 ä¿®æ”¹å€¼
p1 = &y;         // âœ“ p1 å¯ä»¥æ”¹æŒ‡å‘åˆ¥è™•

// 2. å¸¸æ•¸æŒ‡æ¨™ï¼ˆConstant Pointerï¼‰
int * const p2 = &x;
*p2 = 20;        // âœ“ å¯ä»¥é€é p2 ä¿®æ”¹å€¼
// p2 = &y;      // âŒ p2 ä¸èƒ½æ”¹æŒ‡å‘åˆ¥è™•

// 3. æŒ‡å‘å¸¸æ•¸çš„å¸¸æ•¸æŒ‡æ¨™ï¼ˆConstant Pointer to Constantï¼‰
const int * const p3 = &x;
// *p3 = 20;     // âŒ
// p3 = &y;      // âŒ
```

è¨˜æ†¶æ–¹æ³•ï¼š`const` åœ¨ `*` å·¦é‚Š â†’ å€¼ä¸å¯æ”¹ï¼Œ`const` åœ¨ `*` å³é‚Š â†’ æŒ‡æ¨™ä¸å¯æ”¹ã€‚

---

### Q7: ç‚ºä»€éº¼ `sizeof(struct)` ä¸ç­‰æ–¼å„æˆå“¡å¤§å°ä¹‹å’Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
```c
struct S {
    char a;
    int b;
    char c;
};
printf("%zu\n", sizeof(struct S));  // è¼¸å‡ºä»€éº¼ï¼Ÿ
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š
12ï¼ˆåœ¨å¤§å¤šæ•¸ 32/64-bit ç³»çµ±ä¸Šï¼‰ã€‚

åŸå› ï¼šMemory Alignmentï¼ˆè¨˜æ†¶é«”å°é½Šï¼‰ã€‚
- `int` éœ€è¦ 4-byte å°é½Š
- `a` å¾Œé¢æœ‰ 3 bytes padding
- `c` å¾Œé¢æœ‰ 3 bytes paddingï¼ˆçµæ§‹é«”å¤§å°é ˆæ˜¯æœ€å¤§æˆå“¡å°é½Šçš„å€æ•¸ï¼‰

```
| a |pad|pad|pad| b  b  b  b | c |pad|pad|pad|
  1      3            4         1      3       = 12
```

å„ªåŒ–æ–¹æ³•ï¼šé‡æ–°æ’åˆ—æˆå“¡é †åº
```c
struct S_optimized {
    int b;   // 4
    char a;  // 1
    char c;  // 1
             // 2 padding
};  // ç¸½å…± 8 bytes
```

---

### Q8: void* æŒ‡æ¨™

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
`void *` æŒ‡æ¨™å¯ä»¥åšæŒ‡æ¨™ç®—è¡“å—ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**æ¨™æº– C**ï¼šä¸è¡Œã€‚`void` æ²’æœ‰å¤§å°ï¼Œ`void *` ä¸èƒ½åšç®—è¡“é‹ç®—ã€‚

**GCC æ“´å±•**ï¼šå¯ä»¥ã€‚GCC æŠŠ `void *` ç•¶ä½œ `char *` ä¾†è¨ˆç®—ï¼Œ+1 ç§»å‹• 1 byteã€‚

```c
void *p = (void *)0x1000;

// æ¨™æº– Cï¼šç·¨è­¯éŒ¯èª¤
// p + 1;

// GCC æ“´å±•ï¼ˆ-fgnu-extensionsï¼Œé è¨­é–‹å•Ÿï¼‰
// p + 1 = 0x1001

// å®‰å…¨åšæ³•ï¼šæ˜ç¢ºè½‰å‹
(char *)p + 1;  // 0x1001
(int *)p + 1;   // 0x1004
```

---

### Q9: é€™å€‹ realloc ä½¿ç”¨æœ‰ä»€éº¼å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
```c
int *p = malloc(10 * sizeof(int));
p = realloc(p, 1000000000 * sizeof(int));
if (p == NULL) {
    printf("Allocation failed\n");
}
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š
å¦‚æœ `realloc` å¤±æ•—å›å‚³ `NULL`ï¼Œ**åŸæœ¬çš„è¨˜æ†¶é«”å°±æ´©æ¼äº†**ï¼

å› ç‚º `p` è¢«è¦†è“‹æˆ `NULL`ï¼Œæˆ‘å€‘å¤±å»äº†åŸæœ¬è¨˜æ†¶é«”çš„æŒ‡æ¨™ã€‚

æ­£ç¢ºå¯«æ³•ï¼š
```c
int *p = malloc(10 * sizeof(int));
int *new_p = realloc(p, 1000000000 * sizeof(int));
if (new_p == NULL) {
    printf("Allocation failed, but p is still valid\n");
    // p ä»ç„¶å¯ç”¨
} else {
    p = new_p;
}
```

---

### Q10: é€™æ®µç¨‹å¼ç¢¼æœƒå°å‡ºä»€éº¼ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / å¾®è»Ÿ

**å•é¡Œ**ï¼š
```c
int arr[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
int *p = (int *)arr;
printf("%d\n", *(p + 4));
printf("%d\n", *(*(arr + 1) + 2));
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š
```
5
6
```

è§£é‡‹ï¼š
1. `arr` åœ¨è¨˜æ†¶é«”ä¸­æ˜¯é€£çºŒçš„ï¼š`1 2 3 4 5 6 7 8 9`
2. `p` è½‰æˆ `int *` å¾Œï¼Œ`p + 4` æŒ‡å‘ç¬¬ 5 å€‹å…ƒç´  = 5
3. `arr + 1` æ˜¯æŒ‡å‘ç¬¬äºŒåˆ—çš„æŒ‡æ¨™ï¼ˆå‹åˆ¥ `int (*)[3]`ï¼‰
4. `*(arr + 1)` æ˜¯ç¬¬äºŒåˆ—ï¼ˆé€€åŒ–æˆ `int *`ï¼‰
5. `*(arr + 1) + 2` æ˜¯ç¬¬äºŒåˆ—ç¬¬ä¸‰å€‹å…ƒç´  = 6

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **æ›¸ç±**
   - ã€ŠExpert C Programmingã€‹ - Peter van der Linden
   - ã€ŠC Traps and Pitfallsã€‹ - Andrew Koenig
   - ã€ŠUnderstanding and Using C Pointersã€‹ - Richard Reese

2. **ç·šä¸Šè³‡æº**
   - [cppreference.com](https://en.cppreference.com/w/c) - C èªè¨€æ¨™æº–åƒè€ƒ
   - [Compiler Explorer (godbolt.org)](https://godbolt.org/) - æŸ¥çœ‹ç·¨è­¯å¾Œçš„çµ„èª
   - [LinkedIn Learning: Advanced C Programming](https://www.linkedin.com/learning/) - é€²éš C èª²ç¨‹

3. **ARM æ–‡ä»¶**
   - [ARM Architecture Procedure Call Standard](https://developer.arm.com/documentation/ihi0042/latest)
   - [ARM Cortex-A Programmer's Guide](https://developer.arm.com/documentation/)

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/02_Cèªè¨€/æŒ‡æ¨™èˆ‡è¨˜æ†¶é«”.md`
- æ“´å……å‰è¡Œæ•¸ï¼š434 è¡Œ
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 1550 è¡Œ
- æ–°å¢é¢è©¦é¡Œæ•¸ï¼š10 é¡Œ
- è‡ªæª¢çµæœï¼š
  - [x] åŒ…å«å®Œæ•´çš„ Why â†’ What â†’ How â†’ Deep Dive çµæ§‹
  - [x] æ¶µè“‹ Pointer to Pointerã€Function Pointerã€restrict
  - [x] æ¶µè“‹ Memory Alignmentã€aligned_malloc/aligned_free
  - [x] æ¶µè“‹ ABI & Calling Convention (ARM AAPCS)
  - [x] ç¨‹å¼ç¢¼ç¯„ä¾‹æœ‰è¨»è§£
  - [x] é¢è©¦é¡ŒåŒ…å« NVIDIA/Google ç´šåˆ¥é›£åº¦
