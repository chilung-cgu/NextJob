# 🔧 指標與記憶體進階詳解

> 這是 C 語言面試必考中的必考！

---

## 📌 指標基礎回顧

### 什麼是指標？

```c
// 指標是儲存「記憶體位址」的變數

int a = 10;        // a 是一個 int，值是 10
int *p = &a;       // p 是指標，儲存 a 的位址

printf("a 的值: %d\n", a);      // 10
printf("a 的位址: %p\n", &a);   // 如 0x7ffd12345678
printf("p 的值: %p\n", p);      // 同上，p 儲存 a 的位址
printf("p 指向的值: %d\n", *p); // 10，透過 p 取得 a 的值
```

### 記憶體視覺化

```
記憶體位址    內容        變數
─────────────────────────
0x1000       10          a
0x1008       0x1000      p  (p 儲存 a 的位址)
```

---

## 🔷 指標運算

### 指標算術

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // p 指向 arr[0]

// 指標 +1 會移動一個元素的大小（int = 4 bytes）
printf("*p = %d\n", *p);         // 10
printf("*(p+1) = %d\n", *(p+1)); // 20
printf("*(p+2) = %d\n", *(p+2)); // 30

// 指標前進
p++;
printf("*p = %d\n", *p);         // 20

// 指標後退
p--;
printf("*p = %d\n", *p);         // 10
```

### 指標相減

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p1 = &arr[1];  // 指向 arr[1]
int *p2 = &arr[4];  // 指向 arr[4]

// 指標相減得到兩者間的元素個數（不是 bytes）
ptrdiff_t diff = p2 - p1;
printf("diff = %td\n", diff);  // 3
```

---

## 🔷 多重指標

### 二重指標

```c
int a = 10;
int *p = &a;      // p 是指向 int 的指標
int **pp = &p;    // pp 是指向「指向 int 的指標」的指標

printf("a = %d\n", a);       // 10
printf("*p = %d\n", *p);     // 10
printf("**pp = %d\n", **pp); // 10

// 記憶體視覺化：
// a:  [10]     位址 0x1000
// p:  [0x1000] 位址 0x1008
// pp: [0x1008] 位址 0x1010
//
// **pp：先取 pp 的值 (0x1008)，再取該位址的值 (0x1000)，
//       再取該位址的值 (10)
```

### 二重指標的用途

```c
// 用途 1：在函式中修改指標本身
void allocate(int **pp) {
    *pp = (int*)malloc(sizeof(int));
    **pp = 100;
}

int main() {
    int *p = NULL;
    allocate(&p);  // 傳入 p 的位址
    printf("*p = %d\n", *p);  // 100
    free(p);
    return 0;
}

// 用途 2：指向指標的陣列
char *names[] = {"Alice", "Bob", "Charlie"};
char **pp = names;  // pp 指向 names[0]
printf("%s\n", *pp);     // Alice
printf("%s\n", *(pp+1)); // Bob
```

---

## 🔷 指標與陣列

### 陣列名是「常數指標」

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;  // arr 退化成指向第一個元素的指標

// 這兩個等價：
printf("%d\n", arr[2]);   // 30
printf("%d\n", *(arr+2)); // 30

// 但 arr 是常數，不能 arr++
// p++ 是合法的
```

### 陣列傳入函式

```c
// 當陣列傳入函式，會退化成指標
void printArray(int *arr, int size) {  // 或 int arr[]
    // 在這裡 sizeof(arr) 是指標大小，不是陣列大小！
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    printf("sizeof(arr) = %zu\n", sizeof(arr));  // 20
    printArray(arr, 5);  // 傳入後變成指標
}
```

### 二維陣列與指標

```c
int arr[3][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12}
};

// arr 是「指向 int[4] 的指標」
// arr[0] 是「指向 int 的指標」

int (*p)[4] = arr;  // p 是指向 int[4] 的指標

printf("arr[1][2] = %d\n", arr[1][2]);     // 7
printf("*(*(p+1)+2) = %d\n", *(*(p+1)+2)); // 7
```

---

## 🔷 函式指標

### 基本使用

```c
// 函式指標：指向函式的指標

int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }

int main() {
    // 宣告函式指標
    int (*fp)(int, int);  // fp 是指標，指向接受兩個 int 回傳 int 的函式
    
    fp = add;  // 指向 add 函式
    printf("%d\n", fp(3, 4));  // 7
    
    fp = sub;  // 指向 sub 函式
    printf("%d\n", fp(3, 4));  // -1
    
    return 0;
}
```

### Callback 函式

```c
// 用函式指標實作 callback

void processArray(int *arr, int size, void (*callback)(int)) {
    for (int i = 0; i < size; i++) {
        callback(arr[i]);
    }
}

void printValue(int x) {
    printf("%d ", x);
}

void doubleValue(int x) {
    printf("%d ", x * 2);
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    
    printf("原始: ");
    processArray(arr, 5, printValue);  // 1 2 3 4 5
    
    printf("\n加倍: ");
    processArray(arr, 5, doubleValue); // 2 4 6 8 10
    
    return 0;
}
```

### 函式指標陣列

```c
// 計算機範例
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int div(int a, int b) { return a / b; }

int main() {
    // 函式指標陣列
    int (*operations[4])(int, int) = {add, sub, mul, div};
    char *names[] = {"add", "sub", "mul", "div"};
    
    int a = 10, b = 3;
    for (int i = 0; i < 4; i++) {
        printf("%s(%d, %d) = %d\n", names[i], a, b, operations[i](a, b));
    }
    
    return 0;
}
```

---

## 🔷 動態記憶體管理

### malloc / calloc / realloc / free

```c
#include <stdlib.h>

// malloc：分配未初始化的記憶體
int *p1 = (int*)malloc(10 * sizeof(int));
// 內容是垃圾值

// calloc：分配並初始化為 0
int *p2 = (int*)calloc(10, sizeof(int));
// 內容全是 0

// realloc：重新分配大小
p1 = (int*)realloc(p1, 20 * sizeof(int));
// 擴大到 20 個 int

// free：釋放記憶體
free(p1);
free(p2);

// 重要！free 後將指標設為 NULL
p1 = NULL;
p2 = NULL;
```

### 常見錯誤

```c
// 錯誤 1：Memory Leak（記憶體洩漏）
void func() {
    int *p = (int*)malloc(10 * sizeof(int));
    // 沒有 free 就 return 了！
    return;
}

// 錯誤 2：Use After Free
int *p = (int*)malloc(sizeof(int));
*p = 10;
free(p);
*p = 20;  // 危險！p 已經被 free 了

// 錯誤 3：Double Free
int *p = (int*)malloc(sizeof(int));
free(p);
free(p);  // 危險！重複 free

// 錯誤 4：野指標（未初始化的指標）
int *p;
*p = 10;  // 危險！p 沒有指向有效記憶體
```

---

## 🔷 記憶體佈局

### Stack vs Heap

```
Stack（堆疊）：
- 自動管理
- LIFO（後進先出）
- 大小有限（通常 1-8 MB）
- 存放：區域變數、函式參數、返回位址

Heap（堆積）：
- 手動管理（malloc/free）
- 大小較大（可達數 GB）
- 存放：動態分配的資料

記憶體佈局：
┌─────────────────┐ 高位址
│     Stack       │ ↓ 向下成長
├─────────────────┤
│       ↓         │
│                 │
│       ↑         │
├─────────────────┤
│     Heap        │ ↑ 向上成長
├─────────────────┤
│     BSS         │ 未初始化全域變數
├─────────────────┤
│     Data        │ 已初始化全域變數
├─────────────────┤
│     Text        │ 程式碼
└─────────────────┘ 低位址
```

### 變數的存放位置

```c
int global_init = 100;     // Data section
int global_uninit;         // BSS section
static int static_var = 5; // Data section

void func() {
    int local = 10;                    // Stack
    static int static_local = 20;      // Data section
    int *heap_ptr = (int*)malloc(4);   // 指標在 Stack，指向的資料在 Heap
    char *str = "Hello";               // 指標在 Stack，字串常量在 Text/Rodata
}
```

---

## 📝 面試高頻問題

**Q1：`int *p` 和 `int* p` 有什麼差別？**
```c
// 語意上沒有差別，都是指向 int 的指標
// 但風格不同

// 風格 1：* 靠近變數名
int *p, *q;  // p 和 q 都是指標

// 風格 2：* 靠近型別名
int* p, q;   // 只有 p 是指標，q 是 int！

// 建議：每行只宣告一個變數
int *p;
int *q;
```

**Q2：NULL 和 野指標？**
```c
// NULL 指標：明確指向「空」
int *p = NULL;
if (p == NULL) {
    // 可以安全檢查
}

// 野指標：未初始化，指向未知位址
int *q;  // q 的值是垃圾，指向未知位址
*q = 10; // 危險！可能造成 segfault 或記憶體損壞
```

**Q3：const 和指標**
```c
const int *p;       // 不能透過 p 修改值，但 p 可以指向別的地方
int * const p;      // p 不能指向別的地方，但可以透過 p 修改值
const int * const p;// 都不行

// 記憶方法：const 在 * 左邊 → 值不可改
//           const 在 * 右邊 → 指標不可改
```
