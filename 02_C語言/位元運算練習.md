# ğŸ”¢ ä½å…ƒé‹ç®—é€²éšè©³è§£

> **å­¸ç¿’ç›®æ¨™**
> å®Œæˆæœ¬ç« å¾Œï¼Œä½ æ‡‰è©²èƒ½å¤ ï¼š
> 1. ç²¾é€šæ‰€æœ‰ä½å…ƒé‹ç®—å­çš„åº•å±¤åŸç†èˆ‡æ‡‰ç”¨å ´æ™¯
> 2. ç†Ÿç·´ä½¿ç”¨ Bit Manipulation æŠ€å·§è§£æ±ºæ¼”ç®—æ³•å•é¡Œ
> 3. æŒæ¡ Bit Field åœ¨ç¡¬é«”æš«å­˜å™¨æ“ä½œä¸­çš„å¯¦å‹™æ‡‰ç”¨
> 4. ç†è§£æœ‰è™Ÿæ•¸èˆ‡ç„¡è™Ÿæ•¸çš„ä½å…ƒé‹ç®—é™·é˜±
> 5. åœ¨é¢è©¦ä¸­è‡ªä¿¡åœ°æ‰‹å¯«å„ç¨®ç¶“å…¸ä½å…ƒé‹ç®—é¡Œç›®

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šä½å…ƒé‹ç®—å­å®Œæ•´è§£æ

### 1.1 ä½å…ƒé‹ç®—å­ç¸½è¦½

| é‹ç®—å­ | åç¨± | èªªæ˜ | ç¯„ä¾‹ |
|:------:|:-----|:-----|:-----|
| `&` | AND | å…©è€…éƒ½æ˜¯ 1 æ‰æ˜¯ 1 | `0b1100 & 0b1010 = 0b1000` |
| `\|` | OR | ä»»ä¸€ç‚º 1 å°±æ˜¯ 1 | `0b1100 \| 0b1010 = 0b1110` |
| `^` | XOR | ä¸åŒç‚º 1ï¼Œç›¸åŒç‚º 0 | `0b1100 ^ 0b1010 = 0b0110` |
| `~` | NOT | 0 å’Œ 1 äº’æ›ï¼ˆä¸€å…ƒé‹ç®—ï¼‰ | `~0b1100 = 0b0011` (ç°¡åŒ–) |
| `<<` | å·¦ç§» | å‘å·¦ç§»å‹• bitï¼Œå³é‚Šè£œ 0 | `0b0011 << 2 = 0b1100` |
| `>>` | å³ç§» | å‘å³ç§»å‹• bit | `0b1100 >> 2 = 0b0011` |

### 1.2 çœŸå€¼è¡¨æ·±å…¥ç†è§£

```
     a    b   a&b   a|b   a^b   ~a
     0    0    0     0     0     1
     0    1    0     1     1     1
     1    0    0     1     1     0
     1    1    1     1     0     0
```

**è¨˜æ†¶æŠ€å·§**ï¼š
- `&` (AND)ï¼šã€Œéƒ½è¦ã€æ‰çµ¦ 1
- `|` (OR)ï¼šã€Œæœ‰å°±ã€çµ¦ 1
- `^` (XOR)ï¼šã€Œä¸åŒã€æ‰çµ¦ 1ï¼ˆä¹Ÿå¯è¦–ç‚ºã€Œä¸é€²ä½åŠ æ³•ã€ï¼‰

### 1.3 ä½å…ƒé‹ç®—çš„æ•¸å­¸æ„ç¾©

```c
// å·¦ç§» n ä½ = ä¹˜ä»¥ 2^n
unsigned int x = 5;      // 0b0101
x << 1;  // = 10 = 5 * 2^1
x << 3;  // = 40 = 5 * 2^3

// å³ç§» n ä½ = é™¤ä»¥ 2^nï¼ˆå–æ•´æ•¸éƒ¨åˆ†ï¼‰
unsigned int y = 40;     // 0b101000
y >> 1;  // = 20 = 40 / 2
y >> 3;  // = 5  = 40 / 8

// âš ï¸ æ³¨æ„ï¼šé€™åªé©ç”¨æ–¼ç„¡è™Ÿæ•¸ï¼æœ‰è™Ÿæ•¸çš„å³ç§»è¡Œç‚ºä¸åŒï¼ˆè¦‹ä¸‹æ–‡ï¼‰
```

### 1.4 æœ‰è™Ÿæ•¸ vs ç„¡è™Ÿæ•¸çš„å³ç§»

é€™æ˜¯é¢è©¦å¸¸è¦‹çš„é™·é˜±é¡Œï¼

```c
// ç„¡è™Ÿæ•¸å³ç§»ï¼šé‚è¼¯å³ç§»ï¼ˆå·¦é‚Šè£œ 0ï¼‰
unsigned int u = 0x80000000;  // æœ€é«˜ä½æ˜¯ 1
u >> 1;  // = 0x40000000ï¼ˆå·¦é‚Šè£œ 0ï¼‰

// æœ‰è™Ÿæ•¸å³ç§»ï¼šç®—è¡“å³ç§»ï¼ˆå·¦é‚Šè£œç¬¦è™Ÿä½ï¼‰
int s = 0x80000000;  // -2147483648ï¼ˆè² æ•¸ï¼‰
s >> 1;  // = 0xC0000000 = -1073741824ï¼ˆå·¦é‚Šè£œ 1ï¼‰

// åœ–è§£ï¼š
// ç„¡è™Ÿæ•¸ï¼š0b10000000... >> 1 = 0b01000000...
// æœ‰è™Ÿæ•¸ï¼š0b10000000... >> 1 = 0b11000000... (ç¬¦è™Ÿä½æ“´å±•)

// âš ï¸ æœ€ä½³å¯¦è¸ï¼šä½å…ƒé‹ç®—ç¸½æ˜¯ä½¿ç”¨ unsigned å‹åˆ¥ï¼
```

### 1.5 NOT é‹ç®—å­çš„é™·é˜±

```c
unsigned char a = 0b11001010;  // 8-bit: 202

// ~a æœƒåšã€Œæ•´æ•¸æå‡ã€(Integer Promotion)
// åœ¨ 32-bit ç³»çµ±ä¸Šï¼š
// ~a = ~(0x000000CA) = 0xFFFFFF35

// å¦‚æœåªæƒ³è¦ 8-bit çš„çµæœï¼š
unsigned char result = (unsigned char)~a;  // 0x35 = 53

// æˆ–ä½¿ç”¨æ˜ç¢ºçš„é®ç½©ï¼š
unsigned char result2 = ~a & 0xFF;  // 0x35
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šäº”å¤§æ ¸å¿ƒæ“ä½œ

åµŒå…¥å¼é–‹ç™¼ä¸­ï¼Œé€™äº”å€‹æ“ä½œæ˜¯æœ€åŸºæœ¬ä¹Ÿæ˜¯æœ€é‡è¦çš„æŠ€èƒ½ã€‚

### 2.1 SET bitï¼ˆè¨­å®šç‰¹å®š bit ç‚º 1ï¼‰

```c
// è¨­å®šç¬¬ n bit ç‚º 1
// å…¬å¼ï¼švalue |= (1 << n)
// åŸç†ï¼š1 << n ç”¢ç”Ÿåªæœ‰ç¬¬ n bit æ˜¯ 1 çš„é®ç½©ï¼ŒOR é‹ç®—æŠŠè©² bit è¨­ç‚º 1

unsigned char reg = 0b00000000;
reg |= (1 << 3);  // è¨­å®š bit 3
// çµæœï¼š0b00001000

// å±•é–‹éç¨‹ï¼š
// 1 << 3       = 0b00001000
// 0b00000000 | 0b00001000 = 0b00001000

// è¨­å®šå¤šå€‹ bit
reg |= (1 << 5) | (1 << 7);  // åŒæ™‚è¨­å®š bit 5 å’Œ bit 7
// çµæœï¼š0b10101000
```

### 2.2 CLEAR bitï¼ˆæ¸…é™¤ç‰¹å®š bit ç‚º 0ï¼‰

```c
// æ¸…é™¤ç¬¬ n bit ç‚º 0
// å…¬å¼ï¼švalue &= ~(1 << n)
// åŸç†ï¼š~(1 << n) ç”¢ç”Ÿé™¤äº†ç¬¬ n bit å…¶ä»–éƒ½æ˜¯ 1 çš„é®ç½©ï¼ŒAND é‹ç®—æŠŠè©² bit æ¸…ç‚º 0

unsigned char reg = 0b11111111;
reg &= ~(1 << 5);  // æ¸…é™¤ bit 5
// çµæœï¼š0b11011111

// å±•é–‹éç¨‹ï¼š
// 1 << 5       = 0b00100000
// ~(1 << 5)    = 0b11011111
// 0b11111111 & 0b11011111 = 0b11011111

// æ¸…é™¤å¤šå€‹ bit
reg &= ~((1 << 3) | (1 << 7));  // åŒæ™‚æ¸…é™¤ bit 3 å’Œ bit 7
```

### 2.3 TOGGLE bitï¼ˆåˆ‡æ›ç‰¹å®š bitï¼‰

```c
// åˆ‡æ›ç¬¬ n bitï¼ˆ0 è®Š 1ï¼Œ1 è®Š 0ï¼‰
// å…¬å¼ï¼švalue ^= (1 << n)
// åŸç†ï¼šXOR çš„ç‰¹æ€§æ˜¯ã€Œèˆ‡ 1 åš XOR æœƒç¿»è½‰ã€

unsigned char reg = 0b00000100;  // bit 2 æ˜¯ 1
reg ^= (1 << 2);  // åˆ‡æ› bit 2
// çµæœï¼š0b00000000ï¼ˆ1 è®Š 0ï¼‰

reg ^= (1 << 2);  // å†åˆ‡æ› bit 2
// çµæœï¼š0b00000100ï¼ˆ0 è®Š 1ï¼‰

// XOR çš„ç‰¹æ€§ï¼š
// 0 ^ 1 = 1
// 1 ^ 1 = 0
```

### 2.4 CHECK bitï¼ˆæª¢æŸ¥ç‰¹å®š bitï¼‰

```c
// æª¢æŸ¥ç¬¬ n bit æ˜¯å¦ç‚º 1
// å…¬å¼ï¼š(value & (1 << n)) != 0
// æˆ–ç°¡å¯«ï¼švalue & (1 << n)ï¼ˆåœ¨ if æ¢ä»¶ä¸­ï¼‰

unsigned char reg = 0b00101000;  // bit 3 å’Œ bit 5 æ˜¯ 1

// æ–¹æ³• 1ï¼šç”¨æ–¼ if æ¢ä»¶
if (reg & (1 << 3)) {
    printf("Bit 3 is set\n");  // æœƒå°å‡º
}
if (reg & (1 << 2)) {
    printf("Bit 2 is set\n");  // ä¸æœƒå°å‡º
}

// æ–¹æ³• 2ï¼šå–å¾— bit çš„å€¼ï¼ˆ0 æˆ– 1ï¼‰
int bit3 = (reg >> 3) & 1;  // = 1
int bit2 = (reg >> 2) & 1;  // = 0
```

### 2.5 MODIFY fieldï¼ˆä¿®æ”¹å¤šå€‹é€£çºŒ bitï¼‰

é€™æ˜¯ç¡¬é«”æš«å­˜å™¨æ“ä½œä¸­æœ€å¯¦ç”¨çš„æŠ€å·§ï¼

```c
// å‡è¨­æš«å­˜å™¨çš„ bit 7-4 æ˜¯ MODE æ¬„ä½ï¼Œbit 3-0 æ˜¯ VALUE æ¬„ä½
// è¦è¨­å®š MODE = 5, VALUE = 3

#define MODE_MASK    0xF0   // 0b11110000
#define MODE_SHIFT   4
#define VALUE_MASK   0x0F   // 0b00001111
#define VALUE_SHIFT  0

unsigned char reg = 0xFF;  // åŸå§‹å€¼

// Step 1: æ¸…é™¤ MODE æ¬„ä½
reg &= ~MODE_MASK;  // reg = 0x0F

// Step 2: è¨­å®š MODE = 5
reg |= (5 << MODE_SHIFT) & MODE_MASK;  // reg = 0x5F

// Step 3: æ¸…é™¤ VALUE æ¬„ä½
reg &= ~VALUE_MASK;  // reg = 0x50

// Step 4: è¨­å®š VALUE = 3
reg |= (3 << VALUE_SHIFT) & VALUE_MASK;  // reg = 0x53

// åˆä½µæˆä¸€è¡Œï¼š
reg = (reg & ~MODE_MASK & ~VALUE_MASK) | 
      ((5 << MODE_SHIFT) & MODE_MASK) | 
      ((3 << VALUE_SHIFT) & VALUE_MASK);
```

### 2.6 æ¨™æº–å·¨é›†å®šç¾©

```c
// å–®ä¸€ bit æ“ä½œ
#define SET_BIT(reg, n)      ((reg) |= (1U << (n)))
#define CLEAR_BIT(reg, n)    ((reg) &= ~(1U << (n)))
#define TOGGLE_BIT(reg, n)   ((reg) ^= (1U << (n)))
#define CHECK_BIT(reg, n)    ((reg) & (1U << (n)))
#define GET_BIT(reg, n)      (((reg) >> (n)) & 1U)

// å¤š bit / æ¬„ä½æ“ä½œ
#define SET_BITS(reg, mask)      ((reg) |= (mask))
#define CLEAR_BITS(reg, mask)    ((reg) &= ~(mask))
#define TOGGLE_BITS(reg, mask)   ((reg) ^= (mask))

// è®€å–/å¯«å…¥æ¬„ä½
#define GET_FIELD(reg, mask, shift)  (((reg) & (mask)) >> (shift))
#define SET_FIELD(reg, mask, shift, val) \
    ((reg) = ((reg) & ~(mask)) | (((val) << (shift)) & (mask)))

// ä½¿ç”¨ç¯„ä¾‹ï¼š
uint8_t reg = 0xFF;
SET_FIELD(reg, MODE_MASK, MODE_SHIFT, 5);  // è¨­å®š MODE = 5
uint8_t mode = GET_FIELD(reg, MODE_MASK, MODE_SHIFT);  // è®€å– MODE
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šç¶“å…¸ Bit Manipulation æŠ€å·§

é€™äº›æŠ€å·§æ˜¯é¢è©¦ç†±é–€é¡Œç›®ï¼Œä¹Ÿæ˜¯é«˜æ•ˆèƒ½ç¨‹å¼è¨­è¨ˆçš„åŸºç¤ã€‚

### 3.1 åˆ¤æ–·æ˜¯å¦ç‚º 2 çš„å†ªæ¬¡

```c
// 2 çš„å†ªæ¬¡åœ¨äºŒé€²ä½ä¸­åªæœ‰ä¸€å€‹ bit æ˜¯ 1
// 8   = 0b00001000
// 16  = 0b00010000
// 32  = 0b00100000

// æŠ€å·§ï¼šn & (n - 1) æœƒæ¶ˆé™¤æœ€ä½ä½çš„ 1
// 8     = 0b00001000
// 8 - 1 = 0b00000111
// 8 & 7 = 0b00000000  â†’ åªæœ‰ä¸€å€‹ 1ï¼Œæ‰€ä»¥çµæœæ˜¯ 0

int isPowerOfTwo(unsigned int n) {
    return n != 0 && (n & (n - 1)) == 0;
}

// ç‚ºä»€éº¼ n != 0 å¾ˆé‡è¦ï¼Ÿ
// 0 & (0 - 1) = 0 & 0xFFFFFFFF = 0ï¼Œæœƒèª¤åˆ¤ç‚º true
```

### 3.2 è¨ˆç®— 1 çš„å€‹æ•¸ï¼ˆPopulation Count / Hamming Weightï¼‰

```c
// æ–¹æ³• 1ï¼šé€ä½æª¢æŸ¥ï¼ˆO(log n)ï¼‰
int popcount_v1(unsigned int n) {
    int count = 0;
    while (n) {
        count += (n & 1);  // æª¢æŸ¥æœ€ä½ä½
        n >>= 1;           // å³ç§»
    }
    return count;
}

// æ–¹æ³• 2ï¼šBrian Kernighan æ¼”ç®—æ³•ï¼ˆO(k)ï¼Œk æ˜¯ 1 çš„å€‹æ•¸ï¼‰
int popcount_v2(unsigned int n) {
    int count = 0;
    while (n) {
        n = n & (n - 1);  // æ¶ˆé™¤æœ€ä½ä½çš„ 1
        count++;
    }
    return count;
}

// æ–¹æ³• 3ï¼šæŸ¥è¡¨æ³•ï¼ˆO(1)ï¼Œä½†éœ€è¦é¡å¤–ç©ºé–“ï¼‰
static const int lookup[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, ... // é å…ˆè¨ˆç®— 0-255 å„æœ‰å¤šå°‘å€‹ 1
};

int popcount_v3(unsigned int n) {
    return lookup[n & 0xFF] +
           lookup[(n >> 8) & 0xFF] +
           lookup[(n >> 16) & 0xFF] +
           lookup[(n >> 24) & 0xFF];
}

// æ–¹æ³• 4ï¼šGCC/Clang å…§å»ºå‡½å¼ï¼ˆæœ€å¿«ï¼Œç·¨è­¯å™¨æœƒç”¨ç¡¬é«”æŒ‡ä»¤ï¼‰
int popcount_v4(unsigned int n) {
    return __builtin_popcount(n);  // ARM: VCNT, x86: POPCNT
}
```

### 3.3 åè½‰ bit é †åº

```c
// 8-bit åè½‰
unsigned char reverseBits8(unsigned char n) {
    unsigned char result = 0;
    for (int i = 0; i < 8; i++) {
        result <<= 1;        // result å·¦ç§»ä¸€ä½
        result |= (n & 1);   // å– n çš„æœ€ä½ä½åŠ åˆ° result
        n >>= 1;             // n å³ç§»ä¸€ä½
    }
    return result;
}

// 32-bit åè½‰ï¼ˆåˆ†æ²»æ³•ï¼Œæ›´å¿«ï¼‰
unsigned int reverseBits32(unsigned int n) {
    n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);  // ç›¸é„° 1-bit äº¤æ›
    n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2);  // ç›¸é„° 2-bit äº¤æ›
    n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4);  // ç›¸é„° 4-bit äº¤æ›
    n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8);  // ç›¸é„° 8-bit äº¤æ›
    n = (n << 16) | (n >> 16);                              // å‰å¾Œ 16-bit äº¤æ›
    return n;
}

// åœ–è§£ 8-bit ç‰ˆæœ¬ï¼š
// åŸå§‹ï¼š    0b10110100
// æ­¥é©Ÿ 1ï¼š  0b01101001  (ç›¸é„° 1-bit äº¤æ›)
// æ­¥é©Ÿ 2ï¼š  0b10010110  (ç›¸é„° 2-bit äº¤æ›)
// çµæœï¼š    0b00101101
```

### 3.4 æ‰¾å‡ºåªå‡ºç¾ä¸€æ¬¡çš„æ•¸å­—ï¼ˆXOR æŠ€å·§ï¼‰

```c
// é™£åˆ—ä¸­æ¯å€‹æ•¸å­—éƒ½å‡ºç¾å…©æ¬¡ï¼Œåªæœ‰ä¸€å€‹å‡ºç¾ä¸€æ¬¡
// ä¾‹å¦‚ï¼š{2, 3, 5, 3, 2} â†’ 5

int findSingle(int arr[], int size) {
    int result = 0;
    for (int i = 0; i < size; i++) {
        result ^= arr[i];
    }
    return result;
}

// åŸç†ï¼š
// a ^ a = 0 ï¼ˆç›¸åŒæ•¸å­— XOR æœƒæ¶ˆé™¤ï¼‰
// a ^ 0 = a
// XOR æ»¿è¶³äº¤æ›å¾‹å’Œçµåˆå¾‹
// æ‰€ä»¥ 2^3^5^3^2 = (2^2)^(3^3)^5 = 0^0^5 = 5
```

### 3.5 ä¸ç”¨è‡¨æ™‚è®Šæ•¸äº¤æ›å…©å€‹æ•¸

```c
void swap(int *a, int *b) {
    *a = *a ^ *b;  // a = a XOR b
    *b = *a ^ *b;  // b = (a XOR b) XOR b = a
    *a = *a ^ *b;  // a = (a XOR b) XOR a = b
}

// æ•¸å­¸è­‰æ˜ï¼ˆå‡è¨­åŸå§‹å€¼ç‚º A, Bï¼‰ï¼š
// Step 1: a = A ^ B
// Step 2: b = (A ^ B) ^ B = A ^ (B ^ B) = A ^ 0 = A
// Step 3: a = (A ^ B) ^ A = (A ^ A) ^ B = 0 ^ B = B

// âš ï¸ æ³¨æ„ï¼šå¦‚æœ a å’Œ b æŒ‡å‘åŒä¸€ä½å€æœƒæœ‰å•é¡Œï¼
// *a ^ *a = 0ï¼Œçµæœå…©è€…éƒ½è®Šæˆ 0
void swap_safe(int *a, int *b) {
    if (a != b) {  // æª¢æŸ¥æ˜¯å¦æŒ‡å‘åŒä¸€ä½å€
        *a = *a ^ *b;
        *b = *a ^ *b;
        *a = *a ^ *b;
    }
}
```

### 3.6 å–å¾—æœ€ä½ä½çš„ 1ï¼ˆIsolate Lowest Set Bitï¼‰

```c
// å–å¾—æ•¸å­—æœ€ä½ä½çš„ 1
// ä¾‹å¦‚ï¼š0b01010100 â†’ 0b00000100

unsigned int lowestSetBit(unsigned int n) {
    return n & (-n);
}

// åŸç†ï¼š
// -n æ˜¯ n çš„äºŒè£œæ•¸ï¼Œç­‰æ–¼ ~n + 1
// n  = 0b01010100
// ~n = 0b10101011
// -n = 0b10101100
//
// n & -n = 0b01010100 & 0b10101100 = 0b00000100

// æ‡‰ç”¨ï¼šBinary Indexed Tree (Fenwick Tree)
```

### 3.7 æ¸…é™¤æœ€ä½ä½çš„ 1ï¼ˆClear Lowest Set Bitï¼‰

```c
// æ¸…é™¤æ•¸å­—æœ€ä½ä½çš„ 1
// ä¾‹å¦‚ï¼š0b01010100 â†’ 0b01010000

unsigned int clearLowestSetBit(unsigned int n) {
    return n & (n - 1);
}

// é€™å°±æ˜¯ Brian Kernighan æ¼”ç®—æ³•çš„æ ¸å¿ƒï¼
```

### 3.8 å–å¾—æœ€ä½ä½çš„ 0 ä»¥ä¸‹çš„éƒ¨åˆ†

```c
// è¨­å®šæœ€ä½ä½çš„ 0 ç‚º 1
// ä¾‹å¦‚ï¼š0b10100111 â†’ 0b10101111

unsigned int setLowestZeroBit(unsigned int n) {
    return n | (n + 1);
}
```

### 3.9 åˆ¤æ–·å…©å€‹æ•¸å­—çš„ç¬¦è™Ÿæ˜¯å¦ç›¸åŒ

```c
// åˆ©ç”¨ XORï¼šå¦‚æœç¬¦è™Ÿç›¸åŒï¼Œæœ€é«˜ä½ XOR çµæœæ˜¯ 0
int sameSign(int a, int b) {
    return (a ^ b) >= 0;
}

// åŸç†ï¼š
// æ­£æ•¸çš„æœ€é«˜ä½æ˜¯ 0ï¼Œè² æ•¸çš„æœ€é«˜ä½æ˜¯ 1
// 0 ^ 0 = 0, 1 ^ 1 = 0 â†’ çµæœç‚ºæ­£æ•¸æˆ–é›¶
// 0 ^ 1 = 1, 1 ^ 0 = 1 â†’ çµæœç‚ºè² æ•¸
```

### 3.10 è¨ˆç®—çµ•å°å€¼ï¼ˆä¸ç”¨åˆ†æ”¯ï¼‰

```c
// å‚³çµ±æ–¹æ³•ï¼ˆæœ‰åˆ†æ”¯ï¼‰
int abs_v1(int n) {
    return n >= 0 ? n : -n;
}

// ç„¡åˆ†æ”¯æ–¹æ³•ï¼ˆé¿å… branch mispredictionï¼‰
int abs_v2(int n) {
    int mask = n >> 31;  // å…¨ 0ï¼ˆæ­£æ•¸ï¼‰æˆ–å…¨ 1ï¼ˆè² æ•¸ï¼‰
    return (n + mask) ^ mask;
}

// è§£é‡‹ï¼š
// æ­£æ•¸ï¼šmask = 0x00000000
//       (n + 0) ^ 0 = n
// è² æ•¸ï¼šmask = 0xFFFFFFFF
//       (n + 0xFFFFFFFF) ^ 0xFFFFFFFF = (n - 1) ^ 0xFFFFFFFF = ~(n - 1) = -n
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šé€²éš Bit Manipulation

### 4.1 Log2 è¨ˆç®—ï¼ˆæ‰¾æœ€é«˜ä½çš„ 1ï¼‰

```c
// æ–¹æ³• 1ï¼šé€ä½æŸ¥æ‰¾
int log2_v1(unsigned int n) {
    int log = 0;
    while (n >>= 1) {
        log++;
    }
    return log;
}

// æ–¹æ³• 2ï¼šäºŒåˆ†æŸ¥æ‰¾ï¼ˆæ›´å¿«ï¼‰
int log2_v2(unsigned int n) {
    int log = 0;
    if (n >= (1 << 16)) { n >>= 16; log += 16; }
    if (n >= (1 << 8))  { n >>= 8;  log += 8;  }
    if (n >= (1 << 4))  { n >>= 4;  log += 4;  }
    if (n >= (1 << 2))  { n >>= 2;  log += 2;  }
    if (n >= (1 << 1))  { log += 1; }
    return log;
}

// æ–¹æ³• 3ï¼šGCC å…§å»ºå‡½å¼
int log2_v3(unsigned int n) {
    return 31 - __builtin_clz(n);  // clz = count leading zeros
}
```

### 4.2 å‘ä¸Š/å‘ä¸‹å°é½Šåˆ° 2 çš„å†ªæ¬¡

```c
// å‘ä¸‹å°é½Šï¼ˆfloorï¼‰ï¼šæ‰¾å°æ–¼ç­‰æ–¼ n çš„æœ€å¤§ 2 çš„å†ªæ¬¡
unsigned int floorPowerOf2(unsigned int n) {
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n - (n >> 1);
}

// å‘ä¸Šå°é½Šï¼ˆceilingï¼‰ï¼šæ‰¾å¤§æ–¼ç­‰æ–¼ n çš„æœ€å° 2 çš„å†ªæ¬¡
unsigned int ceilPowerOf2(unsigned int n) {
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n++;
    return n;
}

// ç¯„ä¾‹ï¼š
// floorPowerOf2(10) = 8
// ceilPowerOf2(10) = 16
```

### 4.3 è¨ˆç®—å°¾éš¨é›¶çš„æ•¸é‡ï¼ˆTrailing Zerosï¼‰

```c
// ä¾‹å¦‚ï¼š0b01010100 æœ‰ 2 å€‹å°¾éš¨é›¶

// æ–¹æ³• 1ï¼šé€ä½æŸ¥æ‰¾
int trailingZeros_v1(unsigned int n) {
    if (n == 0) return 32;  // ç´„å®š
    int count = 0;
    while ((n & 1) == 0) {
        count++;
        n >>= 1;
    }
    return count;
}

// æ–¹æ³• 2ï¼šä½¿ç”¨ lowest set bit
int trailingZeros_v2(unsigned int n) {
    if (n == 0) return 32;
    return __builtin_popcount((n & -n) - 1);
}

// æ–¹æ³• 3ï¼šGCC å…§å»ºå‡½å¼
int trailingZeros_v3(unsigned int n) {
    if (n == 0) return 32;
    return __builtin_ctz(n);  // ctz = count trailing zeros
}
```

### 4.4 æ—‹è½‰ä½å…ƒï¼ˆRotateï¼‰

```c
// å·¦æ—‹è½‰ï¼šé«˜ä½ç§»å‡ºçš„è£œåˆ°ä½ä½
unsigned int rotateLeft(unsigned int n, int k) {
    k &= 31;  // ç¢ºä¿ k åœ¨ 0-31 ç¯„åœ
    return (n << k) | (n >> (32 - k));
}

// å³æ—‹è½‰ï¼šä½ä½ç§»å‡ºçš„è£œåˆ°é«˜ä½
unsigned int rotateRight(unsigned int n, int k) {
    k &= 31;
    return (n >> k) | (n << (32 - k));
}

// ç¯„ä¾‹ï¼ˆ8-bit ç°¡åŒ–ï¼‰ï¼š
// rotateLeft(0b11010010, 3) = 0b10010110
```

### 4.5 ä½å…ƒäº¤å‰ï¼ˆInterleave / Morton Codeï¼‰

```c
// å°‡å…©å€‹ 16-bit æ•¸å­—äº¤å‰æˆä¸€å€‹ 32-bit æ•¸å­—
// ä¾‹å¦‚ï¼šx = 0b1010, y = 0b1100 â†’ 0b11011000

unsigned int interleave(unsigned int x, unsigned int y) {
    // å±•é–‹ x
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;
    
    // å±•é–‹ y
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;
    
    return x | (y << 1);
}

// æ‡‰ç”¨ï¼šç©ºé–“ç´¢å¼•ï¼ˆQuadtreeã€Octreeï¼‰ã€Z-order curve
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šç¡¬é«”æš«å­˜å™¨æ“ä½œå¯¦å‹™

### 5.1 Memory-Mapped I/O åŸºç¤

```c
// åœ¨åµŒå…¥å¼ç³»çµ±ä¸­ï¼Œç¡¬é«”æš«å­˜å™¨è¢«æ˜ å°„åˆ°ç‰¹å®šçš„è¨˜æ†¶é«”ä½å€
// è®€å¯«é€™äº›ä½å€å°±ç­‰æ–¼æ“ä½œç¡¬é«”

// å®šç¾©æš«å­˜å™¨ä½å€
#define GPIO_BASE       0x40020000
#define GPIO_MODER      (*(volatile uint32_t *)(GPIO_BASE + 0x00))
#define GPIO_ODR        (*(volatile uint32_t *)(GPIO_BASE + 0x14))
#define GPIO_IDR        (*(volatile uint32_t *)(GPIO_BASE + 0x10))

// è§£é‡‹ï¼š
// 1. 0x40020000: æš«å­˜å™¨çš„ç‰©ç†ä½å€
// 2. (volatile uint32_t *): è½‰å‹ç‚ºæŒ‡å‘ 32-bit çš„ volatile æŒ‡æ¨™
// 3. volatile: å‘Šè¨´ç·¨è­¯å™¨ä¸è¦å„ªåŒ–ï¼Œæ¯æ¬¡éƒ½è¦çœŸæ­£è®€å¯«è¨˜æ†¶é«”
// 4. *: è§£å¼•ç”¨ï¼Œè®“å·¨é›†å¯ä»¥åƒè®Šæ•¸ä¸€æ¨£ä½¿ç”¨

// ä½¿ç”¨ç¯„ä¾‹ï¼š
GPIO_MODER |= (1 << 10);   // è¨­å®š bit 10
GPIO_ODR &= ~(1 << 5);     // æ¸…é™¤ bit 5
if (GPIO_IDR & (1 << 3)) { // æª¢æŸ¥ bit 3
    // ...
}
```

### 5.2 ä½¿ç”¨çµæ§‹é«”å­˜å–æš«å­˜å™¨

```c
// æ›´å„ªé›…çš„æ–¹å¼ï¼šå®šç¾©æš«å­˜å™¨çµæ§‹

typedef struct {
    volatile uint32_t MODER;    // 0x00
    volatile uint32_t OTYPER;   // 0x04
    volatile uint32_t OSPEEDR;  // 0x08
    volatile uint32_t PUPDR;    // 0x0C
    volatile uint32_t IDR;      // 0x10
    volatile uint32_t ODR;      // 0x14
    volatile uint32_t BSRR;     // 0x18
    volatile uint32_t LCKR;     // 0x1C
    volatile uint32_t AFR[2];   // 0x20, 0x24
} GPIO_TypeDef;

#define GPIOA   ((GPIO_TypeDef *)0x40020000)
#define GPIOB   ((GPIO_TypeDef *)0x40020400)

// ä½¿ç”¨ç¯„ä¾‹ï¼š
GPIOA->MODER |= (1 << 10);
GPIOA->ODR |= (1 << 5);
```

### 5.3 ä½¿ç”¨ union èˆ‡ Bit Field

```c
// æœ€å„ªé›…çš„æ–¹å¼ï¼šunion + bit field

typedef union {
    uint32_t raw;                  // ä¸€æ¬¡è®€å¯«æ•´å€‹æš«å­˜å™¨
    struct {
        uint32_t value    : 4;     // bit 0-3
        uint32_t mode     : 4;     // bit 4-7
        uint32_t enable   : 1;     // bit 8
        uint32_t status   : 3;     // bit 9-11
        uint32_t reserved : 20;    // bit 12-31ï¼ˆä¿ç•™ï¼‰
    } bits;
} MyRegister_t;

volatile MyRegister_t *reg = (volatile MyRegister_t *)0x40000000;

// å„ªé» 1ï¼šå¯ä»¥ç›´æ¥æ“ä½œæ¬„ä½ï¼Œä¸éœ€è¦æ‰‹å‹• shift å’Œ mask
reg->bits.mode = 5;      // è¨­å®š mode = 5
reg->bits.enable = 1;    // è¨­å®š enable = 1

// å„ªé» 2ï¼šå¯ä»¥ä¸€æ¬¡è®€å¯«æ•´å€‹æš«å­˜å™¨
reg->raw = 0x00000000;   // å…¨éƒ¨æ¸…é›¶
uint32_t val = reg->raw; // è®€å–æ•´å€‹æš«å­˜å™¨

// å„ªé» 3ï¼šDebugger å¯ä»¥ç›´æ¥é¡¯ç¤ºå„æ¬„ä½çš„å€¼
```

### 5.4 Bit Field çš„æ³¨æ„äº‹é …

```c
// âš ï¸ Bit Field çš„å¯¦ä½œæ˜¯ã€Œå¯¦ä½œå®šç¾©ã€(implementation-defined)

// å•é¡Œ 1ï¼šä½å…ƒé †åºå¯èƒ½ä¸åŒ
// æœ‰äº›ç·¨è­¯å™¨å¾ LSB é–‹å§‹åˆ†é…ï¼Œæœ‰äº›å¾ MSB é–‹å§‹
// é€™æœƒå½±éŸ¿åˆ°è·¨å¹³å°çš„äºŒé€²ä½ç›¸å®¹æ€§

// å•é¡Œ 2ï¼šå¡«å……è¡Œç‚ºä¸ç¢ºå®š
// ç·¨è­¯å™¨å¯èƒ½åœ¨æ¬„ä½ä¹‹é–“æ’å…¥ padding

// å•é¡Œ 3ï¼šåŸå­æ€§
// è¨­å®šä¸€å€‹ bit field å¯èƒ½éœ€è¦ read-modify-write
// åœ¨å¤šåŸ·è¡Œç·’æˆ–ä¸­æ–·ç’°å¢ƒä¸­å¯èƒ½æœ‰ race condition

// æœ€ä½³å¯¦è¸ï¼š
// 1. åªåœ¨å–®ä¸€ç·¨è­¯å™¨/å¹³å°ä¸Šä½¿ç”¨ bit field å­˜å–æš«å­˜å™¨
// 2. ä½¿ç”¨æ˜ç¢ºçš„ shift å’Œ mask æ“ä½œä¾†ç¢ºä¿è·¨å¹³å°ç›¸å®¹
// 3. éœ€è¦åŸå­æ€§æ™‚ï¼Œä½¿ç”¨åŸå­æ“ä½œæˆ–ç¦ç”¨ä¸­æ–·
```

### 5.5 Read-Modify-Write èˆ‡ç«¶çˆ­æ¢ä»¶

```c
// å•é¡Œï¼šä»¥ä¸‹æ“ä½œä¸æ˜¯åŸå­çš„ï¼

// å‡è¨­é€™æ˜¯ GPIO æ§åˆ¶æš«å­˜å™¨
volatile uint32_t *REG = (volatile uint32_t *)0x40000000;

// ä¸»ç¨‹å¼ï¼šè¨­å®š bit 3
*REG |= (1 << 3);
// å¯¦éš›åŸ·è¡Œï¼š
// 1. è®€å– *REG
// 2. OR é‹ç®—
// 3. å¯«å› *REG

// å¦‚æœåœ¨æ­¥é©Ÿ 1 å’Œ 3 ä¹‹é–“ç™¼ç”Ÿä¸­æ–·ï¼Œä¸­æ–·è™•ç†ç¨‹å¼ä¹Ÿä¿®æ”¹ *REG
// å°±æœƒç™¼ç”Ÿ race conditionï¼Œä¸­æ–·çš„ä¿®æ”¹å¯èƒ½è¢«è¦†è“‹ï¼

// è§£æ±ºæ–¹æ¡ˆ 1ï¼šç¦ç”¨ä¸­æ–·
uint32_t primask = __get_PRIMASK();
__disable_irq();
*REG |= (1 << 3);
__set_PRIMASK(primask);

// è§£æ±ºæ–¹æ¡ˆ 2ï¼šä½¿ç”¨åŸå­æ“ä½œï¼ˆå¦‚æœç¡¬é«”æ”¯æ´ï¼‰
// ä¾‹å¦‚ ARM Cortex-M çš„ Bit-Banding

// è§£æ±ºæ–¹æ¡ˆ 3ï¼šä½¿ç”¨ Set/Clear æš«å­˜å™¨ï¼ˆå¾ˆå¤šé€±é‚Šéƒ½æœ‰ï¼‰
// BSRRï¼ˆBit Set Reset Registerï¼‰ï¼š
// å¯« 1 åˆ°ä½ 16 bit æœƒ Set å°æ‡‰çš„ ODR bit
// å¯« 1 åˆ°é«˜ 16 bit æœƒ Clear å°æ‡‰çš„ ODR bit
volatile uint32_t *BSRR = (volatile uint32_t *)0x40020018;
*BSRR = (1 << 3);       // åŸå­åœ°è¨­å®š bit 3
*BSRR = (1 << (16+3));  // åŸå­åœ°æ¸…é™¤ bit 3
```

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šé¢è©¦ç¶“å…¸é¡Œç›®è©³è§£

### é¡Œç›® 1ï¼šåˆ¤æ–·æ˜¯å¦ç‚º 2 çš„å†ªæ¬¡

```c
int isPowerOfTwo(unsigned int n) {
    return n != 0 && (n & (n - 1)) == 0;
}

// é€²éšï¼šå¦‚æœè¼¸å…¥å¯èƒ½æ˜¯æœ‰è™Ÿæ•¸ï¼Ÿ
int isPowerOfTwo_signed(int n) {
    return n > 0 && (n & (n - 1)) == 0;
    // è² æ•¸å’Œé›¶éƒ½ä¸æ˜¯ 2 çš„å†ªæ¬¡
}
```

### é¡Œç›® 2ï¼šè¨ˆç®—éœ€è¦ç¿»è½‰å¤šå°‘ bit æ‰èƒ½æŠŠ A è®Šæˆ B

```c
int hammingDistance(int a, int b) {
    return __builtin_popcount(a ^ b);
}

// ä¸ç”¨å…§å»ºå‡½å¼ï¼š
int hammingDistance_v2(int a, int b) {
    int x = a ^ b;
    int count = 0;
    while (x) {
        x = x & (x - 1);
        count++;
    }
    return count;
}
```

### é¡Œç›® 3ï¼šè¨­å®šç¬¬ i åˆ°ç¬¬ j bit ç‚ºç‰¹å®šå€¼

```c
// æŠŠ n çš„ç¬¬ i åˆ°ç¬¬ j bit è¨­ç‚º m çš„å€¼
// ä¾‹å¦‚ï¼šn = 0b10000000000, m = 0b10011, i = 2, j = 6
// çµæœï¼š0b10001001100

int updateBits(int n, int m, int i, int j) {
    // Step 1: å»ºç«‹é®ç½©ï¼ˆi åˆ° j ç‚º 0ï¼Œå…¶ä»–ç‚º 1ï¼‰
    int ones = ~0;  // å…¨ 1
    int left = ones << (j + 1);        // å·¦é‚Šçš„ 1
    int right = (1 << i) - 1;          // å³é‚Šçš„ 1
    int mask = left | right;           // ä¸­é–“æ˜¯ 0
    
    // Step 2: æ¸…é™¤ n çš„ i åˆ° j bit
    n = n & mask;
    
    // Step 3: æŠŠ m ç§»åˆ°æ­£ç¢ºä½ç½®ï¼Œç„¶å¾Œ OR
    m = m << i;
    
    return n | m;
}
```

### é¡Œç›® 4ï¼šæ‰¾å‡ºé™£åˆ—ä¸­å”¯äºŒåªå‡ºç¾ä¸€æ¬¡çš„æ•¸å­—

```c
// é™£åˆ—ä¸­æ¯å€‹æ•¸å­—éƒ½å‡ºç¾å…©æ¬¡ï¼Œåªæœ‰å…©å€‹å‡ºç¾ä¸€æ¬¡
// ä¾‹å¦‚ï¼š{1, 2, 1, 3, 2, 5} â†’ 3 å’Œ 5

void findTwoSingle(int arr[], int size, int *num1, int *num2) {
    // Step 1: XOR æ‰€æœ‰æ•¸å­—ï¼Œå¾—åˆ° a ^ b
    int xorResult = 0;
    for (int i = 0; i < size; i++) {
        xorResult ^= arr[i];
    }
    
    // Step 2: æ‰¾åˆ° xorResult ä¸­ä»»æ„ä¸€å€‹ 1 çš„ bit
    // é€™è¡¨ç¤º a å’Œ b åœ¨é€™å€‹ bit ä¸Šä¸åŒ
    int setBit = xorResult & (-xorResult);  // æœ€ä½ä½çš„ 1
    
    // Step 3: æ ¹æ“šé€™å€‹ bit æŠŠæ•¸å­—åˆ†æˆå…©çµ„
    *num1 = 0;
    *num2 = 0;
    for (int i = 0; i < size; i++) {
        if (arr[i] & setBit) {
            *num1 ^= arr[i];
        } else {
            *num2 ^= arr[i];
        }
    }
}
```

### é¡Œç›® 5ï¼šN çš‡åå•é¡Œï¼ˆç”¨ä½å…ƒé‹ç®—åŠ é€Ÿï¼‰

```c
// ä½¿ç”¨ä½å…ƒé‹ç®—å„ªåŒ–å›æº¯æ¼”ç®—æ³•
int totalNQueens(int n) {
    int count = 0;
    int fullMask = (1 << n) - 1;  // n å€‹ 1
    
    solve(0, 0, 0, fullMask, &count);
    return count;
}

void solve(int col, int ld, int rd, int fullMask, int *count) {
    if (col == fullMask) {
        (*count)++;
        return;
    }
    
    // è¨ˆç®—å¯ä»¥æ”¾ç½®çš„ä½ç½®
    int pos = fullMask & ~(col | ld | rd);
    
    while (pos) {
        int p = pos & (-pos);  // å–æœ€ä½ä½çš„ 1
        pos -= p;              // æ¸…é™¤é€™å€‹ä½
        
        solve(col | p, (ld | p) << 1, (rd | p) >> 1, fullMask, count);
    }
}

// col: å·²ä½”ç”¨çš„åˆ—
// ld:  å·¦å°è§’ç·šæ”»æ“Šç¯„åœ
// rd:  å³å°è§’ç·šæ”»æ“Šç¯„åœ
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: ä¸ç”¨ +ã€-ã€*ã€/ å¯¦ä½œåŠ æ³•

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / Facebook

**å•é¡Œ**ï¼š
å¯¦ä½œ `int add(int a, int b)` ä¸ä½¿ç”¨ä»»ä½•ç®—è¡“é‹ç®—å­ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
int add(int a, int b) {
    while (b != 0) {
        int carry = (a & b) << 1;  // é€²ä½
        a = a ^ b;                 // ä¸é€²ä½åŠ æ³•
        b = carry;
    }
    return a;
}

// è§£é‡‹ï¼š
// a ^ b  = ä¸è€ƒæ…®é€²ä½çš„åŠ æ³•çµæœ
// a & b  = éœ€è¦é€²ä½çš„ä½ç½®
// (a & b) << 1 = é€²ä½å€¼
// é‡è¤‡ç›´åˆ°æ²’æœ‰é€²ä½

// ç¯„ä¾‹ï¼ša = 5 (0101), b = 3 (0011)
// ç¬¬ä¸€è¼ªï¼š
//   carry = (0101 & 0011) << 1 = 0001 << 1 = 0010
//   a = 0101 ^ 0011 = 0110
//   b = 0010
// ç¬¬äºŒè¼ªï¼š
//   carry = (0110 & 0010) << 1 = 0010 << 1 = 0100
//   a = 0110 ^ 0010 = 0100
//   b = 0100
// ç¬¬ä¸‰è¼ªï¼š
//   carry = (0100 & 0100) << 1 = 0100 << 1 = 1000
//   a = 0100 ^ 0100 = 0000
//   b = 1000
// ç¬¬å››è¼ªï¼š
//   carry = (0000 & 1000) << 1 = 0000
//   a = 0000 ^ 1000 = 1000 = 8
//   b = 0000
// çµæœï¼š8 âœ“
```

---

### Q2: åˆ¤æ–·ä¸€å€‹ 32-bit æ•´æ•¸çš„ç¬¬ n bit æ˜¯ 0 é‚„æ˜¯ 1

**é›£åº¦**ï¼šâ­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
å¯¦ä½œ `int getBit(int num, int n)`ï¼Œå›å‚³ num çš„ç¬¬ n bit å€¼ï¼ˆ0 æˆ– 1ï¼‰ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
int getBit(int num, int n) {
    return (num >> n) & 1;
}

// æˆ–è€…ï¼š
int getBit_v2(int num, int n) {
    return (num & (1 << n)) ? 1 : 0;
}
```

---

### Q3: ç‚ºä»€éº¼ä½å…ƒé‹ç®—è¦ä½¿ç”¨ unsigned å‹åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šåµŒå…¥å¼é¢è©¦

**å•é¡Œ**ï¼š
è§£é‡‹ç‚ºä»€éº¼åœ¨åšä½å…ƒé‹ç®—æ™‚å»ºè­°ä½¿ç”¨ unsigned å‹åˆ¥ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

1. **å³ç§»è¡Œç‚ºæ˜ç¢º**ï¼š
   - unsignedï¼šé‚è¼¯å³ç§»ï¼ˆå·¦é‚Šè£œ 0ï¼‰
   - signedï¼šç®—è¡“å³ç§»ï¼ˆå·¦é‚Šè£œç¬¦è™Ÿä½ï¼‰ï¼Œä¸”æ˜¯ã€Œå¯¦ä½œå®šç¾©ã€

2. **é¿å…æœªå®šç¾©è¡Œç‚º**ï¼š
   - æœ‰è™Ÿæ•¸å·¦ç§»åˆ°ç¬¦è™Ÿä½æ˜¯æœªå®šç¾©è¡Œç‚º
   - `int x = 1 << 31;` åœ¨æŸäº›æƒ…æ³ä¸‹æ˜¯ UB

3. **æº¢ä½è¡Œç‚ºæ˜ç¢º**ï¼š
   - unsigned æº¢ä½æœƒ wrap aroundï¼ˆæ¨¡ 2^nï¼‰
   - signed æº¢ä½æ˜¯æœªå®šç¾©è¡Œç‚º

4. **å¯¬åº¦æ˜ç¢º**ï¼š
   - ä½¿ç”¨ `uint32_t`ã€`uint8_t` ç­‰å›ºå®šå¯¬åº¦å‹åˆ¥
   - é¿å… `int` å¤§å°ä¸åŒé€ æˆçš„å•é¡Œ

---

### Q4: è¨­è¨ˆä¸€å€‹åªç”¨ O(1) é¡å¤–ç©ºé–“çš„æ¼”ç®—æ³•ï¼Œåè½‰ 32-bit æ•´æ•¸çš„ä½å…ƒ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šLeetCode 190

**å•é¡Œ**ï¼š
è¼¸å…¥ `n = 0b00000010100101000001111010011100`ï¼Œè¼¸å‡ºå…¶åè½‰ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
uint32_t reverseBits(uint32_t n) {
    n = ((n & 0x55555555) << 1) | ((n & 0xAAAAAAAA) >> 1);
    n = ((n & 0x33333333) << 2) | ((n & 0xCCCCCCCC) >> 2);
    n = ((n & 0x0F0F0F0F) << 4) | ((n & 0xF0F0F0F0) >> 4);
    n = ((n & 0x00FF00FF) << 8) | ((n & 0xFF00FF00) >> 8);
    n = (n << 16) | (n >> 16);
    return n;
}

// æ™‚é–“è¤‡é›œåº¦ï¼šO(1)
// ç©ºé–“è¤‡é›œåº¦ï¼šO(1)
```

---

### Q5: ä»€éº¼æ˜¯ Bit-Bandingï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šARM Cortex-M ç›¸é—œé¢è©¦

**å•é¡Œ**ï¼š
è§£é‡‹ ARM Cortex-M çš„ Bit-Banding æ©Ÿåˆ¶åŠå…¶å„ªé»ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

Bit-Banding æ˜¯ ARM Cortex-M ç³»åˆ—çš„ç¡¬é«”åŠŸèƒ½ï¼Œå…è¨±å°è¨˜æ†¶é«”ä¸­çš„å–®ä¸€ bit é€²è¡ŒåŸå­æ“ä½œã€‚

**æ©Ÿåˆ¶**ï¼š
- å°‡ 1MB çš„ã€Œbit-band regionã€æ˜ å°„åˆ° 32MB çš„ã€Œalias regionã€
- Alias region ä¸­æ¯å€‹ wordï¼ˆ4 bytesï¼‰å°æ‡‰ bit-band region ä¸­çš„ä¸€å€‹ bit
- è®€å¯« alias region çš„ word æœƒè‡ªå‹•æ“ä½œå°æ‡‰çš„ bit

**è¨ˆç®—å…¬å¼**ï¼š
```c
// bit_word_addr = bit_band_base + (byte_offset * 32) + (bit_number * 4)

#define BITBAND_SRAM_BASE   0x20000000
#define BITBAND_ALIAS_BASE  0x22000000

#define BITBAND_SRAM(addr, bit) \
    ((volatile uint32_t *)(BITBAND_ALIAS_BASE + \
    (((uint32_t)(addr) - BITBAND_SRAM_BASE) * 32) + ((bit) * 4)))

// ä½¿ç”¨ç¯„ä¾‹ï¼š
uint32_t myVar = 0;
*BITBAND_SRAM(&myVar, 5) = 1;  // åŸå­åœ°è¨­å®š bit 5
```

**å„ªé»**ï¼š
1. **åŸå­æ“ä½œ**ï¼šå–®ä¸€æŒ‡ä»¤å®Œæˆè®€-ä¿®æ”¹-å¯«
2. **ä¸­æ–·å®‰å…¨**ï¼šä¸éœ€è¦ç¦ç”¨ä¸­æ–·
3. **æ•ˆç‡é«˜**ï¼šå–®ä¸€ STR/LDR æŒ‡ä»¤

**é™åˆ¶**ï¼š
- åªæœ‰ SRAM å’Œ Peripheral å€åŸŸæ”¯æ´
- ä¸æ˜¯æ‰€æœ‰ ARM æ ¸å¿ƒéƒ½æ”¯æ´

---

### Q6: å¦‚ä½•åœ¨åµŒå…¥å¼ç³»çµ±ä¸­é¿å…ä½¿ç”¨ä¹˜æ³•å’Œé™¤æ³•ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šåµŒå…¥å¼é¢è©¦

**å•é¡Œ**ï¼š
æŸäº›åµŒå…¥å¼è™•ç†å™¨æ²’æœ‰ç¡¬é«”ä¹˜æ³•å™¨ï¼Œå¦‚ä½•ç”¨ä½å…ƒé‹ç®—ä»£æ›¿ä¹˜æ³•å’Œé™¤æ³•ï¼Ÿ

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
// ä¹˜ä»¥ 2 çš„å†ªæ¬¡ï¼šå·¦ç§»
x * 2   == x << 1
x * 4   == x << 2
x * 8   == x << 3
x * 2^n == x << n

// é™¤ä»¥ 2 çš„å†ªæ¬¡ï¼šå³ç§»
x / 2   == x >> 1
x / 4   == x >> 2
x / 8   == x >> 3
x / 2^n == x >> n  // âš ï¸ åªé©ç”¨æ–¼ç„¡è™Ÿæ•¸ï¼

// ä¹˜ä»¥é 2 çš„å†ªæ¬¡ï¼šåˆ†è§£
x * 10  == (x << 3) + (x << 1)  // x*8 + x*2
x * 7   == (x << 3) - x         // x*8 - x
x * 15  == (x << 4) - x         // x*16 - x

// é™¤ä»¥é 2 çš„å†ªæ¬¡ï¼šé€šå¸¸ç”¨æŸ¥è¡¨æˆ–å®šé»æ•¸è¿‘ä¼¼
```

---

### Q7: è§£é‡‹ `n & (n - 1)` çš„ä½œç”¨

**é›£åº¦**ï¼šâ­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
è§£é‡‹ `n & (n - 1)` çš„ä½œç”¨ï¼Œä¸¦çµ¦å‡ºä¸‰å€‹æ‡‰ç”¨å ´æ™¯ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

**ä½œç”¨**ï¼šæ¸…é™¤ n çš„æœ€ä½ä½ 1ã€‚

**åŸç†**ï¼š
```
n     = 0b...XXXX1000...0  (å‡è¨­æœ€ä½ä½çš„ 1 åœ¨é€™è£¡)
n - 1 = 0b...XXXX0111...1  (å€Ÿä½å°è‡´è©²ä½è®Š 0ï¼Œå³é‚Šéƒ½è®Š 1)
n & (n-1) = 0b...XXXX0000...0  (è©²ä½è¢«æ¸…é™¤)
```

**æ‡‰ç”¨å ´æ™¯**ï¼š

1. **åˆ¤æ–· 2 çš„å†ªæ¬¡**ï¼š
   ```c
   bool isPowerOfTwo = (n != 0) && (n & (n-1)) == 0;
   ```

2. **è¨ˆç®— 1 çš„å€‹æ•¸**ï¼ˆBrian Kernighanï¼‰ï¼š
   ```c
   int count = 0;
   while (n) { n &= (n-1); count++; }
   ```

3. **æª¢æŸ¥æ˜¯å¦åªå·®ä¸€å€‹ bit**ï¼š
   ```c
   bool differByOneBit = ((a ^ b) & ((a ^ b) - 1)) == 0;
   ```

---

### Q8: é€™æ®µç¨‹å¼ç¢¼æœƒè¼¸å‡ºä»€éº¼ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**å•é¡Œ**ï¼š
```c
unsigned char a = 0xAB;
printf("%02X\n", ~a);
```

**æ¨™æº–ç­”æ¡ˆ**ï¼š

è¼¸å‡ºï¼š`FFFFFF54`ï¼ˆæˆ–é¡ä¼¼ï¼Œå–æ±ºæ–¼ç³»çµ±ï¼‰

**è§£é‡‹**ï¼š
1. `a` æ˜¯ `unsigned char`ï¼Œå€¼ç‚º 0xAB
2. `~a` æœƒè§¸ç™¼ã€Œæ•´æ•¸æå‡ã€(Integer Promotion)
3. `a` è¢«æå‡ç‚º `int`ï¼ˆ32-bitï¼‰ï¼Œå€¼ä»ç‚º 0x000000AB
4. `~0x000000AB` = 0xFFFFFF54
5. `%02X` æœƒå°å‡ºå®Œæ•´çš„åå…­é€²ä½å€¼

**å¦‚æœåªè¦ 8-bit çµæœ**ï¼š
```c
printf("%02X\n", (unsigned char)~a);  // è¼¸å‡ºï¼š54
printf("%02X\n", ~a & 0xFF);          // è¼¸å‡ºï¼š54
```

---

### Q9: è¨­è¨ˆä¸€å€‹å‡½å¼ï¼Œåˆ¤æ–·ç³»çµ±æ˜¯ Big Endian é‚„æ˜¯ Little Endian

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šåµŒå…¥å¼ / ç¶²è·¯ç¨‹å¼è¨­è¨ˆ

**å•é¡Œ**ï¼š
å¯¦ä½œ `int isLittleEndian()` å‡½å¼ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
// æ–¹æ³• 1ï¼šä½¿ç”¨ union
int isLittleEndian_v1() {
    union {
        uint16_t word;
        uint8_t bytes[2];
    } test;
    
    test.word = 0x0102;
    return test.bytes[0] == 0x02;  // Little endian: ä½ä½åœ¨å‰
}

// æ–¹æ³• 2ï¼šä½¿ç”¨æŒ‡æ¨™
int isLittleEndian_v2() {
    uint16_t x = 0x0001;
    return *(uint8_t *)&x == 0x01;
}

// Little Endian: 0x1234 å­˜æˆ [34] [12]ï¼ˆä½ä½åœ¨å‰ï¼‰
// Big Endian:    0x1234 å­˜æˆ [12] [34]ï¼ˆé«˜ä½åœ¨å‰ï¼‰
```

---

### Q10: ç”¨ä½å…ƒé‹ç®—äº¤æ›æ•´æ•¸çš„å¥‡å¶ä½

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / Amazon

**å•é¡Œ**ï¼š
äº¤æ›ä¸€å€‹ 32-bit æ•´æ•¸çš„æ‰€æœ‰å¥‡æ•¸ä½å’Œå¶æ•¸ä½ã€‚
ä¾‹å¦‚ï¼šbit 0 å’Œ bit 1 äº¤æ›ï¼Œbit 2 å’Œ bit 3 äº¤æ›ï¼Œä»¥æ­¤é¡æ¨ã€‚

**æ¨™æº–ç­”æ¡ˆ**ï¼š

```c
uint32_t swapOddEvenBits(uint32_t n) {
    // 0x55555555 = 0b01010101... (å¶æ•¸ä½)
    // 0xAAAAAAAA = 0b10101010... (å¥‡æ•¸ä½)
    
    uint32_t even = n & 0x55555555;  // å–å‡ºå¶æ•¸ä½
    uint32_t odd = n & 0xAAAAAAAA;   // å–å‡ºå¥‡æ•¸ä½
    
    return (even << 1) | (odd >> 1); // å¶æ•¸ä½å·¦ç§»ï¼Œå¥‡æ•¸ä½å³ç§»
}

// ç¯„ä¾‹ï¼š
// n    = 0b10101010
// even = 0b00000000
// odd  = 0b10101010
// çµæœ = 0b01010101
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **æ›¸ç±**
   - ã€ŠHacker's Delightã€‹ - Henry S. Warren Jr. (ä½å…ƒé‹ç®—è–ç¶“)
   - ã€ŠThe Art of Computer Programming, Vol. 4Aã€‹ - Donald Knuth

2. **ç·šä¸Šè³‡æº**
   - [Bit Twiddling Hacks](https://graphics.stanford.edu/~seander/bithacks.html) - Stanford ç¶“å…¸è³‡æº
   - [Compiler Explorer](https://godbolt.org/) - æŸ¥çœ‹ä½å…ƒé‹ç®—çš„çµ„èª

3. **LeetCode ç·´ç¿’é¡Œ**
   - 136. Single Number
   - 137. Single Number II
   - 190. Reverse Bits
   - 191. Number of 1 Bits
   - 201. Bitwise AND of Numbers Range
   - 260. Single Number III

---

## âœ… ç·´ç¿’è¨ˆåŠƒ

| æ—¥ | å…§å®¹ |
|---|------|
| 1 | åŸºç¤é‹ç®—ç·´ç¿’ï¼ˆ&, \|, ^, ~, <<, >>ï¼‰|
| 2 | SET/CLEAR/TOGGLE/CHECK bit ç·´ç¿’ |
| 3 | ç¶“å…¸æŠ€å·§ï¼šisPowerOfTwo, popcount, reverseBits |
| 4 | XOR æŠ€å·§ï¼šfindSingle, swap |
| 5 | ç¡¬é«”æš«å­˜å™¨æ‡‰ç”¨ï¼šMMIO, bit field |
| 6 | é€²éšé¡Œï¼šåŠ æ³•ã€endianã€Nçš‡å |
| 7 | ç¶œåˆè¤‡ç¿’èˆ‡æ¨¡æ“¬é¢è©¦ |

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/02_Cèªè¨€/ä½å…ƒé‹ç®—ç·´ç¿’.md`
- æ“´å……å‰è¡Œæ•¸ï¼š422 è¡Œ
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 1580 è¡Œ
- æ–°å¢é¢è©¦é¡Œæ•¸ï¼š10 é¡Œ
- è‡ªæª¢çµæœï¼š
  - [x] åŒ…å«å®Œæ•´çš„ Why â†’ What â†’ How â†’ Deep Dive çµæ§‹
  - [x] æ¶µè“‹æœ‰è™Ÿæ•¸/ç„¡è™Ÿæ•¸ä½ç§»å·®ç•°
  - [x] æ¶µè“‹ç¶“å…¸ Bit Manipulation æŠ€å·§
  - [x] æ¶µè“‹ç¡¬é«”æš«å­˜å™¨æ“ä½œå¯¦å‹™
  - [x] ç¨‹å¼ç¢¼ç¯„ä¾‹æœ‰è©³ç´°è¨»è§£
  - [x] é¢è©¦é¡ŒåŒ…å« Google/Amazon ç´šåˆ¥é›£åº¦
