# ğŸ”§ Linux é©…å‹•ç¨‹å¼åŸºç¤å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£ Linux Device Model æ¶æ§‹
> 2. æŒæ¡ Platform Driver èˆ‡ Device Tree åŒ¹é…æ©Ÿåˆ¶
> 3. ç†è§£ probe å‡½å¼çš„å‘¼å«æ™‚æ©Ÿèˆ‡ Deferred Probe
> 4. ç†Ÿç·´ä½¿ç”¨ devm_ Managed Resource API
> 5. æŒæ¡ sysfs/debugfs/procfs ä»‹é¢è¨­è¨ˆ

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šDriver åŸºç¤æ¦‚å¿µ

### 1.1 ä»€éº¼æ˜¯é©…å‹•ç¨‹å¼ï¼Ÿ

```
é©…å‹•ç¨‹å¼æ˜¯ã€Œè»Ÿé«”ã€å’Œã€Œç¡¬é«”ã€ä¹‹é–“çš„æ©‹æ¨‘ã€‚

æ‡‰ç”¨ç¨‹å¼ (User Space)
    â†“ ç³»çµ±å‘¼å«ï¼ˆopen, read, write, ioctlï¼‰
Kernel (Kernel Space)
    â†“
é©…å‹•ç¨‹å¼ (Driver)
    â†“
ç¡¬é«” (Hardware)
```

### 1.2 Linux Driver ä¸‰å¤§é¡å‹

| é¡å‹ | ç‰¹é» | ç¯„ä¾‹ | è£ç½®æª”æ¡ˆ |
|:---|:---|:---|:---|
| Character Device | byte stream, é †åºå­˜å– | UART, éµç›¤, sensor | /dev/ttyUSB0 |
| Block Device | block ç‚ºå–®ä½, éš¨æ©Ÿå­˜å– | ç¡¬ç¢Ÿ, SSD, SDå¡ | /dev/sda |
| Network Device | è™•ç†ç¶²è·¯å°åŒ… | Ethernet, WiFi | ç„¡ (ç”¨ ifconfig) |

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šLinux Device Model

### 2.1 æ ¸å¿ƒè³‡æ–™çµæ§‹

```c
/* Linux Kernel v6.x */

/* ä»£è¡¨ä¸€å€‹è£ç½® */
struct device {
    struct kobject kobj;           /* sysfs ç¯€é» */
    struct device *parent;         /* çˆ¶è£ç½® */
    struct bus_type *bus;          /* æ‰€å±¬çš„ bus */
    struct device_driver *driver;  /* ç¶å®šçš„ driver */
    void *platform_data;           /* å¹³å°ç‰¹å®šè³‡æ–™ */
    void *driver_data;             /* driver ç§æœ‰è³‡æ–™ */
    struct device_node *of_node;   /* Device Tree ç¯€é» */
    /* ... */
};

/* ä»£è¡¨ä¸€å€‹é©…å‹•ç¨‹å¼ */
struct device_driver {
    const char *name;
    struct bus_type *bus;
    int (*probe)(struct device *dev);
    int (*remove)(struct device *dev);
    const struct of_device_id *of_match_table; /* DT åŒ¹é…è¡¨ */
    /* ... */
};

/* ä»£è¡¨ä¸€å€‹åŒ¯æµæ’ */
struct bus_type {
    const char *name;
    int (*match)(struct device *dev, struct device_driver *drv);
    int (*probe)(struct device *dev);
    /* ... */
};
```

### 2.2 Device-Driver ç¶å®šæµç¨‹

```
1. Device è¨»å†Šåˆ° Bus
   device_register() â†’ bus_add_device()
   
2. Driver è¨»å†Šåˆ° Bus  
   driver_register() â†’ bus_add_driver()

3. Bus åŸ·è¡Œ match
   bus->match(device, driver)
   - Platform Bus: æ¯”å° compatible å­—ä¸²
   - I2C Bus: æ¯”å° i2c_device_id
   
4. Match æˆåŠŸå¾Œå‘¼å« probe
   driver->probe(device)
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šPlatform Driver

### 3.1 ä»€éº¼æ˜¯ Platform Device/Driverï¼Ÿ

```c
/* Platform Deviceï¼šä¸åœ¨æ¨™æº–åŒ¯æµæ’ä¸Šçš„è£ç½®
 * ä¾‹å¦‚ï¼šSoC å…§å»ºçš„ UARTã€GPIOã€Timer
 * é€™äº›è£ç½®é€é Memory-Mapped I/O å­˜å–
 */

struct platform_device {
    const char *name;
    int id;
    struct resource *resource;  /* è¨˜æ†¶é«”/IRQ è³‡æº */
    struct device dev;
};

struct platform_driver {
    int (*probe)(struct platform_device *pdev);
    int (*remove)(struct platform_device *pdev);
    struct device_driver driver;
};
```

### 3.2 Platform Driver å®Œæ•´ç¯„ä¾‹

```c
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/io.h>

struct my_device {
    void __iomem *base;
    int irq;
};

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    struct resource *res;
    
    /* 1. åˆ†é…ç§æœ‰è³‡æ–™ */
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;
    
    /* 2. å–å¾—è¨˜æ†¶é«”è³‡æºä¸¦æ˜ å°„ */
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    priv->base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(priv->base))
        return PTR_ERR(priv->base);
    
    /* 3. å–å¾— IRQ */
    priv->irq = platform_get_irq(pdev, 0);
    if (priv->irq < 0)
        return priv->irq;
    
    /* 4. å„²å­˜ç§æœ‰è³‡æ–™ */
    platform_set_drvdata(pdev, priv);
    
    dev_info(&pdev->dev, "Probed successfully\n");
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    dev_info(&pdev->dev, "Removed\n");
    return 0;
}

/* Device Tree åŒ¹é…è¡¨ */
static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device" },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, my_of_match);

static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-driver",
        .of_match_table = my_of_match,
    },
};
module_platform_driver(my_driver);

MODULE_LICENSE("GPL");
```

### 3.3 Device Tree åŒ¹é…æ©Ÿåˆ¶

```dts
/* Device Tree å®šç¾© */
my_device@40000000 {
    compatible = "vendor,my-device";
    reg = <0x40000000 0x1000>;
    interrupts = <32>;
    status = "okay";
};
```

```c
/* Driver ä¸­çš„åŒ¹é…è¡¨ */
static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device" },
    { .compatible = "vendor,my-device-v2", .data = &v2_config },
    { }
};

/* åŒ¹é…å„ªå…ˆé †åºï¼š
 * 1. å®Œå…¨åŒ¹é… compatible å­—ä¸²
 * 2. åŒ¹é… compatible list ä¸­çš„ä»»ä¸€é …
 */
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šProbe æ™‚æ©Ÿèˆ‡ Deferred Probe

### 4.1 Probe ä½•æ™‚è¢«å‘¼å«ï¼Ÿ

```c
/* ä¸‰ç¨®æƒ…æ³æœƒè§¸ç™¼ probeï¼š
 * 
 * 1. Driver è¨»å†Šæ™‚ï¼Œå·²å­˜åœ¨åŒ¹é…çš„ Device
 *    driver_register() â†’ bus_for_each_dev() â†’ æ‰¾åˆ°åŒ¹é… â†’ probe()
 * 
 * 2. Device è¨»å†Šæ™‚ï¼Œå·²å­˜åœ¨åŒ¹é…çš„ Driver
 *    device_register() â†’ bus_for_each_drv() â†’ æ‰¾åˆ°åŒ¹é… â†’ probe()
 * 
 * 3. Deferred Probe é‡è©¦
 *    æŸäº›ä¾è³´å°±ç·’å¾Œï¼Œkernel é‡æ–°å˜—è©¦ probe
 */
```

### 4.2 Deferred Probe æ©Ÿåˆ¶

```c
/* ç•¶ probe ä¾è³´çš„è³‡æºé‚„æ²’æº–å‚™å¥½æ™‚ï¼š
 * ä¾‹å¦‚ï¼šregulatorã€clockã€GPIO controller é‚„æ²’åˆå§‹åŒ–
 */
static int my_probe(struct platform_device *pdev)
{
    struct clk *clk;
    
    clk = devm_clk_get(&pdev->dev, "main");
    if (IS_ERR(clk)) {
        if (PTR_ERR(clk) == -EPROBE_DEFER) {
            /* Clock é‚„æ²’æº–å‚™å¥½ï¼Œç¨å¾Œé‡è©¦ */
            dev_dbg(&pdev->dev, "Clock not ready, deferring\n");
            return -EPROBE_DEFER;
        }
        return PTR_ERR(clk);
    }
    
    /* Clock å·²å°±ç·’ï¼Œç¹¼çºŒåˆå§‹åŒ– */
    return 0;
}

/* Kernel æœƒå°‡å›å‚³ -EPROBE_DEFER çš„è£ç½®åŠ å…¥
 * deferred_probe_pending_listï¼Œç¨å¾Œé‡è©¦
 */
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šdevm_ Managed Resource API

### 5.1 ç‚ºä»€éº¼éœ€è¦ devm_ï¼Ÿ

```c
/* å‚³çµ±æ–¹å¼ï¼šéœ€è¦æ‰‹å‹•ç®¡ç†æ¯å€‹è³‡æº */
static int old_probe(struct platform_device *pdev)
{
    void *ptr = kmalloc(size, GFP_KERNEL);
    if (!ptr)
        return -ENOMEM;
    
    void *base = ioremap(addr, size);
    if (!base) {
        kfree(ptr);  /* å¿…é ˆæ‰‹å‹•é‡‹æ”¾ */
        return -ENOMEM;
    }
    
    int irq = request_irq(...);
    if (irq < 0) {
        iounmap(base);  /* å¿…é ˆä¾åºé‡‹æ”¾ */
        kfree(ptr);
        return irq;
    }
    
    return 0;
}

/* devm_ æ–¹å¼ï¼šè‡ªå‹•ç®¡ç†è³‡æºç”Ÿå‘½é€±æœŸ */
static int new_probe(struct platform_device *pdev)
{
    void *ptr = devm_kmalloc(&pdev->dev, size, GFP_KERNEL);
    if (!ptr)
        return -ENOMEM;
    
    void *base = devm_ioremap(&pdev->dev, addr, size);
    if (!base)
        return -ENOMEM;  /* ptr æœƒè‡ªå‹•é‡‹æ”¾ */
    
    int ret = devm_request_irq(&pdev->dev, irq, handler, 0, "my", dev);
    if (ret < 0)
        return ret;  /* base å’Œ ptr éƒ½æœƒè‡ªå‹•é‡‹æ”¾ */
    
    return 0;
}
/* ç•¶ device è¢« remove æ™‚ï¼Œæ‰€æœ‰ devm_ è³‡æºè‡ªå‹•é‡‹æ”¾ */
```

### 5.2 å¸¸ç”¨ devm_ API åˆ—è¡¨

| API | ç”¨é€” |
|:---|:---|
| `devm_kmalloc` | å‹•æ…‹è¨˜æ†¶é«”åˆ†é… |
| `devm_kzalloc` | åˆ†é…ä¸¦æ¸…é›¶ |
| `devm_ioremap` | è¨˜æ†¶é«”æ˜ å°„ |
| `devm_ioremap_resource` | å–å¾—è³‡æºä¸¦æ˜ å°„ |
| `devm_request_irq` | è¨»å†Šä¸­æ–· |
| `devm_clk_get` | å–å¾— clock |
| `devm_regulator_get` | å–å¾— regulator |
| `devm_gpio_request` | è«‹æ±‚ GPIO |
| `devm_pinctrl_get` | å–å¾— pinctrl |

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šsysfs / debugfs / procfs

### 6.1 sysfs ä»‹é¢

```c
/* sysfs: /sys ä¸‹çš„æª”æ¡ˆç³»çµ±ï¼Œç”¨æ–¼ kernel èˆ‡ user space äº¤äº’ */

/* å®šç¾© attribute */
static ssize_t my_attr_show(struct device *dev,
                            struct device_attribute *attr, char *buf)
{
    struct my_device *priv = dev_get_drvdata(dev);
    return sprintf(buf, "%d\n", priv->value);
}

static ssize_t my_attr_store(struct device *dev,
                             struct device_attribute *attr,
                             const char *buf, size_t count)
{
    struct my_device *priv = dev_get_drvdata(dev);
    sscanf(buf, "%d", &priv->value);
    return count;
}

static DEVICE_ATTR(my_attr, 0644, my_attr_show, my_attr_store);

/* åœ¨ probe ä¸­å»ºç«‹ */
device_create_file(&pdev->dev, &dev_attr_my_attr);

/* ä½¿ç”¨ï¼š
 * cat /sys/devices/.../my_attr
 * echo 123 > /sys/devices/.../my_attr
 */
```

### 6.2 debugfs ä»‹é¢

```c
/* debugfs: /sys/kernel/debug ä¸‹ï¼Œç”¨æ–¼ debug è³‡è¨Š */
#include <linux/debugfs.h>

static struct dentry *debugfs_root;

static int my_debugfs_show(struct seq_file *s, void *data)
{
    struct my_device *priv = s->private;
    seq_printf(s, "Register dump:\n");
    seq_printf(s, "  REG0: 0x%08x\n", readl(priv->base + 0x00));
    return 0;
}
DEFINE_SHOW_ATTRIBUTE(my_debugfs);

static int my_probe(struct platform_device *pdev)
{
    /* ... */
    debugfs_root = debugfs_create_dir("my_driver", NULL);
    debugfs_create_file("regs", 0444, debugfs_root, priv,
                        &my_debugfs_fops);
    return 0;
}
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Platform Driver çš„ probe ä½•æ™‚è¢«å‘¼å«ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š
1. Driver è¨»å†Šæ™‚ï¼ŒBus éæ­·å·²è¨»å†Šçš„ Device å°‹æ‰¾åŒ¹é…
2. Device è¨»å†Šæ™‚ï¼ŒBus éæ­·å·²è¨»å†Šçš„ Driver å°‹æ‰¾åŒ¹é…
3. åŒ¹é…æˆåŠŸå¾Œç”± Bus å‘¼å« driver->probe()
4. Deferred Probe é‡è©¦æ™‚

### Q2: ä»€éº¼æ˜¯ Deferred Probeï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**ç­”æ¡ˆ**ï¼š
ç•¶ probe ä¾è³´çš„è³‡æºï¼ˆclockã€regulatorã€GPIOï¼‰å°šæœªå°±ç·’æ™‚ï¼Œå›å‚³ `-EPROBE_DEFER`ï¼ŒKernel æœƒå°‡è£ç½®åŠ å…¥å¾…è™•ç†åˆ—è¡¨ï¼Œç¨å¾Œé‡è©¦ã€‚

### Q3: devm_ API çš„å„ªé»ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**ç­”æ¡ˆ**ï¼š
1. è‡ªå‹•è³‡æºç®¡ç†ï¼Œä¸éœ€æ‰‹å‹• free/unmap
2. é¿å… error path ä¸­çš„è³‡æºæ´©æ¼
3. ç¨‹å¼ç¢¼æ›´ç°¡æ½”
4. æŒ‰åˆ†é…çš„ç›¸åé †åºè‡ªå‹•é‡‹æ”¾

### Q4: sysfs vs debugfs vs procfsï¼Ÿ

| ç‰¹æ€§ | sysfs | debugfs | procfs |
|:---|:---|:---|:---|
| ç”¨é€” | è£ç½®å±¬æ€§ | Debug è³‡è¨Š | Process è³‡è¨Š |
| è·¯å¾‘ | /sys | /sys/kernel/debug | /proc |
| ç©©å®šæ€§ | ABI ç©©å®š | å¯éš¨æ™‚è®Šå‹• | éƒ¨åˆ†ç©©å®š |

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/03_åº•å±¤é©…å‹•é–‹ç™¼/é©…å‹•ç¨‹å¼åŸºç¤.md`
- æ“´å……å‰è¡Œæ•¸ï¼š371 è¡Œ
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 450 è¡Œ
- æ¶µè“‹ï¼šDevice Modelã€Platform Driverã€Deferred Probeã€devm_ APIã€sysfs/debugfs
