# ğŸ”§ Linux é©…å‹•ç¨‹å¼åŸºç¤å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£ Linux Device Model æ¶æ§‹èˆ‡ Kernel åŸå§‹ç¢¼
> 2. æŒæ¡ Character Deviceã€Platform Driverã€Misc Driver çš„å®Œæ•´å¯¦ä½œ
> 3. ç†è§£ probe å‡½å¼çš„å‘¼å«æ™‚æ©Ÿèˆ‡ Deferred Probe æ©Ÿåˆ¶
> 4. ç†Ÿç·´ä½¿ç”¨ devm_ Managed Resource API
> 5. æŒæ¡ sysfs/debugfs/procfs ä»‹é¢è¨­è¨ˆ
> 6. ç²¾é€š Kernel Synchronization åœ¨ Driver ä¸­çš„æ‡‰ç”¨

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šDriver åŸºç¤æ¦‚å¿µ

### 1.1 ä»€éº¼æ˜¯é©…å‹•ç¨‹å¼ï¼Ÿ

```
é©…å‹•ç¨‹å¼æ˜¯ã€Œè»Ÿé«”ã€å’Œã€Œç¡¬é«”ã€ä¹‹é–“çš„æ©‹æ¨‘ã€‚

æ‡‰ç”¨ç¨‹å¼ (User Space)
    â†“ ç³»çµ±å‘¼å«ï¼ˆopen, read, write, ioctlï¼‰
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Kernel (Kernel Space)
    â†“ VFS (Virtual File System)
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
é©…å‹•ç¨‹å¼ (Driver)
    â†“ I/O æ“ä½œ
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ç¡¬é«” (Hardware)

é©…å‹•ç¨‹å¼çš„è·è²¬ï¼š
1. åˆå§‹åŒ–ç¡¬é«”
2. è™•ç†è®€å¯«è«‹æ±‚
3. è™•ç†ä¸­æ–·
4. é›»æºç®¡ç†
5. éŒ¯èª¤è™•ç†
```

### 1.2 Linux Driver ä¸‰å¤§é¡å‹

| é¡å‹ | ç‰¹é» | ç¯„ä¾‹ | è£ç½®æª”æ¡ˆ | Major/Minor |
|:---|:---|:---|:---|:---|
| Character Device | byte stream, é †åºå­˜å– | UART, éµç›¤, sensor | /dev/ttyUSB0 | 188/0 |
| Block Device | block ç‚ºå–®ä½, éš¨æ©Ÿå­˜å– | ç¡¬ç¢Ÿ, SSD, SD å¡ | /dev/sda | 8/0 |
| Network Device | è™•ç†ç¶²è·¯å°åŒ… | Ethernet, WiFi | ç„¡ (ç”¨ ifconfig) | N/A |

### 1.3 Major Number èˆ‡ Minor Number

```c
/* è£ç½®è™Ÿç¢¼ = Major + Minor
 * Major: è­˜åˆ¥é©…å‹•ç¨‹å¼
 * Minor: è­˜åˆ¥åŒä¸€é©…å‹•ä¸‹çš„ä¸åŒè£ç½®
 */

#include <linux/kdev_t.h>

dev_t dev_num = MKDEV(200, 0);     /* å»ºç«‹è£ç½®è™Ÿç¢¼ */
int major = MAJOR(dev_num);        /* å–å¾— major */
int minor = MINOR(dev_num);        /* å–å¾— minor */

/* å‹•æ…‹åˆ†é…è£ç½®è™Ÿç¢¼ï¼ˆæ¨è–¦ï¼‰ */
dev_t dev;
int ret = alloc_chrdev_region(&dev, 0, 1, "my_device");
/* first_minor = 0, count = 1 */

/* éœæ…‹æŒ‡å®šï¼ˆä¸æ¨è–¦ï¼‰ */
int ret = register_chrdev_region(MKDEV(200, 0), 1, "my_device");
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šLinux Device Model æ·±å…¥è§£æ

### 2.1 æ ¸å¿ƒè³‡æ–™çµæ§‹ï¼ˆKernel v6.x åŸå§‹ç¢¼ç¯€é¸ï¼‰

```c
/* include/linux/device.h */

/**
 * struct device - ä»£è¡¨ç³»çµ±ä¸­çš„ä¸€å€‹è£ç½®
 * 
 * é€™æ˜¯ Linux Device Model çš„æ ¸å¿ƒï¼
 * æ¯å€‹ç¡¬é«”è£ç½®åœ¨ kernel ä¸­éƒ½ç”¨é€™å€‹çµæ§‹è¡¨ç¤º
 */
struct device {
    struct kobject kobj;           /* sysfs ç¯€é»ï¼ˆç¹¼æ‰¿ kobjectï¼‰ */
    struct device *parent;         /* çˆ¶è£ç½®ï¼ˆå½¢æˆæ¨¹ç‹€çµæ§‹ï¼‰ */
    
    const char *init_name;         /* åˆå§‹åç¨± */
    
    struct bus_type *bus;          /* æ‰€å±¬çš„ bus */
    struct device_driver *driver;  /* ç¶å®šçš„ driver */
    
    void *platform_data;           /* å¹³å°ç‰¹å®šè³‡æ–™ï¼ˆèˆŠå¼ï¼‰ */
    void *driver_data;             /* driver ç§æœ‰è³‡æ–™ */
    
    struct device_node *of_node;   /* Device Tree ç¯€é» */
    struct fwnode_handle *fwnode;  /* Firmware ç¯€é»ï¼ˆACPI/DT æŠ½è±¡ï¼‰ */
    
    struct dev_pm_info power;      /* é›»æºç®¡ç†è³‡è¨Š */
    struct dev_pm_domain *pm_domain; /* é›»æºç®¡ç†åŸŸ */
    
    u64 *dma_mask;                 /* DMA ä½å€é®ç½© */
    u64 coherent_dma_mask;         /* Coherent DMA é®ç½© */
    
    struct device_dma_parameters *dma_parms;
    
    struct list_head dma_pools;    /* DMA pool åˆ—è¡¨ */
    
    struct class *class;           /* è£ç½®é¡åˆ¥ï¼ˆå¦‚ input, gpioï¼‰ */
    const struct attribute_group **groups; /* sysfs å±¬æ€§ç¾¤çµ„ */
    
    void (*release)(struct device *dev); /* é‡‹æ”¾å›å‘¼ */
    
    struct iommu_group *iommu_group;
    struct dev_iommu *iommu;
    
    /* ... æ›´å¤šæ¬„ä½ ... */
};

/**
 * struct device_driver - ä»£è¡¨ä¸€å€‹é©…å‹•ç¨‹å¼
 */
struct device_driver {
    const char *name;              /* é©…å‹•åç¨± */
    struct bus_type *bus;          /* æ‰€å±¬ bus */
    
    struct module *owner;          /* æ¨¡çµ„æ“æœ‰è€… */
    
    const char *mod_name;          /* æ¨¡çµ„åç¨± */
    
    bool suppress_bind_attrs;      /* ç¦ç”¨ bind/unbind sysfs */
    
    enum probe_type probe_type;    /* probe é¡å‹ */
    
    const struct of_device_id *of_match_table;   /* Device Tree åŒ¹é…è¡¨ */
    const struct acpi_device_id *acpi_match_table; /* ACPI åŒ¹é…è¡¨ */
    
    int (*probe)(struct device *dev);    /* è£ç½®åˆå§‹åŒ– */
    void (*sync_state)(struct device *dev);
    int (*remove)(struct device *dev);   /* è£ç½®ç§»é™¤ */
    void (*shutdown)(struct device *dev); /* ç³»çµ±é—œæ©Ÿ */
    
    int (*suspend)(struct device *dev, pm_message_t state);
    int (*resume)(struct device *dev);
    
    const struct attribute_group **groups;
    
    const struct dev_pm_ops *pm;   /* é›»æºç®¡ç†æ“ä½œ */
    
    struct driver_private *p;      /* ç§æœ‰è³‡æ–™ */
};

/**
 * struct bus_type - ä»£è¡¨ä¸€å€‹åŒ¯æµæ’é¡å‹
 */
struct bus_type {
    const char *name;              /* bus åç¨± */
    const char *dev_name;          /* è£ç½®åç¨±å‰ç¶´ */
    struct device *dev_root;       /* bus æ ¹è£ç½® */
    
    const struct attribute_group **bus_groups;
    const struct attribute_group **dev_groups;
    const struct attribute_group **drv_groups;
    
    /* æ ¸å¿ƒæ“ä½œ */
    int (*match)(struct device *dev, struct device_driver *drv);
    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
    int (*probe)(struct device *dev);
    void (*sync_state)(struct device *dev);
    void (*remove)(struct device *dev);
    void (*shutdown)(struct device *dev);
    
    int (*online)(struct device *dev);
    int (*offline)(struct device *dev);
    
    int (*suspend)(struct device *dev, pm_message_t state);
    int (*resume)(struct device *dev);
    
    const struct dev_pm_ops *pm;
    
    struct subsys_private *p;
    
    /* ... */
};
```

### 2.2 Device-Driver-Bus ç¶å®šæµç¨‹è©³è§£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Device-Driver ç¶å®šæµç¨‹                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Device è¨»å†Š                     Driver è¨»å†Š                     â”‚
â”‚      â”‚                               â”‚                           â”‚
â”‚      â†“                               â†“                           â”‚
â”‚  device_register()              driver_register()                â”‚
â”‚      â”‚                               â”‚                           â”‚
â”‚      â†“                               â†“                           â”‚
â”‚  device_add()                   bus_add_driver()                 â”‚
â”‚      â”‚                               â”‚                           â”‚
â”‚      â†“                               â†“                           â”‚
â”‚  bus_add_device()               driver_attach()                  â”‚
â”‚      â”‚                               â”‚                           â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                  â†“   â†“                                           â”‚
â”‚              bus->match()                                        â”‚
â”‚                  â”‚                                               â”‚
â”‚                  â†“ åŒ¹é…æˆåŠŸ                                       â”‚
â”‚           driver_probe_device()                                  â”‚
â”‚                  â”‚                                               â”‚
â”‚                  â†“                                               â”‚
â”‚           really_probe()                                         â”‚
â”‚                  â”‚                                               â”‚
â”‚                  â†“                                               â”‚
â”‚           driver->probe(dev)                                     â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Kernel åŸå§‹ç¢¼è¿½è¹¤ï¼šreally_probe()

```c
/* drivers/base/dd.c - é€™æ˜¯å¯¦éš›å‘¼å« driver->probe() çš„åœ°æ–¹ */

static int really_probe(struct device *dev, struct device_driver *drv)
{
    int ret = -EPROBE_DEFER;
    
    /* 1. ç¶å®š driver åˆ° device */
    dev->driver = drv;
    
    /* 2. å‘¼å« bus çš„ probeï¼ˆå¦‚æœæœ‰ï¼‰ */
    if (dev->bus->probe) {
        ret = dev->bus->probe(dev);
    } else if (drv->probe) {
        /* 3. å‘¼å« driver çš„ probe */
        ret = drv->probe(dev);
    }
    
    if (ret) {
        /* 4. å¤±æ•—è™•ç† */
        dev->driver = NULL;
        
        if (ret == -EPROBE_DEFER) {
            /* åŠ å…¥ deferred probe åˆ—è¡¨ */
            driver_deferred_probe_add(dev);
        }
        return ret;
    }
    
    /* 5. æˆåŠŸï¼Œå»ºç«‹ sysfs links */
    driver_bound(dev);
    
    return 0;
}
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šCharacter Device å®Œæ•´å¯¦ä½œ

### 3.1 Character Device æ¶æ§‹

```
User Space: open("/dev/mydev", O_RDWR)
                    â”‚
                    â†“
Kernel VFS: æŸ¥æ‰¾ /dev/mydev çš„ inode
                    â”‚
                    â†“
cdev çµæ§‹: é€é major/minor æ‰¾åˆ°å°æ‡‰çš„ cdev
                    â”‚
                    â†“
file_operations: å‘¼å« .open å‡½å¼
```

### 3.2 å®Œæ•´ Character Device é©…å‹•ç¯„ä¾‹

```c
/* my_char_driver.c - å®Œæ•´çš„ Character Device é©…å‹• */

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "mychardev"
#define BUFFER_SIZE 1024

/* ç§æœ‰è³‡æ–™çµæ§‹ */
struct my_device_data {
    struct cdev cdev;
    char buffer[BUFFER_SIZE];
    size_t buffer_size;
    struct mutex lock;
};

static dev_t dev_num;
static struct class *my_class;
static struct my_device_data my_dev;

/* ============ File Operations ============ */

static int my_open(struct inode *inode, struct file *file)
{
    struct my_device_data *data;
    
    /* å¾ inode å–å¾— cdevï¼Œå†æ‰¾åˆ°ç§æœ‰è³‡æ–™ */
    data = container_of(inode->i_cdev, struct my_device_data, cdev);
    file->private_data = data;
    
    pr_info("Device opened\n");
    return 0;
}

static int my_release(struct inode *inode, struct file *file)
{
    pr_info("Device closed\n");
    return 0;
}

static ssize_t my_read(struct file *file, char __user *buf,
                       size_t count, loff_t *offset)
{
    struct my_device_data *data = file->private_data;
    size_t to_read;
    int ret;
    
    mutex_lock(&data->lock);
    
    if (*offset >= data->buffer_size) {
        mutex_unlock(&data->lock);
        return 0;  /* EOF */
    }
    
    to_read = min(count, data->buffer_size - (size_t)*offset);
    
    /* å¾ kernel buffer è¤‡è£½åˆ° user buffer */
    ret = copy_to_user(buf, data->buffer + *offset, to_read);
    if (ret) {
        mutex_unlock(&data->lock);
        return -EFAULT;
    }
    
    *offset += to_read;
    
    mutex_unlock(&data->lock);
    
    pr_info("Read %zu bytes\n", to_read);
    return to_read;
}

static ssize_t my_write(struct file *file, const char __user *buf,
                        size_t count, loff_t *offset)
{
    struct my_device_data *data = file->private_data;
    size_t to_write;
    int ret;
    
    mutex_lock(&data->lock);
    
    to_write = min(count, (size_t)(BUFFER_SIZE - 1));
    
    /* å¾ user buffer è¤‡è£½åˆ° kernel buffer */
    ret = copy_from_user(data->buffer, buf, to_write);
    if (ret) {
        mutex_unlock(&data->lock);
        return -EFAULT;
    }
    
    data->buffer[to_write] = '\0';
    data->buffer_size = to_write;
    
    mutex_unlock(&data->lock);
    
    pr_info("Written %zu bytes\n", to_write);
    return to_write;
}

static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct my_device_data *data = file->private_data;
    
    switch (cmd) {
    case 0x01:  /* æ¸…é™¤ buffer */
        mutex_lock(&data->lock);
        memset(data->buffer, 0, BUFFER_SIZE);
        data->buffer_size = 0;
        mutex_unlock(&data->lock);
        pr_info("Buffer cleared\n");
        return 0;
        
    case 0x02:  /* å–å¾— buffer å¤§å° */
        if (copy_to_user((size_t __user *)arg, &data->buffer_size,
                         sizeof(size_t)))
            return -EFAULT;
        return 0;
        
    default:
        return -EINVAL;
    }
}

static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .open = my_open,
    .release = my_release,
    .read = my_read,
    .write = my_write,
    .unlocked_ioctl = my_ioctl,
};

/* ============ Module Init/Exit ============ */

static int __init my_init(void)
{
    int ret;
    
    /* 1. å‹•æ…‹åˆ†é…è£ç½®è™Ÿç¢¼ */
    ret = alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME);
    if (ret < 0) {
        pr_err("Failed to allocate device number\n");
        return ret;
    }
    pr_info("Allocated major=%d, minor=%d\n", MAJOR(dev_num), MINOR(dev_num));
    
    /* 2. å»ºç«‹è£ç½®é¡åˆ¥ï¼ˆæœƒåœ¨ /sys/class ä¸‹å»ºç«‹ç›®éŒ„ï¼‰ */
    my_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(my_class)) {
        unregister_chrdev_region(dev_num, 1);
        return PTR_ERR(my_class);
    }
    
    /* 3. åˆå§‹åŒ– cdev ä¸¦åŠ å…¥ kernel */
    cdev_init(&my_dev.cdev, &my_fops);
    my_dev.cdev.owner = THIS_MODULE;
    
    ret = cdev_add(&my_dev.cdev, dev_num, 1);
    if (ret < 0) {
        class_destroy(my_class);
        unregister_chrdev_region(dev_num, 1);
        return ret;
    }
    
    /* 4. å»ºç«‹è£ç½®ç¯€é»ï¼ˆudev æœƒè‡ªå‹•å»ºç«‹ /dev/mychardevï¼‰ */
    if (IS_ERR(device_create(my_class, NULL, dev_num, NULL, DEVICE_NAME))) {
        cdev_del(&my_dev.cdev);
        class_destroy(my_class);
        unregister_chrdev_region(dev_num, 1);
        return -ENODEV;
    }
    
    /* 5. åˆå§‹åŒ–ç§æœ‰è³‡æ–™ */
    mutex_init(&my_dev.lock);
    my_dev.buffer_size = 0;
    
    pr_info("Driver loaded successfully\n");
    return 0;
}

static void __exit my_exit(void)
{
    device_destroy(my_class, dev_num);
    cdev_del(&my_dev.cdev);
    class_destroy(my_class);
    unregister_chrdev_region(dev_num, 1);
    
    pr_info("Driver unloaded\n");
}

module_init(my_init);
module_exit(my_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Complete Character Device Driver Example");
```

### 3.3 æ¸¬è©¦ Character Device

```bash
# è¼‰å…¥é©…å‹•
sudo insmod my_char_driver.ko

# æŸ¥çœ‹è£ç½®
ls -l /dev/mychardev
cat /sys/class/mychardev/mychardev/dev

# æ¸¬è©¦è®€å¯«
echo "Hello World" > /dev/mychardev
cat /dev/mychardev

# ä½¿ç”¨ ioctlï¼ˆéœ€è¦å¯«æ¸¬è©¦ç¨‹å¼ï¼‰

# å¸è¼‰é©…å‹•
sudo rmmod my_char_driver
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šPlatform Driver æ·±å…¥

### 4.1 ä»€éº¼æ˜¯ Platform Device/Driverï¼Ÿ

```c
/* Platform Deviceï¼šä¸åœ¨æ¨™æº–åŒ¯æµæ’ä¸Šçš„è£ç½®
 * 
 * ä¾‹å¦‚ï¼šSoC å…§å»ºçš„ UARTã€GPIOã€Timerã€SPI Controller
 * é€™äº›è£ç½®é€é Memory-Mapped I/O (MMIO) å­˜å–
 * 
 * ç‚ºä»€éº¼éœ€è¦ Platform Busï¼Ÿ
 * - çµ±ä¸€ç®¡ç† SoC å…§éƒ¨å‘¨é‚Š
 * - æ”¯æ´ Device Tree 
 * - åˆ©ç”¨ Device Model çš„ probe/remove æ©Ÿåˆ¶
 */

struct platform_device {
    const char *name;              /* è£ç½®åç¨± */
    int id;                        /* è£ç½® IDï¼ˆ-1 è¡¨ç¤ºå–®ä¸€è£ç½®ï¼‰ */
    bool id_auto;                  /* è‡ªå‹•åˆ†é… ID */
    struct device dev;             /* å…§åµŒçš„ device çµæ§‹ */
    u64 platform_dma_mask;         /* DMA é®ç½© */
    struct device_dma_parameters dma_parms;
    u32 num_resources;             /* è³‡æºæ•¸é‡ */
    struct resource *resource;     /* è³‡æºé™£åˆ—ï¼ˆè¨˜æ†¶é«”ã€IRQï¼‰ */
    const struct platform_device_id *id_entry; /* ID åŒ¹é…é … */
    struct pdev_archdata archdata; /* æ¶æ§‹ç›¸é—œè³‡æ–™ */
};

struct platform_driver {
    int (*probe)(struct platform_device *);    /* è£ç½®åˆå§‹åŒ– */
    int (*remove)(struct platform_device *);   /* è£ç½®ç§»é™¤ */
    void (*shutdown)(struct platform_device *);
    int (*suspend)(struct platform_device *, pm_message_t);
    int (*resume)(struct platform_device *);
    struct device_driver driver;               /* å…§åµŒçš„ driver */
    const struct platform_device_id *id_table; /* ID åŒ¹é…è¡¨ */
    bool prevent_deferred_probe;
    bool driver_managed_dma;
};
```

### 4.2 Platform Driver å®Œæ•´ç¯„ä¾‹ï¼ˆå« Device Treeï¼‰

```c
/* my_platform_driver.c */

#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/clk.h>

/* ç¡¬é«”æš«å­˜å™¨å®šç¾© */
#define REG_CTRL    0x00
#define REG_STATUS  0x04
#define REG_DATA    0x08

/* é©…å‹•ç§æœ‰è³‡æ–™ */
struct my_hw_device {
    void __iomem *base;        /* MMIO åŸºåº•ä½å€ */
    int irq;                   /* ä¸­æ–·è™Ÿç¢¼ */
    struct clk *clk;           /* æ™‚è„ˆ */
    u32 version;               /* ç¡¬é«”ç‰ˆæœ¬ */
    spinlock_t lock;           /* ä¿è­·ç¡¬é«”å­˜å– */
};

/* ä¸åŒç¡¬é«”ç‰ˆæœ¬çš„è³‡æ–™ */
struct my_hw_data {
    u32 version;
    u32 features;
};

static const struct my_hw_data v1_data = {
    .version = 1,
    .features = 0x01,
};

static const struct my_hw_data v2_data = {
    .version = 2,
    .features = 0x0F,
};

/* ä¸­æ–·è™•ç† */
static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    struct my_hw_device *hw = dev_id;
    u32 status;
    
    spin_lock(&hw->lock);
    
    status = readl(hw->base + REG_STATUS);
    
    /* æ¸…é™¤ä¸­æ–· */
    writel(status, hw->base + REG_STATUS);
    
    spin_unlock(&hw->lock);
    
    pr_info("IRQ handled, status=0x%08x\n", status);
    
    return IRQ_HANDLED;
}

static int my_probe(struct platform_device *pdev)
{
    struct my_hw_device *hw;
    struct resource *res;
    const struct my_hw_data *hw_data;
    int ret;
    
    dev_info(&pdev->dev, "Probing...\n");
    
    /* 1. åˆ†é…ç§æœ‰è³‡æ–™ï¼ˆä½¿ç”¨ devm_ï¼Œè‡ªå‹•ç®¡ç†è¨˜æ†¶é«”ï¼‰ */
    hw = devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);
    if (!hw)
        return -ENOMEM;
    
    spin_lock_init(&hw->lock);
    
    /* 2. å–å¾— Device Tree ä¸­çš„ compatible ç‰¹å®šè³‡æ–™ */
    hw_data = of_device_get_match_data(&pdev->dev);
    if (hw_data) {
        hw->version = hw_data->version;
        dev_info(&pdev->dev, "Hardware version: %u\n", hw->version);
    }
    
    /* 3. å–å¾—è¨˜æ†¶é«”è³‡æºä¸¦æ˜ å°„ */
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    hw->base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(hw->base)) {
        dev_err(&pdev->dev, "Failed to map registers\n");
        return PTR_ERR(hw->base);
    }
    
    dev_info(&pdev->dev, "Mapped %pR to %p\n", res, hw->base);
    
    /* 4. å–å¾— IRQ */
    hw->irq = platform_get_irq(pdev, 0);
    if (hw->irq < 0) {
        dev_err(&pdev->dev, "Failed to get IRQ\n");
        return hw->irq;
    }
    
    /* 5. è¨»å†Šä¸­æ–· */
    ret = devm_request_irq(&pdev->dev, hw->irq, my_irq_handler,
                           IRQF_SHARED, dev_name(&pdev->dev), hw);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }
    
    /* 6. å–å¾— Clockï¼ˆå¯èƒ½ deferï¼‰ */
    hw->clk = devm_clk_get(&pdev->dev, NULL);
    if (IS_ERR(hw->clk)) {
        ret = PTR_ERR(hw->clk);
        if (ret == -EPROBE_DEFER) {
            dev_dbg(&pdev->dev, "Clock not ready, deferring\n");
            return ret;
        }
        /* Clock å¯é¸ï¼Œç¹¼çºŒåŸ·è¡Œ */
        hw->clk = NULL;
    }
    
    /* 7. å•Ÿç”¨ Clock */
    if (hw->clk) {
        ret = clk_prepare_enable(hw->clk);
        if (ret) {
            dev_err(&pdev->dev, "Failed to enable clock\n");
            return ret;
        }
    }
    
    /* 8. å„²å­˜ç§æœ‰è³‡æ–™ */
    platform_set_drvdata(pdev, hw);
    
    /* 9. åˆå§‹åŒ–ç¡¬é«” */
    writel(0x01, hw->base + REG_CTRL);  /* å•Ÿç”¨ */
    
    dev_info(&pdev->dev, "Probed successfully!\n");
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    struct my_hw_device *hw = platform_get_drvdata(pdev);
    
    /* åœç”¨ç¡¬é«” */
    writel(0x00, hw->base + REG_CTRL);
    
    /* åœç”¨ Clock */
    if (hw->clk)
        clk_disable_unprepare(hw->clk);
    
    dev_info(&pdev->dev, "Removed\n");
    return 0;
}

/* Device Tree åŒ¹é…è¡¨ */
static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device-v1", .data = &v1_data },
    { .compatible = "vendor,my-device-v2", .data = &v2_data },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, my_of_match);

/* Platform ID åŒ¹é…è¡¨ï¼ˆé DT ç³»çµ±ç”¨ï¼‰ */
static const struct platform_device_id my_id_table[] = {
    { "my-device", 0 },
    { }
};
MODULE_DEVICE_TABLE(platform, my_id_table);

static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-platform-driver",
        .of_match_table = my_of_match,
    },
    .id_table = my_id_table,
};

module_platform_driver(my_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Complete Platform Driver Example");
```

### 4.3 å°æ‡‰çš„ Device Tree

```dts
/* Device Tree å®šç¾© */
my_device@40000000 {
    compatible = "vendor,my-device-v2";
    reg = <0x40000000 0x1000>;      /* åŸºåº•ä½å€ + å¤§å° */
    interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clk_controller 5>;    /* å¼•ç”¨ clock */
    clock-names = "main";
    status = "okay";
};
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šMisc Deviceï¼ˆç°¡åŒ–ç‰ˆ Character Deviceï¼‰

### 5.1 ä»€éº¼æ˜¯ Misc Deviceï¼Ÿ

```c
/* Misc Device ä½¿ç”¨å›ºå®šçš„ Major Number (10)
 * é©åˆç°¡å–®çš„ character deviceï¼Œçœå»æ‰‹å‹•ç®¡ç† major/minor
 */

#include <linux/miscdevice.h>

struct miscdevice {
    int minor;                      /* MISC_DYNAMIC_MINOR = è‡ªå‹•åˆ†é… */
    const char *name;               /* /dev ä¸‹çš„åç¨± */
    const struct file_operations *fops;
    struct list_head list;
    struct device *parent;
    struct device *this_device;
    const struct attribute_group **groups;
    umode_t mode;
};
```

### 5.2 Misc Device ç¯„ä¾‹

```c
#include <linux/module.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>

static int my_misc_open(struct inode *inode, struct file *file)
{
    pr_info("Misc device opened\n");
    return 0;
}

static ssize_t my_misc_read(struct file *file, char __user *buf,
                            size_t count, loff_t *pos)
{
    char msg[] = "Hello from misc device!\n";
    size_t len = strlen(msg);
    
    if (*pos >= len)
        return 0;
    
    if (copy_to_user(buf, msg + *pos, min(count, len - (size_t)*pos)))
        return -EFAULT;
    
    *pos += min(count, len - (size_t)*pos);
    return min(count, len);
}

static const struct file_operations my_misc_fops = {
    .owner = THIS_MODULE,
    .open = my_misc_open,
    .read = my_misc_read,
};

static struct miscdevice my_misc = {
    .minor = MISC_DYNAMIC_MINOR,     /* è‡ªå‹•åˆ†é… minor */
    .name = "my_misc",               /* /dev/my_misc */
    .fops = &my_misc_fops,
};

static int __init my_misc_init(void)
{
    return misc_register(&my_misc);
}

static void __exit my_misc_exit(void)
{
    misc_deregister(&my_misc);
}

module_init(my_misc_init);
module_exit(my_misc_exit);
MODULE_LICENSE("GPL");
```

### 5.3 Platform Driver vs Misc Driver æ¯”è¼ƒ

| ç‰¹æ€§ | Platform Driver | Misc Driver | Character Device |
|:---|:---|:---|:---|
| ç”¨é€” | SoC å‘¨é‚Š | ç°¡å–®è£ç½® | é€šç”¨ |
| Device Tree | æ”¯æ´ | ä¸ç›´æ¥æ”¯æ´ | ä¸ç›´æ¥æ”¯æ´ |
| Major | çœ‹ bus | 10 (å›ºå®š) | å‹•æ…‹/æŒ‡å®š |
| è¤‡é›œåº¦ | ä¸­ | ä½ | é«˜ |
| è³‡æºç®¡ç† | è‡ªå‹• (platform) | æ‰‹å‹• | æ‰‹å‹• |

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šProbe æ™‚æ©Ÿèˆ‡ Deferred Probe

### 6.1 Probe ä½•æ™‚è¢«å‘¼å«ï¼Ÿ

```
ä¸‰ç¨®æƒ…æ³æœƒè§¸ç™¼ probeï¼š

1. Driver è¨»å†Šæ™‚ï¼Œå·²å­˜åœ¨åŒ¹é…çš„ Device
   driver_register() 
       â†’ bus_add_driver()
       â†’ driver_attach()
       â†’ bus_for_each_dev() 
       â†’ __driver_attach()
       â†’ driver_probe_device()
       â†’ really_probe()
       â†’ driver->probe()

2. Device è¨»å†Šæ™‚ï¼Œå·²å­˜åœ¨åŒ¹é…çš„ Driver
   device_register()
       â†’ device_add()
       â†’ bus_probe_device()
       â†’ device_attach()
       â†’ bus_for_each_drv()
       â†’ __device_attach_driver()
       â†’ driver_probe_device()
       â†’ really_probe()
       â†’ driver->probe()

3. Deferred Probe é‡è©¦
   - kernel å®šæœŸæª¢æŸ¥ deferred list
   - æˆ–æœ‰æ–° device/driver è¨»å†Šæ™‚è§¸ç™¼
```

### 6.2 Deferred Probe æ·±å…¥

```c
/* Deferred Probe çš„å®Œæ•´è™•ç† */

static int my_probe(struct platform_device *pdev)
{
    struct clk *clk;
    struct regulator *reg;
    struct gpio_desc *gpio;
    
    /* Clock ä¾è³´ */
    clk = devm_clk_get(&pdev->dev, "main");
    if (IS_ERR(clk)) {
        if (PTR_ERR(clk) == -EPROBE_DEFER) {
            dev_dbg(&pdev->dev, "Clock not ready\n");
            return -EPROBE_DEFER;
        }
        return PTR_ERR(clk);
    }
    
    /* Regulator ä¾è³´ */
    reg = devm_regulator_get(&pdev->dev, "vdd");
    if (IS_ERR(reg)) {
        if (PTR_ERR(reg) == -EPROBE_DEFER) {
            dev_dbg(&pdev->dev, "Regulator not ready\n");
            return -EPROBE_DEFER;
        }
        return PTR_ERR(reg);
    }
    
    /* GPIO ä¾è³´ */
    gpio = devm_gpiod_get(&pdev->dev, "reset", GPIOD_OUT_LOW);
    if (IS_ERR(gpio)) {
        if (PTR_ERR(gpio) == -EPROBE_DEFER) {
            dev_dbg(&pdev->dev, "GPIO not ready\n");
            return -EPROBE_DEFER;
        }
        return PTR_ERR(gpio);
    }
    
    /* æ‰€æœ‰ä¾è³´å°±ç·’ï¼Œç¹¼çºŒåˆå§‹åŒ– */
    return 0;
}

/* æª¢æŸ¥ deferred probe ç‹€æ…‹ */
$ cat /sys/kernel/debug/devices_deferred
```

### 6.3 Deferred Probe èª¿è©¦æŠ€å·§

```bash
# æŸ¥çœ‹ deferred çš„ devices
cat /sys/kernel/debug/devices_deferred

# å‹•æ…‹é–‹å•Ÿ probe ç›¸é—œ log
echo 'file dd.c +p' > /sys/kernel/debug/dynamic_debug/control

# é€é initcall_debug æŸ¥çœ‹ probe é †åº
# åœ¨ kernel command line åŠ ä¸Š initcall_debug
```

---

## ğŸ”· ç¬¬ä¸ƒéƒ¨åˆ†ï¼šdevm_ Managed Resource API

### 7.1 devm_ çš„é‹ä½œåŸç†

```c
/* devm_ = Device-managed resource
 * 
 * æ ¸å¿ƒæ¦‚å¿µï¼šå°‡è³‡æºçš„ç”Ÿå‘½é€±æœŸç¶å®šåˆ° device
 * ç•¶ device è¢« remove æˆ– probe å¤±æ•—æ™‚ï¼Œè‡ªå‹•é‡‹æ”¾
 */

/* å…§éƒ¨å¯¦ä½œï¼ˆç°¡åŒ–ï¼‰ */
void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp)
{
    struct devres *dr;
    
    /* åˆ†é… devres çµæ§‹ + ä½¿ç”¨è€…è³‡æ–™ */
    dr = alloc_dr(devm_kmalloc_release, size, gfp);
    if (!dr)
        return NULL;
    
    /* å°‡ dr åŠ å…¥ dev->devres_head åˆ—è¡¨ */
    devres_add(dev, dr);
    
    return dr->data;
}

/* ç•¶ device remove æ™‚ */
void device_release_driver(struct device *dev)
{
    /* ... */
    devres_release_all(dev);  /* é‡‹æ”¾æ‰€æœ‰ devm_ è³‡æº */
}
```

### 7.2 å¸¸ç”¨ devm_ API å®Œæ•´åˆ—è¡¨

```c
/* è¨˜æ†¶é«”åˆ†é… */
void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp);
void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp);
void *devm_kcalloc(struct device *dev, size_t n, size_t size, gfp_t gfp);
char *devm_kstrdup(struct device *dev, const char *s, gfp_t gfp);

/* I/O æ˜ å°„ */
void __iomem *devm_ioremap(struct device *dev, resource_size_t offset, 
                           resource_size_t size);
void __iomem *devm_ioremap_resource(struct device *dev, 
                                    const struct resource *res);
void __iomem *devm_platform_ioremap_resource(struct platform_device *pdev, 
                                             unsigned int index);

/* ä¸­æ–· */
int devm_request_irq(struct device *dev, unsigned int irq,
                     irq_handler_t handler, unsigned long irqflags,
                     const char *devname, void *dev_id);
int devm_request_threaded_irq(struct device *dev, unsigned int irq,
                              irq_handler_t handler, irq_handler_t thread_fn,
                              unsigned long irqflags, const char *devname,
                              void *dev_id);

/* Clock */
struct clk *devm_clk_get(struct device *dev, const char *id);
struct clk *devm_clk_get_optional(struct device *dev, const char *id);
int devm_clk_bulk_get(struct device *dev, int num_clks, 
                      struct clk_bulk_data *clks);

/* Regulator */
struct regulator *devm_regulator_get(struct device *dev, const char *id);
struct regulator *devm_regulator_get_optional(struct device *dev, 
                                              const char *id);

/* GPIO */
struct gpio_desc *devm_gpiod_get(struct device *dev, const char *con_id,
                                 enum gpiod_flags flags);
struct gpio_desc *devm_gpiod_get_optional(struct device *dev, 
                                          const char *con_id,
                                          enum gpiod_flags flags);

/* Pinctrl */
struct pinctrl *devm_pinctrl_get(struct device *dev);

/* Reset */
struct reset_control *devm_reset_control_get(struct device *dev, 
                                             const char *id);

/* è‡ªå®šç¾© action */
int devm_add_action(struct device *dev, void (*action)(void *), void *data);
int devm_add_action_or_reset(struct device *dev, void (*action)(void *), 
                             void *data);
```

### 7.3 devm_add_action è‡ªå®šç¾©æ¸…ç†

```c
/* ç•¶æ²’æœ‰å°æ‡‰çš„ devm_ API æ™‚ï¼Œç”¨ devm_add_action */

static void my_cleanup(void *data)
{
    struct my_resource *res = data;
    /* è‡ªå®šç¾©æ¸…ç†é‚è¼¯ */
    my_resource_free(res);
}

static int my_probe(struct platform_device *pdev)
{
    struct my_resource *res;
    
    res = my_resource_alloc();
    if (!res)
        return -ENOMEM;
    
    /* è¨»å†Šæ¸…ç† action */
    if (devm_add_action_or_reset(&pdev->dev, my_cleanup, res))
        return -ENOMEM;  /* my_cleanup å·²è¢«å‘¼å« */
    
    /* ä½¿ç”¨ res */
    return 0;
}
```

---

## ğŸ”· ç¬¬å…«éƒ¨åˆ†ï¼šsysfs / debugfs / procfs ä»‹é¢

### 8.1 sysfs ä»‹é¢ï¼ˆæœ€å¸¸ç”¨ï¼‰

```c
/* sysfs: /sys ä¸‹çš„æª”æ¡ˆç³»çµ±
 * ç”¨æ–¼ kernel èˆ‡ user space äº¤æ›è³‡è¨Š
 * ABI ç©©å®šï¼Œéœ€è¦å‘å¾Œç›¸å®¹
 */

#include <linux/device.h>

/* ç°¡å–® attribute */
static ssize_t my_attr_show(struct device *dev,
                            struct device_attribute *attr, char *buf)
{
    struct my_device *priv = dev_get_drvdata(dev);
    return sysfs_emit(buf, "%d\n", priv->value);  /* v5.10+ æ¨è–¦ç”¨æ³• */
}

static ssize_t my_attr_store(struct device *dev,
                             struct device_attribute *attr,
                             const char *buf, size_t count)
{
    struct my_device *priv = dev_get_drvdata(dev);
    int ret;
    
    ret = kstrtoint(buf, 10, &priv->value);
    if (ret)
        return ret;
    
    return count;
}

static DEVICE_ATTR_RW(my_attr);  /* å»ºç«‹ dev_attr_my_attr */

/* å”¯è®€ attribute */
static ssize_t status_show(struct device *dev,
                           struct device_attribute *attr, char *buf)
{
    return sysfs_emit(buf, "OK\n");
}
static DEVICE_ATTR_RO(status);  /* dev_attr_status */

/* Attribute ç¾¤çµ„ */
static struct attribute *my_attrs[] = {
    &dev_attr_my_attr.attr,
    &dev_attr_status.attr,
    NULL,
};
ATTRIBUTE_GROUPS(my);  /* å»ºç«‹ my_groups[] */

/* åœ¨ driver ä¸­ä½¿ç”¨ */
static struct platform_driver my_driver = {
    .driver = {
        .name = "my-driver",
        .dev_groups = my_groups,  /* è‡ªå‹•å»ºç«‹ sysfs attrs */
    },
};
```

### 8.2 debugfs ä»‹é¢ï¼ˆèª¿è©¦ç”¨ï¼‰

```c
/* debugfs: /sys/kernel/debug ä¸‹
 * ç”¨æ–¼ debug è³‡è¨Šï¼Œæ²’æœ‰ ABI ç©©å®šä¿è­‰
 * å¯éš¨æ™‚è®Šå‹•æ ¼å¼
 */

#include <linux/debugfs.h>

static struct dentry *debugfs_root;
static u32 debug_value;

/* ç°¡å–®çš„æ•¸å€¼ */
debugfs_create_u32("my_value", 0644, debugfs_root, &debug_value);

/* è¤‡é›œçš„è¼¸å‡º */
static int my_seq_show(struct seq_file *s, void *data)
{
    struct my_device *priv = s->private;
    
    seq_printf(s, "=== Device Status ===\n");
    seq_printf(s, "Base: %p\n", priv->base);
    seq_printf(s, "REG_CTRL:   0x%08x\n", readl(priv->base + 0x00));
    seq_printf(s, "REG_STATUS: 0x%08x\n", readl(priv->base + 0x04));
    seq_printf(s, "REG_DATA:   0x%08x\n", readl(priv->base + 0x08));
    
    return 0;
}
DEFINE_SHOW_ATTRIBUTE(my_seq);  /* å»ºç«‹ my_seq_fops */

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    /* ... åˆå§‹åŒ– priv ... */
    
    /* å»ºç«‹ debugfs */
    priv->debugfs_dir = debugfs_create_dir("my_device", NULL);
    debugfs_create_file("status", 0444, priv->debugfs_dir, priv, 
                        &my_seq_fops);
    debugfs_create_x32("ctrl_reg", 0644, priv->debugfs_dir, 
                       &priv->ctrl_value);
    
    return 0;
}
```

### 8.3 procfs ä»‹é¢ï¼ˆè¼ƒå°‘ç”¨æ–¼æ–°é©…å‹•ï¼‰

```c
/* procfs: /proc ä¸‹
 * ä¸»è¦ç”¨æ–¼ process è³‡è¨Š
 * æ–°é©…å‹•å»ºè­°ç”¨ sysfs æˆ– debugfs
 */

#include <linux/proc_fs.h>
#include <linux/seq_file.h>

static int my_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, "Hello from /proc\n");
    return 0;
}

static int my_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_proc_show, NULL);
}

static const struct proc_ops my_proc_ops = {
    .proc_open = my_proc_open,
    .proc_read = seq_read,
    .proc_lseek = seq_lseek,
    .proc_release = single_release,
};

/* å»ºç«‹ /proc/my_entry */
proc_create("my_entry", 0, NULL, &my_proc_ops);
```

---

## ğŸ”· ç¬¬ä¹éƒ¨åˆ†ï¼šKernel Synchronization åœ¨ Driver ä¸­çš„æ‡‰ç”¨

### 9.1 ä½•æ™‚éœ€è¦åŒæ­¥ï¼Ÿ

```c
/* éœ€è¦åŒæ­¥çš„å ´æ™¯ï¼š
 * 1. å¤šå€‹ process åŒæ™‚å­˜å– driver
 * 2. Interrupt handler å’Œ process context å…±äº«è³‡æ–™
 * 3. å¤š CPU åŒæ™‚å­˜å–
 */

/* å…±äº«è³‡æ–™çš„ä¿è­·åŸå‰‡ï¼š
 * - ä»»ä½•æ™‚å€™è®€å¯«å…±äº«è³‡æ–™ï¼Œéƒ½è¦æŒæœ‰é©ç•¶çš„ lock
 * - ä½¿ç”¨æœ€å°ç¯„åœçš„ lockï¼ˆæ¸›å°‘ contentionï¼‰
 */
```

### 9.2 Mutexï¼ˆå¯ç¡çœ ï¼Œé©åˆé•·æ“ä½œï¼‰

```c
#include <linux/mutex.h>

struct my_device {
    struct mutex lock;
    int data;
};

static ssize_t my_read(struct file *file, char __user *buf, 
                       size_t count, loff_t *pos)
{
    struct my_device *dev = file->private_data;
    int ret;
    
    /* å–å¾— lockï¼ˆå¯èƒ½ç¡çœ ï¼‰ */
    if (mutex_lock_interruptible(&dev->lock))
        return -ERESTARTSYS;
    
    /* å¯ä»¥å®‰å…¨å­˜å– dev->data */
    ret = copy_to_user(buf, &dev->data, sizeof(dev->data));
    
    mutex_unlock(&dev->lock);
    
    return ret ? -EFAULT : sizeof(dev->data);
}
```

### 9.3 Spinlockï¼ˆä¸å¯ç¡çœ ï¼Œé©åˆçŸ­æ“ä½œå’Œä¸­æ–·ï¼‰

```c
#include <linux/spinlock.h>

struct my_device {
    spinlock_t lock;
    u32 status;
    void __iomem *base;
};

/* Process Context */
static void my_update_status(struct my_device *dev)
{
    unsigned long flags;
    
    spin_lock_irqsave(&dev->lock, flags);  /* ç¦ç”¨ä¸­æ–· + å–å¾— lock */
    dev->status = readl(dev->base + REG_STATUS);
    spin_unlock_irqrestore(&dev->lock, flags);
}

/* Interrupt Handler */
static irqreturn_t my_irq_handler(int irq, void *data)
{
    struct my_device *dev = data;
    
    spin_lock(&dev->lock);  /* ä¸­æ–·ä¸­ï¼Œä¸éœ€è¦ save flags */
    writel(dev->status, dev->base + REG_CTRL);
    spin_unlock(&dev->lock);
    
    return IRQ_HANDLED;
}
```

### 9.4 Completionï¼ˆç­‰å¾…äº‹ä»¶å®Œæˆï¼‰

```c
#include <linux/completion.h>

struct my_device {
    struct completion done;
    int result;
};

/* ç™¼èµ·æ“ä½œçš„ç·šç¨‹ */
static int my_do_operation(struct my_device *dev)
{
    /* é‡ç½® completion */
    reinit_completion(&dev->done);
    
    /* ç™¼é€å‘½ä»¤çµ¦ç¡¬é«” */
    start_hardware_operation(dev);
    
    /* ç­‰å¾…å®Œæˆï¼ˆå¯ä¸­æ–·ï¼Œtimeout 5 ç§’ï¼‰ */
    if (!wait_for_completion_interruptible_timeout(&dev->done, 
            msecs_to_jiffies(5000))) {
        dev_err(dev->dev, "Operation timeout\n");
        return -ETIMEDOUT;
    }
    
    return dev->result;
}

/* ä¸­æ–·è™•ç†å™¨ */
static irqreturn_t my_irq_handler(int irq, void *data)
{
    struct my_device *dev = data;
    
    dev->result = readl(dev->base + REG_RESULT);
    complete(&dev->done);  /* å–šé†’ç­‰å¾…çš„ç·šç¨‹ */
    
    return IRQ_HANDLED;
}
```

### 9.5 Wait Queueï¼ˆç­‰å¾…æ¢ä»¶æˆç«‹ï¼‰

```c
#include <linux/wait.h>

struct my_device {
    wait_queue_head_t wait_queue;
    bool data_ready;
    spinlock_t lock;
};

static ssize_t my_read(struct file *file, char __user *buf,
                       size_t count, loff_t *pos)
{
    struct my_device *dev = file->private_data;
    int ret;
    
    /* ç­‰å¾… data_ready è®Šæˆ true */
    ret = wait_event_interruptible(dev->wait_queue, dev->data_ready);
    if (ret)
        return ret;
    
    spin_lock(&dev->lock);
    /* è®€å–è³‡æ–™ */
    dev->data_ready = false;
    spin_unlock(&dev->lock);
    
    return count;
}

static irqreturn_t my_irq_handler(int irq, void *data)
{
    struct my_device *dev = data;
    
    spin_lock(&dev->lock);
    /* æ”¶åˆ°è³‡æ–™ */
    dev->data_ready = true;
    spin_unlock(&dev->lock);
    
    wake_up_interruptible(&dev->wait_queue);  /* å–šé†’ç­‰å¾…è€… */
    
    return IRQ_HANDLED;
}
```

### 9.6 åŒæ­¥æ©Ÿåˆ¶é¸æ“‡æŒ‡å—

| æ©Ÿåˆ¶ | ç¡çœ  | ä¸­æ–·ä¸­ä½¿ç”¨ | é©ç”¨å ´æ™¯ |
|:---|:---:|:---:|:---|
| mutex | âœ… | âŒ | é•·æ“ä½œã€æª”æ¡ˆ I/O |
| spinlock | âŒ | âœ… | çŸ­æ“ä½œã€ç¡¬é«”æš«å­˜å™¨ |
| spinlock_irqsave | âŒ | âœ… | èˆ‡ IRQ å…±äº«è³‡æ–™ |
| completion | âœ… | âœ…(å®Œæˆ) | ç­‰å¾…å–®ä¸€äº‹ä»¶ |
| wait_queue | âœ… | âœ…(å–šé†’) | ç­‰å¾…æ¢ä»¶æˆç«‹ |
| semaphore | âœ… | âŒ | è³‡æºè¨ˆæ•¸ï¼ˆè¼ƒå°‘ç”¨ï¼‰ |

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Platform Driver çš„ probe ä½•æ™‚è¢«å‘¼å«ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š
ä¸‰ç¨®æƒ…æ³ï¼š
1. Driver è¨»å†Šæ™‚ï¼ŒBus éæ­·å·²è¨»å†Šçš„ Device å°‹æ‰¾åŒ¹é…
2. Device è¨»å†Šæ™‚ï¼ŒBus éæ­·å·²è¨»å†Šçš„ Driver å°‹æ‰¾åŒ¹é…
3. Deferred Probe é‡è©¦

åŒ¹é…å¾Œç”± `really_probe()` å‘¼å« `driver->probe()`ã€‚

---

### Q2: ä»€éº¼æ˜¯ Deferred Probeï¼Ÿä»€éº¼æ™‚å€™å›å‚³ -EPROBE_DEFERï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š
ç•¶ probe ä¾è³´çš„è³‡æºï¼ˆclockã€regulatorã€GPIO controllerï¼‰å°šæœªå°±ç·’æ™‚ï¼Œå›å‚³ `-EPROBE_DEFER`ã€‚
Kernel æœƒå°‡è£ç½®åŠ å…¥ `deferred_probe_pending_list`ï¼Œç¨å¾Œé‡è©¦ã€‚

å¸¸è¦‹ä¾è³´ï¼š
- `devm_clk_get()` å›å‚³ `-EPROBE_DEFER`
- `devm_regulator_get()` å›å‚³ `-EPROBE_DEFER`
- `devm_gpiod_get()` å›å‚³ `-EPROBE_DEFER`

---

### Q3: è§£é‡‹ Linux Device Model ä¸­ deviceã€driverã€bus çš„é—œä¿‚

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / AMD

**ç­”æ¡ˆ**ï¼š
- **device**ï¼šä»£è¡¨ç¡¬é«”è£ç½®ï¼ŒåŒ…å«è³‡æºï¼ˆMEMã€IRQï¼‰
- **driver**ï¼šä»£è¡¨é©…å‹•ç¨‹å¼ï¼ŒåŒ…å« probe/remove å‡½å¼
- **bus**ï¼šé€£æ¥ device å’Œ driverï¼Œè² è²¬ match

æµç¨‹ï¼š
1. Device æˆ– Driver è¨»å†Šåˆ° Bus
2. Bus åŸ·è¡Œ match() å‡½å¼æ¯”å°
3. åŒ¹é…æˆåŠŸï¼Œå‘¼å« driver->probe()

---

### Q4: devm_ API çš„å„ªé»ï¼Ÿä»€éº¼æƒ…æ³ä¸è©²ç”¨ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­

**ç­”æ¡ˆ**ï¼š

**å„ªé»**ï¼š
1. è‡ªå‹•è³‡æºç®¡ç†ï¼Œä¸éœ€æ‰‹å‹• free/unmap
2. é¿å… error path ä¸­çš„è³‡æºæ´©æ¼
3. ç¨‹å¼ç¢¼æ›´ç°¡æ½”
4. æŒ‰åˆ†é…çš„ç›¸åé †åºè‡ªå‹•é‡‹æ”¾

**ä¸è©²ç”¨çš„æƒ…æ³**ï¼š
- è³‡æºç”Ÿå‘½é€±æœŸä¸è·Ÿéš¨ deviceï¼ˆå¦‚è·¨ device å…±äº«ï¼‰
- éœ€è¦ç²¾ç¢ºæ§åˆ¶é‡‹æ”¾æ™‚æ©Ÿ

---

### Q5: åœ¨ Interrupt Context å¯ä»¥å‘¼å« mutex_lock() å—ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ‰€æœ‰å…¬å¸

**ç­”æ¡ˆ**ï¼š
**ä¸å¯ä»¥ï¼**

åŸå› ï¼š
- `mutex_lock()` å¯èƒ½ç¡çœ 
- ç¡çœ éœ€è¦ context switch
- Interrupt context æ²’æœ‰ process context å¯ä»¥åˆ‡å‡ºå»
- Kernel æœƒ BUG() æˆ–ç³»çµ± hang

æ›¿ä»£æ–¹æ¡ˆï¼š
- ä½¿ç”¨ spinlock_irqsave()
- ç”¨ workqueue å»¶é²åˆ° process context

---

### Q6: sysfs vs debugfs vs procfs çš„å€åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­

| ç‰¹æ€§ | sysfs | debugfs | procfs |
|:---|:---|:---|:---|
| ä½ç½® | /sys | /sys/kernel/debug | /proc |
| ç”¨é€” | è£ç½®å±¬æ€§ | Debug è³‡è¨Š | Process è³‡è¨Š |
| ABI ç©©å®šæ€§ | ç©©å®š | å¯éš¨æ™‚è®Šå‹• | éƒ¨åˆ†ç©©å®š |
| æ¨è–¦ç”¨é€” | å°å¤–ä»‹é¢ | é–‹ç™¼èª¿è©¦ | é¿å…æ–°å¢ |

---

### Q7: å¦‚ä½• debug deferred probe å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
```bash
# æŸ¥çœ‹ deferred devices
cat /sys/kernel/debug/devices_deferred

# é–‹å•Ÿ probe debug log
echo 'file dd.c +p' > /sys/kernel/debug/dynamic_debug/control

# Kernel command line
initcall_debug
```

---

### Q8: container_of çš„ç”¨æ³•å’ŒåŸç†ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
```c
/* å¾çµæ§‹é«”æˆå“¡æŒ‡æ¨™ï¼Œå–å¾—çµæ§‹é«”æœ¬èº«çš„æŒ‡æ¨™ */
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))

/* ä½¿ç”¨ç¯„ä¾‹ */
struct my_device {
    int a;
    struct cdev cdev;  /* offset = 4 (assuming int = 4 bytes) */
    int b;
};

/* å¾ cdev å–å¾— my_device */
struct my_device *dev = container_of(inode->i_cdev, struct my_device, cdev);

/* åŸç†ï¼šç”¨ cdev çš„ä½å€æ¸›å» cdev åœ¨çµæ§‹é«”ä¸­çš„ offset */
```

---

### Q9: Platform Driver å’Œ I2C/SPI Driver æœ‰ä»€éº¼å€åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | Platform Driver | I2C/SPI Driver |
|:---|:---|:---|
| Bus é¡å‹ | platform_bus | i2c_bus / spi_bus |
| è£ç½®ç™¼ç¾ | Device Tree / ACPI | Bus enumerate |
| è³‡æºä¾†æº | platform_device çš„ resource | i2c_client / spi_device |
| ä½å€ç©ºé–“ | Memory-Mapped I/O (MMIO) | é€é bus protocol |
| å¯¦é«”é€£æ¥ | SoC å…§éƒ¨å‘¨é‚Š | å¤–éƒ¨æ™¶ç‰‡ |

```c
/* Platform Driver */
static struct platform_driver my_platform = {
    .probe = my_platform_probe,
    .driver = {
        .name = "my-device",
        .of_match_table = my_of_match,
    },
};

/* I2C Driver */
static struct i2c_driver my_i2c = {
    .probe = my_i2c_probe,
    .driver = {
        .name = "my-i2c-device",
        .of_match_table = my_of_match,
    },
    .id_table = my_i2c_ids,
};
```

---

### Q10: å¦‚ä½•åœ¨ Driver ä¸­æ­£ç¢ºè™•ç† Error Pathï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / NVIDIA

**ç­”æ¡ˆ**ï¼š

**å‚³çµ±åšæ³•ï¼ˆgoto cleanupï¼‰ï¼š**
```c
static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    int ret;
    
    priv = kzalloc(sizeof(*priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;
    
    priv->base = ioremap(res->start, resource_size(res));
    if (!priv->base) {
        ret = -ENOMEM;
        goto err_free_priv;
    }
    
    ret = request_irq(irq, my_handler, 0, "my-dev", priv);
    if (ret)
        goto err_unmap;
    
    ret = misc_register(&priv->misc);
    if (ret)
        goto err_free_irq;
    
    return 0;

err_free_irq:
    free_irq(irq, priv);
err_unmap:
    iounmap(priv->base);
err_free_priv:
    kfree(priv);
    return ret;
}
```

**ç¾ä»£åšæ³•ï¼ˆdevm_ï¼‰ï¼š**
```c
static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    if (!priv)
        return -ENOMEM;
    
    priv->base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(priv->base))
        return PTR_ERR(priv->base);
    
    ret = devm_request_irq(&pdev->dev, irq, my_handler, 0, "my-dev", priv);
    if (ret)
        return ret;
    
    /* æ²’æœ‰å°æ‡‰ devm_ API çš„è³‡æºï¼Œç”¨ devm_add_action */
    ret = devm_add_action_or_reset(&pdev->dev, my_cleanup, priv);
    if (ret)
        return ret;  /* cleanup å·²è¢«å‘¼å« */
    
    return 0;
}
```

**é—œéµé»**ï¼š
1. ä½¿ç”¨ devm_ API å¯å®Œå…¨æ¶ˆé™¤ goto cleanup
2. ä»»ä½•å¤±æ•—é»ï¼Œå·²åˆ†é…çš„ devm_ è³‡æºè‡ªå‹•é‡‹æ”¾
3. ç¨‹å¼ç¢¼æ›´ç°¡æ½”ã€æ›´ä¸å®¹æ˜“å‡ºéŒ¯

---

### Q11: è§£é‡‹ Device Tree compatible çš„åŒ¹é…æ©Ÿåˆ¶

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šè¯ç™¼ç§‘ / Qualcomm

**ç­”æ¡ˆ**ï¼š

```dts
/* Device Tree ä¸­çš„å®šç¾© */
my_device@10000 {
    compatible = "vendor,my-device-v2", "vendor,my-device";
    reg = <0x10000 0x1000>;
};
```

```c
/* Driver ä¸­çš„ of_device_id è¡¨ */
static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device-v2", .data = &config_v2 },
    { .compatible = "vendor,my-device", .data = &config_v1 },
    { /* sentinel */ }
};
MODULE_DEVICE_TABLE(of, my_of_match);
```

**åŒ¹é…è¦å‰‡**ï¼š
1. Kernel å¾ DT çš„ `compatible` åˆ—è¡¨**å¾å·¦åˆ°å³**åŒ¹é…
2. å…ˆå¯«çš„å„ªå…ˆï¼ˆ`my-device-v2` å…ˆæ–¼ `my-device`ï¼‰
3. åŒ¹é…æˆåŠŸå¾Œï¼Œå¯é€é `of_match_device()` å–å¾— `.data`

```c
static int my_probe(struct platform_device *pdev)
{
    const struct of_device_id *match;
    const struct my_config *config;
    
    match = of_match_device(my_of_match, &pdev->dev);
    if (!match)
        return -ENODEV;
    
    config = match->data;  /* å–å¾—å°æ‡‰çš„ config */
    
    /* æ ¹æ“š config é€²è¡Œä¸åŒåˆå§‹åŒ– */
    if (config->version == 2) {
        /* v2 ç‰¹æœ‰çš„åˆå§‹åŒ– */
    }
    
    return 0;
}
```

**é€²éšï¼šfallback æ©Ÿåˆ¶**
```dts
/* æ–°æ™¶ç‰‡ä½¿ç”¨æ–° driverï¼ŒèˆŠæ™¶ç‰‡å›é€€åˆ°èˆŠ driver */
compatible = "vendor,chip-2023", "vendor,chip-2020", "generic,base-driver";
```

---

### Q12: spinlock_irqsave å’Œ spin_lock_irq çš„å€åˆ¥ï¼Ÿä½•æ™‚ç”¨å“ªå€‹ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ‰€æœ‰å…¬å¸

**ç­”æ¡ˆ**ï¼š

```c
/* spin_lock_irqï¼šå‡è¨­ä¸­æ–·åŸæœ¬æ˜¯é–‹å•Ÿçš„ */
spin_lock_irq(&lock);
/* ... critical section ... */
spin_unlock_irq(&lock);  /* å¼·åˆ¶é–‹å•Ÿä¸­æ–· */

/* spin_lock_irqsaveï¼šä¿å­˜ä¸¦æ¢å¾©åŸæœ¬çš„ä¸­æ–·ç‹€æ…‹ */
unsigned long flags;
spin_lock_irqsave(&lock, flags);  /* ä¿å­˜ flags */
/* ... critical section ... */
spin_unlock_irqrestore(&lock, flags);  /* æ¢å¾© flags */
```

**é¸æ“‡è¦å‰‡**ï¼š

| å ´æ™¯ | ä½¿ç”¨ |
|:---|:---|
| ç¢ºå®šä¸­æ–·ä¸€å®šæ˜¯é–‹çš„ | `spin_lock_irq` |
| ä¸ç¢ºå®šä¸­æ–·ç‹€æ…‹ï¼ˆé€šç”¨å‡½å¼ï¼‰ | `spin_lock_irqsave` |
| è¢«å¤šå€‹ context å‘¼å«çš„å‡½å¼ | `spin_lock_irqsave` |
| ä¸­æ–·è™•ç†å™¨ä¸­ï¼ˆä¸­æ–·å·²é—œé–‰ï¼‰ | `spin_lock` |

**å¸¸è¦‹éŒ¯èª¤**ï¼š
```c
/* éŒ¯èª¤ï¼šåœ¨å·²ç¶“é—œé–‰ä¸­æ–·çš„ context ä½¿ç”¨ spin_lock_irq */
irqreturn_t my_handler(int irq, void *data)
{
    spin_lock_irq(&lock);  /* âŒ è¿”å›æ™‚æœƒéŒ¯èª¤åœ°é–‹å•Ÿä¸­æ–· */
    /* ... */
    spin_unlock_irq(&lock);
    return IRQ_HANDLED;
}

/* æ­£ç¢º */
irqreturn_t my_handler(int irq, void *data)
{
    spin_lock(&lock);  /* âœ… ä¸­æ–·è™•ç†ä¸­ä½¿ç”¨ spin_lock */
    /* ... */
    spin_unlock(&lock);
    return IRQ_HANDLED;
}
```

---

### Q13: å¦‚ä½•åœ¨ Driver ä¸­å¯¦ç¾ Power Management (PM)ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Qualcomm / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š

```c
/* dev_pm_ops çµæ§‹ */
static int my_suspend(struct device *dev)
{
    struct my_device *priv = dev_get_drvdata(dev);
    
    /* 1. åœæ­¢ç¡¬é«”æ“ä½œ */
    writel(0, priv->base + REG_ENABLE);
    
    /* 2. é—œé–‰ clock */
    clk_disable_unprepare(priv->clk);
    
    /* 3. ä¿å­˜å¿…è¦çš„æš«å­˜å™¨ç‹€æ…‹ */
    priv->saved_ctrl = readl(priv->base + REG_CTRL);
    
    return 0;
}

static int my_resume(struct device *dev)
{
    struct my_device *priv = dev_get_drvdata(dev);
    
    /* 1. é–‹å•Ÿ clock */
    clk_prepare_enable(priv->clk);
    
    /* 2. æ¢å¾©æš«å­˜å™¨ç‹€æ…‹ */
    writel(priv->saved_ctrl, priv->base + REG_CTRL);
    
    /* 3. é‡æ–°å•Ÿå‹•ç¡¬é«” */
    writel(1, priv->base + REG_ENABLE);
    
    return 0;
}

/* Runtime PM */
static int my_runtime_suspend(struct device *dev)
{
    struct my_device *priv = dev_get_drvdata(dev);
    clk_disable_unprepare(priv->clk);
    return 0;
}

static int my_runtime_resume(struct device *dev)
{
    struct my_device *priv = dev_get_drvdata(dev);
    return clk_prepare_enable(priv->clk);
}

static const struct dev_pm_ops my_pm_ops = {
    /* System PM */
    SET_SYSTEM_SLEEP_PM_OPS(my_suspend, my_resume)
    /* Runtime PM */
    SET_RUNTIME_PM_OPS(my_runtime_suspend, my_runtime_resume, NULL)
};

static struct platform_driver my_driver = {
    .driver = {
        .name = "my-device",
        .pm = &my_pm_ops,
    },
};

/* åœ¨ probe ä¸­å•Ÿç”¨ Runtime PM */
static int my_probe(struct platform_device *pdev)
{
    /* ... åˆå§‹åŒ– ... */
    
    pm_runtime_enable(&pdev->dev);
    pm_runtime_set_active(&pdev->dev);
    pm_runtime_use_autosuspend(&pdev->dev);
    pm_runtime_set_autosuspend_delay(&pdev->dev, 200);  /* 200ms */
    
    return 0;
}

/* åœ¨ä½¿ç”¨ç¡¬é«”å‰å¾Œå‘¼å« */
static int my_operation(struct my_device *priv)
{
    int ret;
    
    ret = pm_runtime_resume_and_get(priv->dev);
    if (ret < 0)
        return ret;
    
    /* ä½¿ç”¨ç¡¬é«” */
    
    pm_runtime_mark_last_busy(priv->dev);
    pm_runtime_put_autosuspend(priv->dev);
    
    return 0;
}
```

---

### Q14: module_init å’Œ module_exit ä»€éº¼æ™‚å€™è¢«å‘¼å«ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ™®é

**ç­”æ¡ˆ**ï¼š

```c
/* module_initï¼šæ¨¡çµ„è¼‰å…¥æ™‚å‘¼å« */
- insmod / modprobe è¼‰å…¥æ¨¡çµ„
- Built-in driverï¼škernel å•Ÿå‹•æ™‚çš„ initcall éšæ®µ
  - pure_initcall (0)
  - core_initcall (1)
  - ...
  - device_initcall (6) â† å¤§å¤šæ•¸ driver
  - late_initcall (7)

/* module_exitï¼šæ¨¡çµ„å¸è¼‰æ™‚å‘¼å« */
- rmmod å¸è¼‰æ¨¡çµ„
- Built-in driverï¼šä¸æœƒè¢«å‘¼å«ï¼ˆé™¤é shutdownï¼‰

/* module_platform_driver çš„å±•é–‹ */
module_platform_driver(my_driver);

/* ç­‰æ–¼ */
static int __init my_driver_init(void)
{
    return platform_driver_register(&my_driver);
}
module_init(my_driver_init);

static void __exit my_driver_exit(void)
{
    platform_driver_unregister(&my_driver);
}
module_exit(my_driver_exit);
```

**Built-in vs Module**ï¼š
| ç‰¹æ€§ | Built-in | Module |
|:---|:---|:---|
| ç·¨è­¯ | é€£çµåˆ° vmlinux | ç·¨è­¯æˆ .ko |
| è¼‰å…¥æ™‚æ©Ÿ | Kernel å•Ÿå‹•æ™‚ | å‹•æ…‹è¼‰å…¥ |
| exit function | ä¸æœƒè¢«å‘¼å« | rmmod æ™‚å‘¼å« |
| é™¤éŒ¯ | éœ€é‡ç·¨ kernel | å¯å‹•æ…‹æ›¿æ› |

---

### Q15: å¦‚ä½•åœ¨ Driver ä¸­ä½¿ç”¨ DMAï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šAMD / NVIDIA

**ç­”æ¡ˆ**ï¼š

```c
#include <linux/dma-mapping.h>

struct my_device {
    struct device *dev;
    void *cpu_addr;         /* CPU çœ‹åˆ°çš„è™›æ“¬ä½å€ */
    dma_addr_t dma_addr;    /* è£ç½®çœ‹åˆ°çš„ bus ä½å€ */
    size_t size;
};

/* ä¸€è‡´æ€§ DMA (Coherent DMA) */
/* CPU å’Œ device åŒæ™‚å¯è¦‹ï¼Œç„¡éœ€æ‰‹å‹•åŒæ­¥ */
static int my_alloc_coherent(struct my_device *priv)
{
    priv->cpu_addr = dma_alloc_coherent(priv->dev, priv->size,
                                        &priv->dma_addr, GFP_KERNEL);
    if (!priv->cpu_addr)
        return -ENOMEM;
    
    /* é…ç½®çµ¦ç¡¬é«” */
    writel(priv->dma_addr, priv->base + REG_DMA_ADDR);
    
    return 0;
}

/* Streaming DMA */
/* é©åˆå–®å‘å‚³è¼¸ï¼Œéœ€è¦æ‰‹å‹•åŒæ­¥ */
static int my_prepare_streaming(struct my_device *priv, void *buf, 
                                 size_t size, enum dma_data_direction dir)
{
    dma_addr_t dma;
    
    /* æ˜ å°„ */
    dma = dma_map_single(priv->dev, buf, size, dir);
    if (dma_mapping_error(priv->dev, dma))
        return -ENOMEM;
    
    /* äº¤çµ¦ç¡¬é«”è™•ç†... */
    
    /* å‚³è¼¸å®Œæˆå¾Œï¼ŒåŒæ­¥ä¸¦è§£é™¤æ˜ å°„ */
    dma_sync_single_for_cpu(priv->dev, dma, size, dir);
    dma_unmap_single(priv->dev, dma, size, dir);
    
    return 0;
}

/* Scatter-Gather DMAï¼ˆé©åˆå¤§é‡éé€£çºŒè³‡æ–™ï¼‰ */
static int my_sg_dma(struct my_device *priv, struct scatterlist *sg, 
                     int nents, enum dma_data_direction dir)
{
    int mapped;
    
    mapped = dma_map_sg(priv->dev, sg, nents, dir);
    if (mapped == 0)
        return -ENOMEM;
    
    /* éæ­· sg å–å¾— dma ä½å€ */
    struct scatterlist *s;
    int i;
    for_each_sg(sg, s, mapped, i) {
        dma_addr_t addr = sg_dma_address(s);
        size_t len = sg_dma_len(s);
        /* é…ç½®çµ¦ DMA controller */
    }
    
    /* å®Œæˆå¾Œè§£é™¤æ˜ å°„ */
    dma_unmap_sg(priv->dev, sg, nents, dir);
    
    return 0;
}
```

**DMA æ–¹å‘**ï¼š
| Direction | èªªæ˜ |
|:---|:---|
| `DMA_TO_DEVICE` | CPU â†’ Deviceï¼ˆå¯«å…¥ï¼‰ |
| `DMA_FROM_DEVICE` | Device â†’ CPUï¼ˆè®€å–ï¼‰ |
| `DMA_BIDIRECTIONAL` | é›™å‘ï¼ˆå°‘ç”¨ï¼Œæ•ˆèƒ½è¼ƒå·®ï¼‰ |

---

## ğŸ”· ç¬¬åéƒ¨åˆ†ï¼šé€²éšä¸»é¡Œ - kobject / kset / ktype

### 10.1 Linux Driver Model åº•å±¤æ¶æ§‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Linux Device Model å±¤æ¬¡çµæ§‹                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                       â”‚
â”‚   User Space                                                          â”‚
â”‚       â”‚                                                               â”‚
â”‚       â”‚ /sys/devices/platform/my-device/...                          â”‚
â”‚       â†“                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                         â”‚
â”‚   â”‚  sysfs  â”‚ â† ä½¿ç”¨è€…çœ‹åˆ°çš„æª”æ¡ˆç³»çµ±                                    â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                                         â”‚
â”‚        â”‚                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                                         â”‚
â”‚   â”‚ kobject â”‚ â† sysfs ä¸­çš„æ¯å€‹ç›®éŒ„                                     â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                                         â”‚
â”‚        â”‚                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                                         â”‚
â”‚   â”‚  kset   â”‚ â† åŒé¡å‹ kobject çš„é›†åˆ                                  â”‚
â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                                         â”‚
â”‚        â”‚                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                                         â”‚
â”‚   â”‚  ktype  â”‚ â† kobject çš„é¡å‹ï¼ˆå®šç¾© release, sysfs_opsï¼‰              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                         â”‚
â”‚                                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.2 kobject æ·±å…¥è§£æ

```c
/* include/linux/kobject.h */

struct kobject {
    const char          *name;          /* sysfs ä¸­çš„ç›®éŒ„åç¨± */
    struct list_head    entry;          /* é€£çµåˆ° kset */
    struct kobject      *parent;        /* çˆ¶ kobject */
    struct kset         *kset;          /* æ‰€å±¬çš„ kset */
    struct kobj_type    *ktype;         /* é¡å‹å®šç¾© */
    struct kernfs_node  *sd;            /* sysfs inode */
    struct kref         kref;           /* å¼•ç”¨è¨ˆæ•¸ */
    unsigned int        state_initialized:1;
    unsigned int        state_in_sysfs:1;
    unsigned int        state_add_uevent_sent:1;
    unsigned int        state_remove_uevent_sent:1;
};

/* ktype å®šç¾©äº† kobject çš„è¡Œç‚º */
struct kobj_type {
    void (*release)(struct kobject *kobj);  /* å¼•ç”¨è¨ˆæ•¸æ­¸é›¶æ™‚å‘¼å« */
    const struct sysfs_ops *sysfs_ops;      /* sysfs è®€å¯«æ“ä½œ */
    struct attribute **default_attrs;       /* é è¨­ attributesï¼ˆdeprecatedï¼‰ */
    const struct attribute_group **default_groups;  /* v5.x æ¨è–¦ */
    const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
    const void *(*namespace)(struct kobject *kobj);
    void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid);
};

/* kset æ˜¯ kobject çš„å®¹å™¨ */
struct kset {
    struct list_head list;          /* æ‰€æœ‰æˆå“¡çš„åˆ—è¡¨ */
    spinlock_t list_lock;
    struct kobject kobj;            /* kset æœ¬èº«ä¹Ÿæ˜¯ kobject */
    const struct kset_uevent_ops *uevent_ops;  /* uevent filter/name/envp */
};
```

### 10.3 kobject ç”Ÿå‘½é€±æœŸ

```c
/* å»ºç«‹ kobject */
void kobject_init(struct kobject *kobj, struct kobj_type *ktype);

/* åŠ å…¥ sysfs */
int kobject_add(struct kobject *kobj, struct kobject *parent, 
                const char *fmt, ...);

/* init + add åˆä½µ */
int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
                         struct kobject *parent, const char *fmt, ...);

/* ç™¼é€ uevent åˆ° user space */
int kobject_uevent(struct kobject *kobj, enum kobject_action action);

/* kobject å¼•ç”¨è¨ˆæ•¸ */
struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);  /* è¨ˆæ•¸æ­¸é›¶æ™‚å‘¼å« ktype->release */

/* å®Œæ•´ç¯„ä¾‹ */
static struct kobj_type my_ktype;
static struct kobject *my_kobj;

static void my_release(struct kobject *kobj)
{
    pr_info("kobject released\n");
    /* é‡‹æ”¾è³‡æº */
}

static ssize_t my_attr_show(struct kobject *kobj, struct attribute *attr,
                            char *buf)
{
    return sprintf(buf, "Hello from kobject\n");
}

static struct sysfs_ops my_sysfs_ops = {
    .show = my_attr_show,
};

static struct attribute my_attr = {
    .name = "my_attribute",
    .mode = 0444,
};

static struct attribute *my_attrs[] = {
    &my_attr,
    NULL,
};

static struct kobj_type my_ktype = {
    .release = my_release,
    .sysfs_ops = &my_sysfs_ops,
    .default_attrs = my_attrs,
};

static int __init my_init(void)
{
    my_kobj = kzalloc(sizeof(*my_kobj), GFP_KERNEL);
    if (!my_kobj)
        return -ENOMEM;
    
    kobject_init(my_kobj, &my_ktype);
    
    if (kobject_add(my_kobj, kernel_kobj, "my_kobject")) {
        kobject_put(my_kobj);
        return -EINVAL;
    }
    
    kobject_uevent(my_kobj, KOBJ_ADD);
    
    return 0;
}

static void __exit my_exit(void)
{
    kobject_put(my_kobj);
}
```

### 10.4 Device Model å’Œ kobject çš„é—œä¿‚

```c
/* struct device å…§åµŒ kobject */
struct device {
    struct kobject kobj;  /* sysfs ç¯€é» */
    /* ... */
};

/* å¾ kobject å–å¾— device */
#define to_dev(obj) container_of(obj, struct device, kobj)

/* struct device_driver ä¹Ÿæœ‰ kobject */
struct device_driver {
    /* ... */
    struct driver_private *p;
};

struct driver_private {
    struct kobject kobj;
    /* ... */
};

/* é€™å°±æ˜¯ç‚ºä»€éº¼ /sys/devices å’Œ /sys/bus/*/drivers æœ‰ç›®éŒ„çµæ§‹ */
```

---

## ğŸ”· ç¬¬åä¸€éƒ¨åˆ†ï¼šDriver Binding æ™‚åºèˆ‡ Debug

### 11.1 å®Œæ•´çš„ Probe æµç¨‹æ™‚åºåœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Driver Probe å®Œæ•´æ™‚åº                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  [Kernel Boot / insmod]                                                  â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“                                                                 â”‚
â”‚  platform_driver_register()                                              â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (åŠ å…¥ bus->p->drivers_kset)                                     â”‚
â”‚  driver_register()                                                       â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (éæ­· bus ä¸Šçš„ devices)                                         â”‚
â”‚  driver_attach()                                                         â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (å°æ¯å€‹ device å‘¼å«)                                            â”‚
â”‚  __driver_attach()                                                       â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (æª¢æŸ¥ match)                                                    â”‚
â”‚  driver_match_device()                                                   â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â”œâ”€â”€â”€ platform_match()                                             â”‚
â”‚        â”‚         â”‚                                                       â”‚
â”‚        â”‚         â”œâ”€â”€ of_driver_match_device() â† Device Tree compatible   â”‚
â”‚        â”‚         â”œâ”€â”€ acpi_driver_match_device() â† ACPI                  â”‚
â”‚        â”‚         â””â”€â”€ platform_match_id() â† legacy id_table              â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (match æˆåŠŸ)                                                    â”‚
â”‚  driver_probe_device()                                                   â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“                                                                 â”‚
â”‚  really_probe()                                                          â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â”œâ”€â”€ dev->driver = drv                                            â”‚
â”‚        â”œâ”€â”€ pinctrl_bind_pins(dev) â† ç¶å®š pin controller                 â”‚
â”‚        â”œâ”€â”€ dma_configure(dev) â† è¨­å®š DMA                                â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (platform bus æœƒå‘¼å«)                                           â”‚
â”‚  platform_drv_probe()                                                    â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â†“ (å‘¼å« driver çš„ probe)                                          â”‚
â”‚  drv->probe(dev)                                                         â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â”œâ”€ æˆåŠŸ (return 0) â”€â”€â†’ probe å®Œæˆ                                â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â””â”€ å¤±æ•— (-EPROBE_DEFER) â”€â”€â†’ åŠ å…¥ deferred list                   â”‚
â”‚                                      ç¨å¾Œé‡è©¦                            â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 11.2 Debug Probe å•é¡Œçš„å¯¦ç”¨æŠ€å·§

```bash
# 1. æŸ¥çœ‹å·²è¼‰å…¥çš„ drivers å’Œ devices
ls -la /sys/bus/platform/drivers/
ls -la /sys/bus/platform/devices/

# 2. æŸ¥çœ‹ç‰¹å®š driver ç¶å®šçš„ devices
ls -la /sys/bus/platform/drivers/my-driver/

# 3. æ‰‹å‹•è§¸ç™¼ bind/unbindï¼ˆdebug ç”¨ï¼‰
echo "my-device" > /sys/bus/platform/drivers/my-driver/unbind
echo "my-device" > /sys/bus/platform/drivers/my-driver/bind

# 4. æŸ¥çœ‹ deferred probe
cat /sys/kernel/debug/devices_deferred

# 5. é–‹å•Ÿ dynamic debug
echo 'file drivers/base/dd.c +p' > /sys/kernel/debug/dynamic_debug/control
echo 'file drivers/base/core.c +p' > /sys/kernel/debug/dynamic_debug/control

# 6. æŸ¥çœ‹ Device Tree è§£æçµæœ
ls -la /proc/device-tree/
cat /proc/device-tree/my-device@10000/compatible

# 7. ä½¿ç”¨ ftrace è¿½è¹¤ probe
echo probe_function > /sys/kernel/debug/tracing/set_ftrace_filter
echo function > /sys/kernel/debug/tracing/current_tracer
cat /sys/kernel/debug/tracing/trace

# 8. Kernel åƒæ•¸ debug
# åœ¨ bootargs åŠ å…¥ï¼š
initcall_debug 
ignore_loglevel
```

### 11.3 å¸¸è¦‹ Probe å¤±æ•—åŸå› è¨ºæ–·

```c
/* å•é¡Œ 1ï¼šcompatible ä¸åŒ¹é… */
// ç¾è±¡ï¼šprobe å®Œå…¨æ²’è¢«å‘¼å«
// Debugï¼š
cat /proc/device-tree/my-device/compatible
// ç¢ºèªå’Œ driver çš„ of_match_table ä¸€è‡´

/* å•é¡Œ 2ï¼šè³‡æºå–å¾—å¤±æ•— */
// ç¾è±¡ï¼šprobe è¢«å‘¼å«ä½†å›å‚³éŒ¯èª¤
// Debugï¼šåŠ å…¥è¶³å¤ çš„ log
static int my_probe(struct platform_device *pdev)
{
    struct resource *res;
    
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!res) {
        dev_err(&pdev->dev, "Failed to get memory resource\n");
        return -ENODEV;
    }
    dev_info(&pdev->dev, "Got resource: %pR\n", res);
    /* ... */
}

/* å•é¡Œ 3ï¼šDeferred Probe å¾ªç’° */
// ç¾è±¡ï¼šprobe ä¸€ç›´è¢« defer
// Debugï¼š
$ cat /sys/kernel/debug/devices_deferred
platform my-device: waiting for supplier clk-controller
// è§£æ±ºï¼šç¢ºèªä¾è³´çš„ driver å·²æ­£ç¢ºè¼‰å…¥

/* å•é¡Œ 4ï¼šClock/Regulator ä¸å­˜åœ¨ */
// ç¾è±¡ï¼š-ENOENT éŒ¯èª¤
// Debugï¼šç¢ºèª Device Tree æœ‰æ­£ç¢ºé…ç½® clocks/supplies
clk = devm_clk_get(&pdev->dev, "main");
if (IS_ERR(clk)) {
    dev_err(&pdev->dev, "Failed to get clock: %ld\n", PTR_ERR(clk));
    // PTR_ERR æœƒé¡¯ç¤ºå…·é«”éŒ¯èª¤ç¢¼
}
```

---

## ğŸ”· ç¬¬åäºŒéƒ¨åˆ†ï¼šé€²éšé¢è©¦å•ç­”

### Q16: ä»€éº¼æ˜¯ Symbol Versioningï¼Ÿç‚ºä»€éº¼éœ€è¦å®ƒï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šAMD / Intel

**ç­”æ¡ˆ**ï¼š

Symbol Versioningï¼ˆç¬¦è™Ÿç‰ˆæœ¬åŒ–ï¼‰æ˜¯ Linux Kernel ç”¨ä¾†ç¢ºä¿æ¨¡çµ„èˆ‡ Kernel ç‰ˆæœ¬ç›¸å®¹çš„æ©Ÿåˆ¶ã€‚

```bash
# æŸ¥çœ‹æ¨¡çµ„çš„ version magic
modinfo my_module.ko
# vermagic: 5.15.0 SMP preempt mod_unload

# å¦‚æœç‰ˆæœ¬ä¸ç¬¦ï¼Œinsmod æœƒå¤±æ•—
$ insmod my_module.ko
insmod: ERROR: could not insert module: Invalid module format
```

**CRC Checksum**ï¼š
```c
/* Kernel ç‚ºæ¯å€‹ exported symbol è¨ˆç®— CRC */
/* å®šç¾©åœ¨ Module.symvers */
0x12345678  my_exported_function    drivers/my/module

/* æ¨¡çµ„è¼‰å…¥æ™‚æª¢æŸ¥ CRC */
/* å¦‚æœ CRC ä¸ç¬¦ï¼Œè¡¨ç¤º ABI å·²æ”¹è®Š */
```

**MODVERSIONS é–‹å•Ÿæ™‚**ï¼š
- æ¯å€‹ exported symbol æœ‰ CRC checksum
- æ¨¡çµ„å¼•ç”¨ symbol æ™‚ï¼Œè¨˜éŒ„ CRC
- è¼‰å…¥æ™‚æ¯”å°ï¼Œä¸ç¬¦å°±æ‹’çµ•è¼‰å…¥

**å¼·åˆ¶è¼‰å…¥ï¼ˆå±éšªï¼ï¼‰**ï¼š
```bash
# è·³éç‰ˆæœ¬æª¢æŸ¥ï¼ˆå¯èƒ½å°è‡´ kernel panicï¼‰
insmod -f my_module.ko
# æˆ–
modprobe --force my_module
```

---

### Q17: å¦‚ä½•å¯¦ç¾ Character Device çš„ poll/select æ”¯æ´ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / æ™®é

**ç­”æ¡ˆ**ï¼š

```c
#include <linux/poll.h>

struct my_device {
    wait_queue_head_t read_queue;
    wait_queue_head_t write_queue;
    spinlock_t lock;
    bool data_ready;
    bool can_write;
};

static __poll_t my_poll(struct file *file, poll_table *wait)
{
    struct my_device *dev = file->private_data;
    __poll_t mask = 0;
    
    /* è¨»å†Šç­‰å¾…ä½‡åˆ—ï¼Œä½†ä¸æœƒç¡çœ  */
    poll_wait(file, &dev->read_queue, wait);
    poll_wait(file, &dev->write_queue, wait);
    
    spin_lock(&dev->lock);
    
    if (dev->data_ready)
        mask |= EPOLLIN | EPOLLRDNORM;  /* å¯è®€ */
    
    if (dev->can_write)
        mask |= EPOLLOUT | EPOLLWRNORM;  /* å¯å¯« */
    
    spin_unlock(&dev->lock);
    
    return mask;
}

/* ç•¶æœ‰è³‡æ–™å¯è®€æ™‚ */
static void my_data_arrived(struct my_device *dev)
{
    spin_lock(&dev->lock);
    dev->data_ready = true;
    spin_unlock(&dev->lock);
    
    wake_up_interruptible(&dev->read_queue);
}

static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .poll = my_poll,
    /* ... */
};
```

**User Space ä½¿ç”¨**ï¼š
```c
/* select/poll/epoll éƒ½å¯ä»¥ç”¨ */
struct pollfd fds[1];
fds[0].fd = open("/dev/mydevice", O_RDWR);
fds[0].events = POLLIN | POLLOUT;

if (poll(fds, 1, 1000) > 0) {
    if (fds[0].revents & POLLIN) {
        /* å¯ä»¥è®€äº† */
    }
}
```

---

### Q18: è§£é‡‹ User Space å’Œ Kernel Space è³‡æ–™å‚³éçš„å®‰å…¨å•é¡Œ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šGoogle / å®‰å…¨ç›¸é—œè·ä½

**ç­”æ¡ˆ**ï¼š

```c
/* âŒ éŒ¯èª¤ï¼šç›´æ¥è§£å¼•ç”¨ user pointer */
static ssize_t bad_read(struct file *file, char __user *buf, 
                        size_t count, loff_t *pos)
{
    char *p = (char *)buf;  /* å±éšªï¼ */
    *p = 'A';  /* å¯èƒ½ crashï¼Œå¯èƒ½å®‰å…¨æ¼æ´ */
}

/* âœ… æ­£ç¢ºï¼šä½¿ç”¨ copy_to_user / copy_from_user */
static ssize_t good_read(struct file *file, char __user *buf,
                         size_t count, loff_t *pos)
{
    char data[] = "Hello";
    
    if (count > sizeof(data))
        count = sizeof(data);
    
    if (copy_to_user(buf, data, count))
        return -EFAULT;
    
    return count;
}

/* å®‰å…¨æª¢æŸ¥ç´°ç¯€ */
unsigned long copy_to_user(void __user *to, const void *from, 
                           unsigned long n)
{
    /* 1. æª¢æŸ¥ to æ˜¯å¦åœ¨ user space ç¯„åœ */
    if (!access_ok(to, n))
        return n;  /* å›å‚³æœªè¤‡è£½çš„ bytes */
    
    /* 2. ä½¿ç”¨ç‰¹æ®ŠæŒ‡ä»¤è¤‡è£½ï¼ˆè™•ç† page faultï¼‰ */
    return raw_copy_to_user(to, from, n);
}
```

**å®‰å…¨å•é¡Œ**ï¼š

1. **TOCTTOU (Time Of Check To Time Of Use)**
```c
/* ä¸å®‰å…¨çš„ ioctl */
static long my_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct my_request req;
    
    if (copy_from_user(&req, (void __user *)arg, sizeof(req)))
        return -EFAULT;
    
    /* æª¢æŸ¥ req.size */
    if (req.size > MAX_SIZE)
        return -EINVAL;
    
    /* âš ï¸ é€™è£¡æœ‰ TOCTTOUï¼
     * User space å¯ä»¥åœ¨æª¢æŸ¥å¾Œã€ä½¿ç”¨å‰ä¿®æ”¹ req 
     */
    char *buf = kmalloc(req.size, GFP_KERNEL);
    /* ... */
}

/* å®‰å…¨åšæ³•ï¼šè¤‡è£½å¾Œå°±ä¸å†è®€å– user memory */
```

2. **Integer Overflow**
```c
/* å±éšª */
size = count * elem_size;  /* å¯èƒ½ overflow */
buf = kmalloc(size, GFP_KERNEL);

/* å®‰å…¨ */
if (check_mul_overflow(count, elem_size, &size))
    return -EOVERFLOW;
buf = kmalloc(size, GFP_KERNEL);
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **Linux Kernel Source**
   - `drivers/base/` - Device Model å¯¦ä½œ
   - `include/linux/device.h` - æ ¸å¿ƒè³‡æ–™çµæ§‹

2. **æ›¸ç±**
   - Linux Device Drivers, 3rd Edition (LDD3) - free online
   - Essential Linux Device Drivers - Sreekrishnan Venkateswaran

3. **ç·šä¸Šè³‡æº**
   - [Bootlin Training Materials](https://bootlin.com/docs/)
   - [Kernel Newbies](https://kernelnewbies.org/)

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/03_åº•å±¤é©…å‹•é–‹ç™¼/é©…å‹•ç¨‹å¼åŸºç¤.md`
- æ“´å……å¾Œè¡Œæ•¸ï¼š~1450 è¡Œ
- æ¶µè“‹ï¼š
  - âœ… Device Model è©³è§£ï¼ˆstruct device/driver/busï¼ŒKernel åŸå§‹ç¢¼ï¼‰
  - âœ… Character Device å®Œæ•´å¯¦ä½œ
  - âœ… Platform Driver å®Œæ•´å¯¦ä½œï¼ˆå« Device Treeï¼‰
  - âœ… Misc Driver
  - âœ… Probe/Deferred Probe æ©Ÿåˆ¶
  - âœ… devm_ API å®Œæ•´åˆ—è¡¨
  - âœ… sysfs/debugfs/procfs ä»‹é¢
  - âœ… Kernel Synchronizationï¼ˆmutex/spinlock/completion/wait_queueï¼‰
  - âœ… 8 é“é¢è©¦é¡Œ
