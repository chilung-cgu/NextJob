# 🔌 I2C / SPI / UART 通訊協定詳解

> 這三個通訊協定是嵌入式和韌體工程師的必備知識  
> 面試幾乎一定會問！

---

## 📌 三種協定比較

| 特性 | I2C | SPI | UART |
|-----|-----|-----|------|
| **全名** | Inter-Integrated Circuit | Serial Peripheral Interface | Universal Asynchronous Receiver-Transmitter |
| **線數** | 2 條（SDA + SCL）| 4 條（MOSI + MISO + SCK + CS）| 2 條（TX + RX）|
| **速度** | 100kHz / 400kHz / 1MHz+ | 可達 50MHz+ | 通常 9600-115200 bps |
| **傳輸模式** | ❌ 半雙工 (SDA 共用，不可同時收發) | ✅ 全雙工 (MOSI/MISO 獨立，可同時收發) | ✅ 全雙工 (TX/RX 獨立，可同時收發) |
| **Master/Slave** | 多 Master 多 Slave | 1 Master 多 Slave | 點對點 |
| **定址方式** | 7-bit 或 10-bit 位址 | CS（Chip Select）線 | 無需定址 |
| **常見用途** | Sensor、EEPROM、RTC | Flash、顯示器、SD卡 | Debug console、GPS |

---

## 🔷 I2C 協定詳解

### 💡 什麼是 I2C？為什麼需要它？

**I2C (Inter-Integrated Circuit)** = 積體電路間通訊，由 Philips（現 NXP）發明

**最大特色：只需要 2 條線，就能連接很多裝置！**

想像一間教室：
- **SPI** 像是每個學生都有專線電話找老師（每人一條 CS 線）
- **I2C** 像是全班共用一個廣播系統，老師喊學號（地址）再指定誰回答

**I2C 的特點：**
```
✅ 省線！只需要 2 條線（SDA + SCL）
✅ 可以接很多裝置（用地址區分，理論上 128 個）
✅ 有 ACK 機制，知道對方有沒有收到
✅ 支援多 Master（進階功能）
❌ 速度較慢（通常 100kHz ~ 400kHz）
❌ 半雙工（不能同時收發）
❌ 需要外部上拉電阻
```

**常見使用場景：**
- 溫度/濕度 Sensor（DHT12、BME280）
- EEPROM（24C02、AT24C256）
- RTC 即時時鐘（DS1307、DS3231）
- 加速度計/陀螺儀（MPU6050）
- OLED 顯示器（SSD1306）

---

### 硬體連接

```
       MCU (Master)                    Sensor (Slave)
    ┌─────────────┐                 ┌─────────────┐
    │         SDA ├─────────────────┤ SDA         │
    │         SCL ├─────────────────┤ SCL         │
    │         GND ├─────────────────┤ GND         │
    └─────────────┘                 └─────────────┘
                    │    │
                    R    R  ← 上拉電阻（Pull-up Resistor）
                    │    │
                   VCC  VCC
```

---

### 基本概念（詳細解釋）

#### 🔌 兩條線的功能

```
┌───────┬─────────────────────────────────────────────────────┐
│  線名 │                     白話解釋                        │
├───────┼─────────────────────────────────────────────────────┤
│  SDA  │ Serial Data = 資料線                                │
│       │ 雙向！Master 和 Slave 輪流用這條線傳資料             │
│       │ 想像：一條單線道的路，車子輪流通行                    │
├───────┼─────────────────────────────────────────────────────┤
│  SCL  │ Serial Clock = 時脈線                               │
│       │ 單向！永遠由 Master 產生                             │
│       │ 想像：指揮交通的紅綠燈，告訴大家什麼時候該看資料       │
└───────┴─────────────────────────────────────────────────────┘
```

#### 🔧 什麼是 Open-Drain？為什麼需要上拉電阻？

這是 I2C 最重要但最難懂的概念！用圖解說明：

```
一般輸出（Push-Pull）：
    VCC ─────┬─────
             │
         【開關1】← 可以主動輸出「高」
             │
    輸出 ────┼──────→
             │
         【開關2】← 可以主動輸出「低」
             │
    GND ─────┴─────
    
    優點：可以主動輸出高和低
    缺點：如果兩個裝置同時輸出，一個高一個低 = 短路！💥


Open-Drain 輸出（I2C 使用）：
    VCC ─────┬───── R（上拉電阻）
             │        ↓
             └────────┼──────→ 輸出
                      │
                  【開關】← 只能主動拉「低」
                      │
    GND ──────────────┴─────
    
    工作原理：
    - 開關關閉（不導通）→ 電阻把線拉到 VCC → 輸出「高」
    - 開關打開（導通）  → 線直接接地       → 輸出「低」
    
    優點：多個裝置可以共用同一條線！
         任何一個拉低，線就是低（Wired-AND 邏輯）
         沒人拉低，電阻把線拉高
```

**Wired-AND 實例：**
```
              VCC
               │
               R（上拉電阻）
               │
    ───────────┼─────────── SDA
         │     │     │
        裝置A  裝置B  裝置C
         │     │     │
        GND   GND   GND

如果大家都放開（不拉低）：SDA = 高
只要有人拉低：SDA = 低

這就是為什麼 ACK 要用「低電位」表示！
接收成功的裝置會主動把 SDA 拉低，Master 就知道有人收到了。
```

---

### 🏷️ I2C 地址詳解

每個 I2C 裝置都有一個「地址」，就像學生的學號。

#### 7-bit 地址格式

```
發送的第一個 byte：
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ A6│ A5│ A4│ A3│ A2│ A1│ A0│R/W│
└───┴───┴───┴───┴───┴───┴───┴───┘
│<────── 7-bit 地址 ──────>│ │
                              │
                              └── 0 = Write（Master 要寫）
                                  1 = Read（Master 要讀）
```

#### 地址計算範例

```
假設一個 Sensor 的 7-bit 地址是 0x48

要「寫入」資料時：
  地址 0x48 = 0b1001000
  加上 R/W = 0（寫）
  完整 byte = 0b10010000 = 0x90

要「讀取」資料時：
  地址 0x48 = 0b1001000  
  加上 R/W = 1（讀）
  完整 byte = 0b10010001 = 0x91

💡 面試技巧：
有些 Datasheet 會直接寫 8-bit 地址（含 R/W bit）
例如寫成「Write: 0x90, Read: 0x91」
實際的 7-bit 地址 = 0x90 >> 1 = 0x48
```

#### 常見裝置地址表

```
┌────────────────────┬───────────────┬────────────────────────┐
│       裝置         │  7-bit 地址   │         備註           │
├────────────────────┼───────────────┼────────────────────────┤
│ EEPROM AT24C02     │   0x50-0x57   │ 可用 A0-A2 調整        │
├────────────────────┼───────────────┼────────────────────────┤
│ RTC DS3231         │     0x68      │ 固定地址               │
├────────────────────┼───────────────┼────────────────────────┤
│ 溫溼度 BME280      │   0x76/0x77   │ SDO 接地=0x76          │
├────────────────────┼───────────────┼────────────────────────┤
│ OLED SSD1306       │   0x3C/0x3D   │ 常見 0x3C              │
├────────────────────┼───────────────┼────────────────────────┤
│ 加速度計 MPU6050   │   0x68/0x69   │ AD0 接地=0x68          │
└────────────────────┴───────────────┴────────────────────────┘

⚠️ 注意：DS3231 和 MPU6050 地址都是 0x68，不能同時接在同一條 I2C！
```

---

### 如何解讀時序圖？

1. **SCL (時脈) 是節拍器**：所有的動作都必須跟著 SCL 的節奏。當 **SCL 為高電位 (High)** 時，SDA 上的資料被視為「有效」且不可改變。
2. **SDA 的改變時機**：只有當 **SCL 為低電位 (Low)** 時，SDA 才可以改變數值（0 變 1 或 1 變 0）。這也是為什麼資料切換都發生在 SCL 的低谷。
3. **唯一的例外 (Start/Stop)**：若 **SCL 保持高電位** 時 SDA 發生了跳變，這代表特殊的通訊信號而非資料：
    - **Start**：SCL 為 High 時，SDA 從高變低。
    - **Stop**：SCL 為 High 時，SDA 從低變高。

```
視覺化：什麼時候 SDA 可以變？

SCL:  ──────┐      ┌──────┐      ┌──────
            │      │      │      │
            └──────┘      └──────┘
              ↑              ↑
            可以變         可以變
            SDA            SDA
            
SCL 高的時候：SDA 必須穩定（這時在讀取資料）
SCL 低的時候：SDA 可以變化（準備下一個 bit）
```

---

### I2C 通訊流程（圖解版）

```
完整的 I2C 寫入流程：向 Slave 0x48 寫入 1 byte 資料 0xAB

    Master                                          Slave 0x48
      │                                                  │
      │  1. 發送 Start Condition                         │
      │────────────────────────────────────────────────→│
      │     (通知所有人：我要開始了！)                     │
      │                                                  │
      │  2. 發送地址 + Write bit (0x90)                  │
      │────────────────────────────────────────────────→│
      │     (喊：0x48 號同學！我要寫資料給你！)            │
      │                                                  │
      │  3. Slave 回應 ACK                               │
      │←────────────────────────────────────────────────│
      │     (0x48：有！我在！)                            │
      │                                                  │
      │  4. 發送資料 0xAB                                │
      │────────────────────────────────────────────────→│
      │                                                  │
      │  5. Slave 回應 ACK                               │
      │←────────────────────────────────────────────────│
      │     (收到！)                                      │
      │                                                  │
      │  6. 發送 Stop Condition                          │
      │────────────────────────────────────────────────→│
      │     (好，結束！)                                  │
      │                                                  │
```

---

### 時序圖（詳細版）

```
寫入 1 byte 到 Slave 0x48 的完整時序：

SCL:  ────┐  ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐...
          └──┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─
              1   2   3   4   5   6   7   8   9

SDA:  ─┐                                             ┌────
       └──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─────┘
          │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ACK│
          │<───── 0x48 地址 ─────>│R/W│   │
       ↑                              │   └── Slave 拉低=收到
     Start                            └── 0=Write
     
地址 0x48 = 0b1001000
R/W = 0 (Write)
ACK = SDA 被 Slave 拉低（表示有收到）
```

---

### ACK 和 NACK 的意義

```
┌────────┬─────────────┬────────────────────────────────────┐
│  狀態  │  SDA 電位   │              意義                  │
├────────┼─────────────┼────────────────────────────────────┤
│  ACK   │     低      │ 「收到了！」                        │
│        │             │ 接收方主動把 SDA 拉低                │
├────────┼─────────────┼────────────────────────────────────┤
│  NACK  │     高      │ 「沒收到」或「不想收了」             │
│        │             │ 接收方沒有拉低，上拉電阻使其為高     │
└────────┴─────────────┴────────────────────────────────────┘

NACK 的常見原因：
1. 沒有這個地址的裝置（根本沒人回應）
2. Slave 正在忙，無法處理
3. Master 讀取時，最後一個 byte 會故意送 NACK，表示「不用再送了」
```

---

### 常見面試問題

**Q1：I2C 為什麼需要上拉電阻？**
```
I2C 使用 open-drain 輸出：
- 只能主動拉低電壓（接地）
- 無法主動輸出高電壓
- 需要上拉電阻把線拉到 VCC，才能有高電位

好處：
- 允許多個裝置共用同一條線，不會互相干擾
- 實現 wired-AND 邏輯
- ACK 機制就是靠這個原理：Slave 拉低 = ACK，沒人拉低 = NACK
```

**Q2：如果 Slave 沒有回應 ACK 會怎樣？**
```
- Master 會檢測到 NACK（SDA 保持高電位）
- 通常表示：
  1. 位址錯誤（沒有這個 Slave）
  2. Slave 忙碌無法處理
  3. 資料傳輸有問題
- Master 應該發送 Stop 或重試
```

**Q3：什麼是 Clock Stretching？**
```
Slave 可以拉住 SCL 使其保持低電位，暫停通訊。

原理圖：
    Master 想拉高 SCL ─┐
                       ├─→ SCL 還是低！（被 Slave 拉住）
    Slave 拉低 SCL ────┘
    
用途：Slave 處理速度較慢時，需要時間準備資料。
Master 必須在 SCL 恢復高電位後才能繼續。

⚠️ 注意：不是所有 Master 都支援 Clock Stretching！
         要查 datasheet 確認。
```

**Q4：I2C 有時會「卡住」，如何處理？**
```
可能原因：Slave 在傳輸途中被 reset，導致 SDA 被拉低

現象：SDA 一直是低電位，Master 無法發送 Start Condition

解決方法：
1. 發送 9 個 Clock pulse（讓 Slave 完成可能的傳輸）
2. 發送 Stop Condition
3. 重新初始化 I2C

程式碼範例：
for (int i = 0; i < 9; i++) {
    SCL = 0; delay();
    SCL = 1; delay();
}
// 發送 Stop
SDA = 0;
SCL = 1;
SDA = 1;
```

---

## 🔷 SPI 協定詳解

### 💡 什麼是 SPI？為什麼需要它？

**SPI (Serial Peripheral Interface)** = 串列周邊介面

想像你是一個老闆（Master），要同時管理多個員工（Slave）：
- **I2C** 像是用對講機：所有人共用一個頻道，說話前要先喊對方名字（地址）
- **SPI** 像是每人一條專線電話（CS 線）：直接按鈕接通特定員工，不用喊名字

**SPI 的特點：**
```
✅ 超快！可達數十 MHz（比 I2C 快上百倍）
✅ 全雙工：可以同時「說」和「聽」
✅ 簡單：沒有複雜的地址系統
❌ 線多：每多一個 Slave，就多一條 CS 線
❌ 只適合短距離（同一塊電路板上）
```

**常見使用場景：**
- SPI Flash（儲存韌體/程式碼）
- SD 記憶卡
- LCD 顯示器
- 高速 ADC/DAC

---

### 硬體連接

```
       MCU (Master)                    Flash (Slave)
    ┌─────────────┐                 ┌─────────────┐
    │        MOSI ├─────────────────┤ MOSI (DI)   │
    │        MISO ├─────────────────┤ MISO (DO)   │
    │         SCK ├─────────────────┤ SCK         │
    │          CS ├─────────────────┤ CS (SS)     │
    │         GND ├─────────────────┤ GND         │
    └─────────────┘                 └─────────────┘
```

---

### 基本概念（詳細解釋）

#### 🔌 四條線的功能

```
┌──────────┬────────────────────────────────────────────────────────┐
│   線名   │                       白話解釋                         │
├──────────┼────────────────────────────────────────────────────────┤
│   MOSI   │ Master 的「嘴巴」→ Slave 的「耳朵」                    │
│          │ Master Out, Slave In = Master 說話，Slave 聽           │
├──────────┼────────────────────────────────────────────────────────┤
│   MISO   │ Slave 的「嘴巴」→ Master 的「耳朵」                    │
│          │ Master In, Slave Out = Slave 說話，Master 聽           │
├──────────┼────────────────────────────────────────────────────────┤
│   SCK    │ 「節拍器」，所有動作都跟著它的節奏                      │
│          │ Serial Clock = 時脈，永遠由 Master 產生                 │
├──────────┼────────────────────────────────────────────────────────┤
│   CS     │ 「點名」用的線，拉低 = 叫到這個 Slave                   │
│          │ Chip Select = 選擇晶片，低電位有效 (Active Low)        │
└──────────┴────────────────────────────────────────────────────────┘
```

#### 📞 通訊流程比喻

想像打電話給朋友：
```
1. 📱 拿起電話撥號      → CS 拉低（選擇 Slave）
2. 🗣️ 開始交談         → 透過 MOSI/MISO 傳資料，跟著 SCK 節奏
3. 📞 掛電話           → CS 拉高（結束通訊）
```

#### 🔄 全雙工的意義

```
I2C (半雙工) - 像對講機：
    按住說話 ────→        （不能同時聽）
              ←──── 放開才能聽

SPI (全雙工) - 像電話：
    說話 ────────────→     （同時雙向）
        ←────────────聽
              
實際上，SPI 的 MOSI 和 MISO 是「同時」在傳資料的！
每個 SCK 週期，兩邊各傳 1 bit。
```

---

### SPI 模式（圖解）

SPI 有 4 種模式，由 **CPOL** 和 **CPHA** 兩個設定決定。

#### 🎯 先理解兩個關鍵設定

```
CPOL (Clock Polarity) - 時脈極性
└── 問：「沒事的時候，時脈停在高還是低？」
    ├── CPOL = 0：閒置時 SCK = 低電位 ───┐
    └── CPOL = 1：閒置時 SCK = 高電位 ───┘

CPHA (Clock Phase) - 時脈相位  
└── 問：「在時脈的哪個邊緣讀取資料？」
    ├── CPHA = 0：第一個邊緣取樣（較早）
    └── CPHA = 1：第二個邊緣取樣（較晚）
```

#### 📊 四種模式對照表

| Mode | CPOL | CPHA | 時脈閒置狀態 | 資料取樣時機 |
|------|------|------|------------|------------|
| 0 | 0 | 0 | 低 | SCK 上升沿 |
| 1 | 0 | 1 | 低 | SCK 下降沿 |
| 2 | 1 | 0 | 高 | SCK 下降沿 |
| 3 | 1 | 1 | 高 | SCK 上升沿 |

#### 🖼️ 視覺化時序圖

**Mode 0（CPOL=0, CPHA=0）- 最常見！**
```
CS:   ────┐                                         ┌────
          └─────────────────────────────────────────┘
          ▲ CS 拉低開始                             ▲ CS 拉高結束
          
SCK:  ────┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐
     (低) └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──
              ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
              取樣  取樣  取樣  取樣  取樣  取樣  取樣  取樣
              (在上升沿讀取資料)

MOSI: ────┬────┬────┬────┬────┬────┬────┬────┬────
          │ D7 │ D6 │ D5 │ D4 │ D3 │ D2 │ D1 │ D0 │
          (MSB First: 最高位元先傳)
```

**Mode 3（CPOL=1, CPHA=1）- 也常見**
```
CS:   ────┐                                         ┌────
          └─────────────────────────────────────────┘

SCK:  ────┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──
     (高) └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──
              ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
              取樣  取樣  取樣  取樣  取樣  取樣  取樣  取樣
              (在上升沿讀取資料，但閒置時是高電位)
```

**⚠️ 重要提醒：Mode 不對會怎樣？**
```
如果 Master 和 Slave 的 Mode 設定不一樣：
→ 資料會讀錯！因為取樣的時機對不上
→ 常見症狀：讀到的資料全是 0xFF 或亂碼

💡 面試常問：查 Datasheet 確認裝置使用哪個 SPI Mode！
```

---

### 多 Slave 連接（詳細說明）

#### 方式一：獨立 CS（最常見）

每個 Slave 都有自己專屬的 CS 線，像是每人一個開關。

```
           MCU
        ┌───────┐
        │   CS0 ├──┐                    只有被選中的 Slave
        │   CS1 ├──┼──────────────┐     會回應（CS = 低）
        │   CS2 ├──┼──────────────┼────────────────┐
        │       │  │              │                │
        │  MOSI ├──┼──────────────┼──────┬─────────┼── (並聯)
        │  MISO ├──┼──────────────┼──────┼─────────┼── (並聯)  
        │   SCK ├──┼──────────────┼──────┼─────────┼── (並聯)
        └───────┘  │              │      │         │
                   ▼              ▼      ▼         │
              ┌────────┐    ┌────────┐   │    ┌────────┐
              │Slave 0 │    │Slave 1 │   │    │Slave 2 │
              │CS=LOW  │    │CS=HIGH │   │    │CS=HIGH │
              │(被選中)│    │(忽略)  │   │    │(忽略)  │
              └────────┘    └────────┘   │    └────────┘
                                         │
    同一時間只有一個 Slave 的 CS 是低電位 ──┘
```

**優點：**
- 簡單直觀
- 每個 Slave 獨立控制

**缺點：**
- 每多一個 Slave 就多佔用 MCU 一個 GPIO

---

#### 方式二：Daisy Chain（菊花鍊）

資料像接力賽一樣，一個傳一個。

```
                    資料流向
    MCU MOSI ──→ Slave0 ──→ Slave1 ──→ Slave2
                   ↓          ↓          ↓
                 (處理)     (處理)     (處理)
                   ↓          ↓          ↓
    MCU MISO ←── Slave0 ←── Slave1 ←── Slave2

    CS 只需要一條，同時選中所有 Slave！
```

**原理解釋：**
```
假設要寫 3 個 byte 給 3 個 Slave：

時間 T1: Master 送 Byte_A
         Slave0 收到 Byte_A
         
時間 T2: Master 送 Byte_B
         Slave0 把 Byte_A 往後傳給 Slave1
         Slave0 收到 Byte_B
         
時間 T3: Master 送 Byte_C
         Slave1 把 Byte_A 往後傳給 Slave2
         Slave0 把 Byte_B 往後傳給 Slave1
         Slave0 收到 Byte_C

最終結果：
Slave0: Byte_C
Slave1: Byte_B  
Slave2: Byte_A
```

**優點：**
- 只需要一條 CS 線（省 GPIO！）
- 很多 LED 驅動 IC 使用這種方式（例如 WS2812B LED Strip 類似概念）

**缺點：**
- 延遲較大（資料要經過前面的 Slave）
- 如果中間一個壞了，後面全斷

### 常見面試問題

**Q1：SPI 和 I2C 的主要差異？**
```
1. 速度：SPI 更快（可達數十 MHz）
2. 線數：SPI 需要更多線（每加一個 Slave 多一條 CS）
3. 全雙工：SPI 可同時收發，I2C 不行
4. 定址：I2C 用地址，SPI 用 CS 線
5. 距離：SPI 只適合短距離（同一 PCB 上）
```


**Q2：CPOL 和 CPHA 是什麼？**
```
CPOL (Clock Polarity)：時脈閒置時的電位
- CPOL=0：閒置時 SCK 為低
- CPOL=1：閒置時 SCK 為高

CPHA (Clock Phase)：資料取樣的時機
- CPHA=0：在第一個邊沿取樣（上升或下降沿，取決於 CPOL）
- CPHA=1：在第二個邊沿取樣
```

**Q3：「讀寫 SPI Flash」是什麼意思？和一般讀寫檔案一樣嗎？**

這是初學者容易搞混的概念！

```
┌──────────────────────────────────────────────────────────────────┐
│  一般「讀寫檔案」（高階操作）                                       │
│  ─────────────────────────                                       │
│  fopen("test.txt", "r")  →  作業系統幫你處理一切                   │
│                              （檔案系統、硬碟驅動...）              │
│                                                                  │
│  像是叫別人幫你存東西到倉庫，你不用管倉庫內部怎麼擺                   │
└──────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────┐
│ 「讀寫 SPI Flash」（底層操作）                                     │
│  ────────────────────────                                        │
│  直接用 SPI 發送命令給 Flash 晶片：                                │
│  - 發送 0x03 + 地址 → 讀取資料                                    │
│  - 發送 0x02 + 地址 + 資料 → 寫入資料                              │
│  - 發送 0x20 + 地址 → 擦除 Sector                                 │
│                                                                  │
│  像是你親自去倉庫的特定格子放東西，要自己處理所有細節                  │
└──────────────────────────────────────────────────────────────────┘
```

**SPI Flash 常見用途：**
```
┌─────────────────┬────────────────────────────────────────────────┐
│      用途       │                    說明                        │
├─────────────────┼────────────────────────────────────────────────┤
│ 1. 存 Firmware  │ 系統開機時從 SPI Flash 讀取韌體來執行           │
│    (最常見！)   │ 例如：BIOS/UEFI、U-Boot、BMC 韌體               │
├─────────────────┼────────────────────────────────────────────────┤
│ 2. 存 設定資料  │ NVRAM 區域，存裝置設定（斷電不消失）             │
│                 │ 例如：MAC 地址、序號、校準參數                   │
├─────────────────┼────────────────────────────────────────────────┤
│ 3. 存 Log/資料  │ 比較少見，但有些嵌入式系統會這樣用               │
│                 │ 例如：事件 log、感測器歷史資料                   │
└─────────────────┴────────────────────────────────────────────────┘

💡 在 BMC 工作中，「讀寫 SPI Flash」通常指：
   ✅ 更新 BMC 韌體（Flash Firmware）
   ✅ 更新 BIOS/ME 韌體
   ✅ 備份現有韌體
   ✅ 讀寫 FRU/設定資料區域
```

**⚠️ Flash 寫入的特殊限制（重要！）：**
```
一般硬碟/RAM：想寫什麼就寫什麼
    地址 0x100 原本是 0xAB → 直接寫成 0xCD ✓

Flash：只能從 1 變 0，不能從 0 變 1！
    原本是 0xFF → 寫成 0xAB ✓（1→0 可以）
    原本是 0xAB → 寫成 0x00 ✓（1→0 可以）
    原本是 0xAB → 寫成 0xFF ✗（0→1 不行！無法改回去！）
    
解決方法：先「擦除」(Erase)，把整個 Sector 變回 0xFF，再寫入

完整寫入流程：
    1. 讀取整個 Sector 到 RAM（備份）
    2. 在 RAM 中修改要改的部分
    3. 擦除整個 Sector（變成全 0xFF）
    4. 把修改後的資料寫回去

這也是為什麼 Flash 壽命有限（擦寫次數限制，通常 10 萬次）
```

---


## 🔷 UART 協定詳解

### 💡 什麼是 UART？為什麼需要它？

**UART (Universal Asynchronous Receiver-Transmitter)** = 通用非同步收發傳輸器

**最大特色：不需要時脈線！**

想像兩個人用燈號通訊：
- **I2C/SPI** 像是有人在旁邊打鼓給節奏：「咚！」看一下，「咚！」再看一下
- **UART** 像是沒人打鼓，雙方事先約定：「我們每秒閃 10 次」，然後各自計時

**UART 的特點：**
```
✅ 簡單！只需要 2 條線（TX + RX）
✅ 不需要時脈線（非同步）
✅ 全雙工：可以同時收發
✅ 歷史悠久，幾乎所有 MCU 都支援
❌ 速度較慢（通常 115200 bps）
❌ 只能點對點（一對一通訊）
❌ 距離有限（除非轉成 RS-232/RS-485）
```

**常見使用場景：**
- Debug console（printf 輸出訊息）
- GPS 模組通訊
- 藍牙模組（HC-05）
- WiFi 模組（ESP8266 AT 指令）
- 與 PC 通訊（透過 USB-to-UART 轉接器）

---

### 硬體連接

```
       MCU                          另一裝置
    ┌───────┐                     ┌───────┐
    │    TX ├─────────────────────┤ RX    │
    │    RX ├─────────────────────┤ TX    │
    │   GND ├─────────────────────┤ GND   │
    └───────┘                     └───────┘
    （注意：TX 接 RX，交叉連接）
```

#### 🔌 為什麼要「交叉連接」？

```
TX = Transmit = 發送（我的嘴巴）
RX = Receive  = 接收（我的耳朵）

想像兩個人打電話：
┌──────────┐                    ┌──────────┐
│  我的嘴  │ ───── 說話 ─────→ │  你的耳  │
│  (TX)    │                    │   (RX)   │
├──────────┤                    ├──────────┤
│  我的耳  │ ←──── 聽話 ────── │  你的嘴  │
│  (RX)    │                    │   (TX)   │
└──────────┘                    └──────────┘

所以：我的 TX 接你的 RX，我的 RX 接你的 TX！
```

#### ⚠️ 常見錯誤

```
錯誤：TX 接 TX，RX 接 RX
結果：兩個人都在講話沒人聽 / 兩個人都在聽沒人講

正確：TX 接 RX（交叉連接）
```

---

### 基本概念（詳細解釋）

#### 🔄 什麼是「非同步」(Asynchronous)？

```
同步通訊（I2C、SPI）：
┌────────────┐     有時脈線     ┌────────────┐
│   Master   │ ────────────────→│    Slave   │
│            │    「看這裡！」   │            │
│   發送方   │ ═══════════════> │   接收方   │
└────────────┘     資料線       └────────────┘
時脈線告訴你「什麼時候該看資料」

非同步通訊（UART）：
┌────────────┐     沒有時脈線    ┌────────────┐
│   發送方   │ ═══════════════> │   接收方   │
└────────────┘                  └────────────┘
雙方事先約定好速度（Baud Rate），各自計時！
```

#### ⏱️ Baud Rate 是什麼？

**Baud Rate = 每秒傳輸幾個 bit**

```
常見的 Baud Rate：
┌───────────┬──────────────────────────────────────┐
│ Baud Rate │           每個 bit 的時間            │
├───────────┼──────────────────────────────────────┤
│    9600   │  1/9600 = 104.17 μs (微秒)           │
│   115200  │  1/115200 = 8.68 μs                  │
│  1000000  │  1/1000000 = 1 μs                    │
└───────────┴──────────────────────────────────────┘

白話解釋：
- 9600 bps = 每秒傳 9600 個 0 或 1
- 115200 bps = 每秒傳 115200 個 0 或 1（比 9600 快 12 倍！）
```

#### ⚠️ Baud Rate 不一致會怎樣？

```
假設：發送方 115200，接收方 9600

發送方想傳：01010101（每個 bit 約 8.68 μs）

                  8.68μs
    發送方：┌─┐ ┌─┐ ┌─┐ ┌─┐
            │0│1│0│1│0│1│0│1│
            └─┘ └─┘ └─┘ └─┘
    
    接收方以為：（每個 bit 約 104 μs）
               ────────────────────────
               │         0            │ ← 只看到第一個 bit 拉很長
               ────────────────────────

結果：資料全錯！收到的是亂碼！

💡 所以雙方 Baud Rate 必須完全一致！
```

---

### UART Frame 格式（詳細圖解）

一次傳輸一個「Frame」（框架），包含起始、資料、校驗、結束。

```
閒置狀態（高電位）
    ─────────────────────────────────────────────
                 ↓ 開始傳輸
    ┌───┬──┬──┬──┬──┬──┬──┬──┬──┬───────┬──────┐
    │ S │D0│D1│D2│D3│D4│D5│D6│D7│Parity │ Stop │
    └───┴──┴──┴──┴──┴──┴──┴──┴──┴───────┴──────┘
    │   │                      │       │      │
    │   └──────────────────────┘       │      │
    │         資料位元 (8 bits)         │      │
    │                                  │      │
    └── Start bit (1 bit, 固定 = 0)    │      │
                                       │      │
        Parity bit (0 或 1 bit, 可選) ──┘      │
                                              │
        Stop bit (1 或 2 bits, 固定 = 1) ──────┘
```

#### 📊 各部分功能說明

```
┌──────────────┬────────┬──────────────────────────────────────┐
│     名稱     │ 位元數 │              功能說明                 │
├──────────────┼────────┼──────────────────────────────────────┤
│  Start bit   │   1    │ 固定是 0（低電位）                   │
│              │        │ 告訴接收方：「資料要來了！」          │
├──────────────┼────────┼──────────────────────────────────────┤
│  Data bits   │  5-9   │ 實際的資料內容                        │
│              │        │ 常見是 8 bits（1 個 byte）           │
│              │        │ 注意：LSB First（最低位元先傳）       │
├──────────────┼────────┼──────────────────────────────────────┤
│  Parity bit  │  0-1   │ 可選的錯誤檢查                        │
│              │        │ N = None（不用）                      │
│              │        │ E = Even（偶校驗）                    │
│              │        │ O = Odd（奇校驗）                     │
├──────────────┼────────┼──────────────────────────────────────┤
│  Stop bit    │  1-2   │ 固定是 1（高電位）                   │
│              │        │ 告訴接收方：「這次資料結束了」        │
└──────────────┴────────┴──────────────────────────────────────┘
```

#### 🖼️ 傳送 0x55 ('U') 的時序圖

```
假設設定：115200 8N1
傳送資料：0x55 = 0b01010101

電壓
 高 ─────┐   ┌───┐   ┌───┐   ┌───┐   ┌───┬─────────
         │   │   │   │   │   │   │   │   │
 低      └───┘   └───┘   └───┘   └───┘   │
         │   │   │   │   │   │   │   │   │
         S  D0  D1  D2  D3  D4  D5  D6  D7  Stop
         │   │   │   │   │   │   │   │   │
         0   1   0   1   0   1   0   1   0    1
         ↑                                    ↑
      Start                                 Stop
      
時間：每個 bit 約 8.68 μs（115200 bps）
總時間：10 bits × 8.68 μs ≈ 86.8 μs 傳完一個 byte

注意：資料是 LSB First！
0x55 = 01010101，但傳輸順序是 D0→D7 = 1,0,1,0,1,0,1,0
```

---

### 常見設定（如何解讀）

當看到 **"115200 8N1"** 這種格式，代表：

```
┌─────────┬─────────┬─────────┬─────────┐
│ 115200  │    8    │    N    │    1    │
├─────────┼─────────┼─────────┼─────────┤
│Baud Rate│Data bits│ Parity  │Stop bits│
│ 波特率  │ 資料位元 │ 校驗位元 │ 停止位元│
└─────────┴─────────┴─────────┴─────────┘

完整解讀：
- 115200：每秒傳 115200 個 bit
- 8：每個 frame 有 8 個 data bits
- N：No parity（不使用校驗位元）
- 1：1 個 stop bit
```

#### 📋 常見設定組合

```
┌──────────────┬────────────────────────────────────────┐
│    設定      │               適用場景                  │
├──────────────┼────────────────────────────────────────┤
│  9600 8N1    │ 傳統設備、GPS 模組、藍牙模組預設       │
├──────────────┼────────────────────────────────────────┤
│ 115200 8N1   │ Debug console（最常用！）             │
├──────────────┼────────────────────────────────────────┤
│ 115200 8E1   │ 工業通訊（需要錯誤檢查）               │
├──────────────┼────────────────────────────────────────┤
│ 1000000 8N1  │ 高速傳輸（1 Mbps）                    │
└──────────────┴────────────────────────────────────────┘
```

---

### 常見面試問題

**Q1：UART 沒有時脈線，如何同步？**
```
1. 收發雙方預先設定相同的 Baud Rate
2. 接收端偵測 Start bit（從高變低）
3. 根據 Baud Rate 計算每個 bit 的時間
4. 在每個 bit 的中間取樣

視覺化說明：
               
    ─────┐         取樣點（在 bit 中間）
         │    ↓    ↓    ↓    ↓
         └────┼────┼────┼────┼────
         │    │    │    │    │
        Start D0   D1   D2   D3 ...

為什麼在「中間」取樣？
→ 避免在邊緣取樣，那裡電壓還在變化，不穩定

所以 Baud Rate 必須完全一致！如果差太多會讀錯資料。
```

**Q2：什麼是 Parity Check？**
```
用來檢測資料傳輸是否有錯誤。

原理：數一數資料有幾個「1」

- Even Parity（偶校驗）：確保「1 的總數」是偶數
- Odd Parity（奇校驗）：確保「1 的總數」是奇數

範例：資料 0x55 = 0b01010101（有 4 個 1）
┌────────────┬─────────────┬───────────────────────┐
│   類型     │ Parity bit  │         原因          │
├────────────┼─────────────┼───────────────────────┤
│Even Parity │      0      │ 4 + 0 = 4（偶數 ✓）   │
│Odd Parity  │      1      │ 4 + 1 = 5（奇數 ✓）   │
└────────────┴─────────────┴───────────────────────┘

⚠️ 重要限制：
- 只能檢測「單一 bit」錯誤
- 無法檢測「兩個 bit」同時錯誤（因為偶數個錯誤會互相抵消）
- 無法「糾正」錯誤，只能「發現」錯誤
```

**Q3：什麼是 Flow Control（流量控制）？**
```
問題：如果發送方太快，接收方來不及處理怎麼辦？

解決方案：Flow Control（流量控制）

方式一：Hardware Flow Control（硬體流控）
────────────────────────────────────────
額外需要 2 條線：RTS（要送了）、CTS（可以收）

    發送方                    接收方
    ┌─────┐                  ┌─────┐
    │ RTS ├─────────────────→│ CTS │
    │ CTS │←─────────────────┤ RTS │
    └─────┘                  └─────┘

流程：
1. 發送方拉低 RTS：「我想送資料」
2. 接收方拉低 CTS：「我準備好了，送吧」
3. 開始傳輸
4. 接收方 buffer 快滿了，拉高 CTS：「等一下！」
5. 發送方暫停傳輸

方式二：Software Flow Control（軟體流控）
────────────────────────────────────────
用特殊字元來控制：
- XON  (0x11)：繼續傳
- XOFF (0x13)：暫停傳

不需要額外接線，但資料中不能出現這兩個字元！
```

---

## ✅ 總結：面試時如何回答「請說明 I2C/SPI/UART」

### 📝 回答架構

```
1. 先說全名和基本概念
2. 說明硬體連接（幾條線、各自功能）
3. 說明通訊流程（起始/結束條件、傳輸方式）
4. 提到常見問題或注意事項
5. 最好能舉自己用過的經驗
```

---

### 🎤 I2C 標準回答範例

```
「I2C 全名是 Inter-Integrated Circuit，是一種兩線式的串列通訊協定，
由 Philips 發明。

硬體上使用 SDA 資料線和 SCL 時脈線，採用 Open-Drain 輸出，
所以需要外部上拉電阻，通常用 4.7kΩ。

通訊時 Master 先發 Start Condition（SCL 高時 SDA 下降），
接著送 7-bit 地址加 R/W bit，Slave 回應 ACK 後開始傳輸資料，
每 8 bits 後接收方回應一次 ACK。
傳輸完成發送 Stop Condition（SCL 高時 SDA 上升）。

常見速度有 Standard Mode 100kHz、Fast Mode 400kHz。
要注意的是如果 Bus 卡住，可以用 9 個 Clock Pulse 來恢復。

在我之前的工作中，我用 I2C 讀取 BME280 溫溼度 Sensor 
和 AT24C256 EEPROM 的資料...」
```

---

### 🎤 SPI 標準回答範例

```
「SPI 全名是 Serial Peripheral Interface，是一種四線式的同步串列通訊協定。

硬體上使用：
- MOSI（Master Out Slave In）：Master 發送資料
- MISO（Master In Slave Out）：Slave 回傳資料
- SCK（Serial Clock）：時脈，由 Master 產生
- CS（Chip Select）：選擇要通訊的 Slave，低電位有效

特點是全雙工，可以同時收發，速度很快，可達數十 MHz。
有四種模式，由 CPOL 和 CPHA 決定，要根據 Slave 的 Datasheet 設定正確的模式。

缺點是每多一個 Slave 就要多一條 CS 線，佔用較多 GPIO。

在我之前的工作中，我用 SPI 讀寫 SPI Flash 的韌體資料，
它需要高速傳輸才能快速更新韌體...」
```

---

### 🎤 UART 標準回答範例

```
「UART 全名是 Universal Asynchronous Receiver-Transmitter，
是一種非同步的串列通訊協定。

硬體上只需要 TX（發送）和 RX（接收）兩條線，要交叉連接。
因為沒有時脈線，所以雙方必須預先設定相同的 Baud Rate，
常見設定是 115200 8N1，表示 115200 bps、8 個 data bits、
無 parity、1 個 stop bit。

傳輸時以 Frame 為單位，包含 Start bit、Data bits、
可選的 Parity bit、以及 Stop bit。
接收端偵測 Start bit（從高變低）後，根據 Baud Rate 
在每個 bit 的中間取樣。

在我之前的工作中，我用 UART 作為 Debug Console 輸出 Log，
也用來和 GPS 模組、藍牙模組通訊...」
```

---

## 🎯 何時選用 I2C / SPI / UART？（場景決策指南）

很多人看完三種協定的說明還是搞不清楚何時該用哪個，
這裡用**實際場景**和**決策流程**來幫你理解！

### 📊 快速決策表

```
┌────────────────────────────────────────────────────────────────────────┐
│                           你的需求是什麼？                              │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   需要 Debug 輸出 / 和 PC 通訊？           ────→  用 UART              │
│                                                                        │
│   需要接很多 Sensor，想省線？              ────→  用 I2C               │
│                                                                        │
│   需要高速傳輸（Flash、顯示器）？          ────→  用 SPI               │
│                                                                        │
│   GPIO 很少，只能再拉 2 條線？             ────→  用 I2C               │
│                                                                        │
│   需要同時讀寫（全雙工）？                 ────→  用 SPI 或 UART        │
│                                                                        │
│   裝置只支援某種協定？                     ────→  沒得選，照裝置規格！   │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

---

### 🎬 場景一：讀取溫度 Sensor（BME280）→ 選 I2C

**為什麼不選其他的？**
```
✅ 選 I2C 的原因：
   - 溫度 Sensor 資料量小（幾個 byte），不需要高速
   - 只用 2 條線就能接，省 GPIO
   - 可以同時接很多其他 Sensor（用不同地址區分）
   - BME280 本身就支援 I2C

❌ 不選 SPI 的原因：
   - 雖然 BME280 也支援 SPI，但會多佔一條 CS 線
   - 沒有速度需求，用 SPI 是「殺雞用牛刀」

❌ 不選 UART 的原因：
   - BME280 不支援 UART
   - UART 是點對點，不適合接多個 Sensor
```

---

### 🎬 場景二：讀寫 SPI Flash（存韌體）→ 選 SPI

**為什麼不選其他的？**
```
✅ 選 SPI 的原因：
   - Flash 讀寫需要高速（例如更新 8MB 韌體）
   - SPI 可達 50MHz+，I2C 最快才 1MHz
   - 全雙工可以同時送 Command 和收 Data
   - SPI Flash 本身就是 SPI 介面

❌ 不選 I2C 的原因：
   - 太慢了！讀 8MB 要等很久
   - Flash 操作通常需要連續大量資料傳輸

❌ 不選 UART 的原因：
   - Flash 不支援 UART
   - UART 更慢（通常 115200 bps = 14KB/s）
   
💡 實際速度比較：
   - UART 115200 bps: 讀 1MB 約需 73 秒
   - I2C 400kHz:      讀 1MB 約需 20 秒
   - SPI 10MHz:       讀 1MB 約需 0.8 秒
```

---

### 🎬 場景三：Debug 輸出 Log → 選 UART

**為什麼不選其他的？**
```
✅ 選 UART 的原因：
   - printf 輸出是「發出去就好」，不需要對方回應
   - UART 設定簡單，只要 Baud Rate 對就能用
   - 可以直接接 USB-to-UART 轉接器連到 PC
   - 大部分 MCU 的 printf 預設就是輸出到 UART

❌ 不選 I2C 的原因：
   - I2C 是 Master-Slave 架構，PC 不適合當 Slave
   - Debug Log 不需要地址定址

❌ 不選 SPI 的原因：
   - SPI 連 PC 很麻煩，沒有標準的 USB-to-SPI 轉接器
   - Debug 不需要高速
```

---

### 🎬 場景四：接 GPS 模組 → 選 UART

**為什麼不選其他的？**
```
✅ 選 UART 的原因：
   - GPS 模組會「主動」輸出位置資料，不是你問它才回答
   - GPS 資料格式是 NMEA 字串，本來就是設計給 UART
   - GPS 模組通常預設就是 UART 介面（9600 bps）

❌ 不選 I2C 的原因：
   - GPS 不是你問它才回答，它會一直吐資料
   - I2C 是 Master 主導，不適合這種「Slave 主動輸出」的場景

❌ 不選 SPI 的原因：
   - 大部分 GPS 模組不支援 SPI
```

---

### 🎬 場景五：接 OLED 顯示器（SSD1306）→ 可選 I2C 或 SPI

**這個場景兩種都可以！**
```
情況 A：GPIO 有限 → 選 I2C
   - SSD1306 通常支援 I2C 和 SPI 兩種
   - I2C 只要 2 條線
   - 小畫面刷新率要求不高

情況 B：需要高刷新率 → 選 SPI
   - SPI 速度快，畫面更新更流暢
   - 適合需要快速動畫的應用

💡 實際考量：
   大部分 Arduino 玩家會選 I2C 版本（接線少）
   需要專業顯示效果的會選 SPI 版本（速度快）
```

---

### 🎬 場景六：同一個 MCU 接多個不同裝置

```
典型的嵌入式系統可能同時需要：
┌─────────────────────────────────────────────────────────────┐
│                         MCU                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   I2C Bus ─────┬──── 溫度 Sensor (BME280)                  │
│                ├──── EEPROM (AT24C256)                      │
│                ├──── RTC 時鐘 (DS3231)                      │
│                └──── 加速度計 (MPU6050)                     │
│                                                             │
│   SPI Bus ─────┬──── SPI Flash (W25Q64)                    │
│                └──── 大型 LCD 顯示器                        │
│                                                             │
│   UART ────────┬──── Debug Console (printf)                 │
│                └──── GPS 模組                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

設計原則：
1. 低速、多裝置 → I2C（省線）
2. 高速、大資料 → SPI（快）
3. Debug / 外部設備通訊 → UART（簡單）
```

---

### 🔀 決策流程圖

```
                    開始
                      │
                      ▼
            ┌─────────────────┐
            │  裝置支援哪種   │
            │  通訊協定？     │
            └────────┬────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
        ▼            ▼            ▼
    只支援一種    支援多種      不確定
        │            │            │
        │            ▼            ▼
        │     ┌─────────────┐   查 Datasheet！
        │     │ 需要高速？  │
        │     └──────┬──────┘
        │            │
        │      ┌─────┴─────┐
        │      │           │
        │      ▼           ▼
        │     是          否
        │      │           │
        │      ▼           ▼
        │   用 SPI    ┌────────────┐
        │             │ GPIO 緊張？│
        │             └─────┬──────┘
        │                   │
        │             ┌─────┴─────┐
        │             │           │
        │             ▼           ▼
        │            是          否
        │             │           │
        │             ▼           ▼
        └────────→ 用 I2C      都可以
                              （選簡單的）
```

---

### ⚡ 面試加分回答：「如何選擇通訊協定？」

```
「選擇通訊協定時，我會考慮以下幾點：

1. 裝置支援度：先確認裝置支援哪些協定，有時沒得選

2. 速度需求：
   - 高速（Flash、顯示器）→ 選 SPI
   - 中速（Sensor、EEPROM）→ 選 I2C
   - 低速（Debug、GPS）→ 選 UART

3. 資源限制：
   - GPIO 不夠 → 選 I2C（只要 2 條線）
   - 需要接很多裝置 → 選 I2C（共用 Bus）

4. 通訊模式：
   - 需要同時收發 → 選 SPI 或 UART（全雙工）
   - Slave 主動輸出 → 選 UART

5. 實際經驗：
   我在 OpenBMC 專案中，I2C 用來讀取各種 Sensor，
   SPI 用來讀寫 SPI Flash 韌體，
   UART 用來輸出 Debug Log...」
```

---

## 🔷 Linux Kernel I2C Subsystem 架構

### I2C Subsystem 三大核心結構

```c
/* include/linux/i2c.h */

/*
 * Linux I2C Subsystem 架構：
 *
 *  ┌─────────────────────────────────────────────────────┐
 *  │                    Application                       │
 *  │               (read/write /dev/i2c-N)                │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │                 I2C Core (i2c-core.c)               │
 *  │     • i2c_transfer() / i2c_smbus_*()                 │
 *  │     • Device/Driver 匹配                              │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │               I2C Adapter (i2c_adapter)             │
 *  │     • 代表 I2C Controller 硬體                       │
 *  │     • 實作 master_xfer() 進行實際傳輸                │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │                  I2C Hardware                        │
 *  │            (SoC I2C Controller)                      │
 *  └─────────────────────────────────────────────────────┘
 */

/* 1. I2C Adapter - 代表 I2C Controller (Master) */
struct i2c_adapter {
    struct module *owner;
    unsigned int class;               /* I2C_CLASS_HWMON, I2C_CLASS_DDC... */
    const struct i2c_algorithm *algo; /* 傳輸演算法 */
    void *algo_data;                  /* 演算法私有資料 */
    
    struct device dev;                /* sysfs 節點 */
    int nr;                           /* adapter 編號 (0, 1, 2...) */
    char name[48];                    /* adapter 名稱 */
    
    struct completion dev_released;
    
    int timeout;                      /* 傳輸超時 (jiffies) */
    int retries;                      /* 重試次數 */
    
    /* ... */
};

/* 2. I2C Client - 代表 I2C 上的一個裝置 (Slave) */
struct i2c_client {
    unsigned short flags;             /* I2C_CLIENT_TEN 等 */
    unsigned short addr;              /* 7-bit 或 10-bit 地址 */
    
    char name[I2C_NAME_SIZE];         /* 裝置名稱 */
    
    struct i2c_adapter *adapter;      /* 所屬的 adapter */
    struct device dev;                /* sysfs 節點 */
    int init_irq;                     /* 中斷號碼 */
    int irq;                          /* 中斷號碼 */
    
    /* ... */
};

/* 3. I2C Driver - 代表 I2C 裝置的驅動程式 */
struct i2c_driver {
    unsigned int class;
    
    int (*probe)(struct i2c_client *client);        /* 新版 probe */
    int (*remove)(struct i2c_client *client);
    void (*shutdown)(struct i2c_client *client);
    
    struct device_driver driver;                    /* 內嵌 device_driver */
    const struct i2c_device_id *id_table;           /* 舊版 ID 匹配 */
    
    /* ... */
};
```

### I2C Driver 完整實作範例

```c
/* 假設要寫一個 LM75 溫度 Sensor 的 Driver */

#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/hwmon.h>

#define LM75_REG_TEMP   0x00
#define LM75_REG_CONF   0x01

struct lm75_data {
    struct i2c_client *client;
    struct mutex lock;
    int temp;  /* 溫度值，milli-degrees */
};

/* 讀取溫度 */
static int lm75_read_temp(struct lm75_data *data)
{
    struct i2c_client *client = data->client;
    int ret;
    u8 buf[2];
    
    /* 使用 I2C 讀取暫存器 */
    ret = i2c_smbus_read_word_swapped(client, LM75_REG_TEMP);
    if (ret < 0) {
        dev_err(&client->dev, "Failed to read temperature\n");
        return ret;
    }
    
    /* LM75 溫度格式：16-bit，高 9 位是溫度，0.5°C 解析度 */
    data->temp = (s16)ret >> 7;  /* 取高 9 位 */
    data->temp *= 500;           /* 轉換成 milli-degrees */
    
    return 0;
}

/* sysfs 屬性 */
static ssize_t temp_show(struct device *dev,
                         struct device_attribute *attr, char *buf)
{
    struct lm75_data *data = dev_get_drvdata(dev);
    int ret;
    
    mutex_lock(&data->lock);
    ret = lm75_read_temp(data);
    mutex_unlock(&data->lock);
    
    if (ret)
        return ret;
    
    return sysfs_emit(buf, "%d\n", data->temp);
}
static DEVICE_ATTR_RO(temp);

static struct attribute *lm75_attrs[] = {
    &dev_attr_temp.attr,
    NULL,
};
ATTRIBUTE_GROUPS(lm75);

/* Probe 函式 */
static int lm75_probe(struct i2c_client *client)
{
    struct lm75_data *data;
    int ret;
    
    /* 確認 I2C 功能 */
    if (!i2c_check_functionality(client->adapter, 
            I2C_FUNC_SMBUS_WORD_DATA)) {
        dev_err(&client->dev, "Adapter doesn't support SMBus word\n");
        return -ENODEV;
    }
    
    data = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;
    
    data->client = client;
    mutex_init(&data->lock);
    
    i2c_set_clientdata(client, data);
    
    /* 讀取初始溫度確認裝置正常 */
    ret = lm75_read_temp(data);
    if (ret) {
        dev_err(&client->dev, "Failed to read initial temp\n");
        return ret;
    }
    
    dev_info(&client->dev, "LM75 detected, temp = %d mC\n", data->temp);
    
    return 0;
}

/* Device Tree 匹配 */
static const struct of_device_id lm75_of_match[] = {
    { .compatible = "national,lm75" },
    { .compatible = "ti,tmp75" },
    { }
};
MODULE_DEVICE_TABLE(of, lm75_of_match);

/* I2C ID Table（舊版匹配） */
static const struct i2c_device_id lm75_id[] = {
    { "lm75", 0 },
    { "tmp75", 0 },
    { }
};
MODULE_DEVICE_TABLE(i2c, lm75_id);

static struct i2c_driver lm75_driver = {
    .driver = {
        .name = "lm75",
        .of_match_table = lm75_of_match,
        .dev_groups = lm75_groups,
    },
    .probe = lm75_probe,
    .id_table = lm75_id,
};
module_i2c_driver(lm75_driver);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("LM75 Temperature Sensor Driver");
```

### Device Tree 配置

```dts
/* 在 Device Tree 中定義 I2C 裝置 */

&i2c1 {
    status = "okay";
    clock-frequency = <400000>;  /* 400kHz Fast Mode */
    
    /* LM75 溫度 Sensor @ 地址 0x48 */
    temp_sensor: lm75@48 {
        compatible = "national,lm75";
        reg = <0x48>;
    };
    
    /* EEPROM @ 地址 0x50 */
    eeprom: at24@50 {
        compatible = "atmel,24c256";
        reg = <0x50>;
        pagesize = <64>;
    };
};
```

### I2C SMBus API 詳解

```c
/* SMBus (System Management Bus) 是 I2C 的子集 */
/* 大部分 Sensor/EEPROM 都使用 SMBus 協定 */

/* Quick Command (只有地址，沒有資料) */
int i2c_smbus_quick(struct i2c_client *client, u8 value);

/* Read/Write Byte */
s32 i2c_smbus_read_byte(struct i2c_client *client);
s32 i2c_smbus_write_byte(struct i2c_client *client, u8 value);

/* Read/Write Byte Data (有 Register 地址) */
s32 i2c_smbus_read_byte_data(struct i2c_client *client, u8 command);
s32 i2c_smbus_write_byte_data(struct i2c_client *client, u8 command, u8 value);

/* Read/Write Word Data (16-bit) */
s32 i2c_smbus_read_word_data(struct i2c_client *client, u8 command);
s32 i2c_smbus_write_word_data(struct i2c_client *client, u8 command, u16 value);

/* Swapped Word (位元組順序交換) */
s32 i2c_smbus_read_word_swapped(struct i2c_client *client, u8 command);

/* Block Read/Write */
s32 i2c_smbus_read_block_data(struct i2c_client *client, u8 command, u8 *values);
s32 i2c_smbus_write_block_data(struct i2c_client *client, u8 command, 
                                u8 length, const u8 *values);

/* 原始 I2C 傳輸 */
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);

/* 使用 i2c_transfer 讀取多個 bytes */
static int my_read_regs(struct i2c_client *client, u8 reg, u8 *buf, int len)
{
    struct i2c_msg msgs[2] = {
        {
            .addr = client->addr,
            .flags = 0,           /* 寫 */
            .len = 1,
            .buf = &reg,
        },
        {
            .addr = client->addr,
            .flags = I2C_M_RD,    /* 讀 */
            .len = len,
            .buf = buf,
        },
    };
    
    int ret = i2c_transfer(client->adapter, msgs, 2);
    if (ret != 2)
        return ret < 0 ? ret : -EIO;
    
    return 0;
}
```

---

## 🔷 Linux Kernel SPI Subsystem 架構

### SPI Subsystem 核心結構

```c
/* include/linux/spi/spi.h */

/*
 * SPI Subsystem 架構：
 *
 *  ┌─────────────────────────────────────────────────────┐
 *  │                    Application                       │
 *  │               (read/write /dev/spidevN.M)            │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │                 SPI Core (spi.c)                     │
 *  │     • spi_sync() / spi_async()                       │
 *  │     • Device/Driver 匹配                              │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │              SPI Controller (spi_controller)        │
 *  │     • 代表 SPI Master 硬體                           │
 *  │     • 實作 transfer_one() 進行實際傳輸              │
 *  └────────────────────────┬────────────────────────────┘
 *                           ↓
 *  ┌─────────────────────────────────────────────────────┐
 *  │                  SPI Hardware                        │
 *  │            (SoC SPI Controller)                      │
 *  └─────────────────────────────────────────────────────┘
 */

/* SPI Controller (舊稱 spi_master) */
struct spi_controller {
    struct device dev;
    
    u16 bus_num;                      /* Controller 編號 */
    u16 num_chipselect;               /* 支援的 CS 數量 */
    
    /* 設定 SPI Mode */
    int (*setup)(struct spi_device *spi);
    
    /* 傳輸 */
    int (*transfer)(struct spi_device *spi, struct spi_message *mesg);
    int (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi,
                        struct spi_transfer *xfer);
    
    /* DMA 支援 */
    bool (*can_dma)(struct spi_controller *ctlr, struct spi_device *spi,
                    struct spi_transfer *xfer);
    
    /* Chip Select 控制 */
    void (*set_cs)(struct spi_device *spi, bool enable);
    
    /* ... */
};

/* SPI Device (從設備) */
struct spi_device {
    struct device dev;
    struct spi_controller *controller;
    
    u32 max_speed_hz;                 /* 最大時脈 */
    u8 chip_select;                   /* CS 編號 */
    u8 bits_per_word;                 /* 每字位數 (8, 16...) */
    u32 mode;                         /* SPI Mode (CPOL, CPHA) */
    
    int irq;                          /* 中斷號碼 */
    
    /* ... */
};

/* SPI Driver */
struct spi_driver {
    int (*probe)(struct spi_device *spi);
    void (*remove)(struct spi_device *spi);
    void (*shutdown)(struct spi_device *spi);
    
    struct device_driver driver;
    const struct spi_device_id *id_table;
};
```

### SPI 傳輸結構

```c
/* 單一傳輸操作 */
struct spi_transfer {
    const void *tx_buf;              /* 發送緩衝區 */
    void *rx_buf;                    /* 接收緩衝區 */
    unsigned len;                    /* 傳輸長度 */
    
    dma_addr_t tx_dma;               /* TX DMA 地址 */
    dma_addr_t rx_dma;               /* RX DMA 地址 */
    
    unsigned cs_change:1;            /* 傳輸後是否切換 CS */
    unsigned tx_nbits:3;             /* 幾線 TX (1/2/4) */
    unsigned rx_nbits:3;             /* 幾線 RX (1/2/4) */
    
    u32 speed_hz;                    /* 此次傳輸的時脈 */
    u16 delay_usecs;                 /* 傳輸後延遲 */
    
    struct list_head transfer_list;
};

/* 完整的 SPI 傳輸訊息 */
struct spi_message {
    struct list_head transfers;      /* spi_transfer 列表 */
    struct spi_device *spi;
    
    unsigned is_dma_mapped:1;        /* 是否已 DMA 映射 */
    
    /* 完成回調 */
    void (*complete)(void *context);
    void *context;
    
    int status;                      /* 傳輸結果 */
    unsigned actual_length;          /* 實際傳輸長度 */
};
```

### SPI Flash Driver 範例

```c
/* SPI Flash (例如 W25Q64) Driver 範例 */

#include <linux/spi/spi.h>
#include <linux/mtd/mtd.h>
#include <linux/mtd/partitions.h>

#define CMD_READ_ID     0x9F
#define CMD_READ_DATA   0x03
#define CMD_PAGE_PROG   0x02
#define CMD_SECTOR_ERASE 0x20
#define CMD_WRITE_EN    0x06
#define CMD_READ_STATUS 0x05

struct w25q_flash {
    struct spi_device *spi;
    struct mtd_info mtd;
    struct mutex lock;
};

/* 讀取 JEDEC ID */
static int w25q_read_id(struct w25q_flash *flash, u32 *id)
{
    u8 cmd = CMD_READ_ID;
    u8 buf[3];
    int ret;
    
    ret = spi_write_then_read(flash->spi, &cmd, 1, buf, 3);
    if (ret)
        return ret;
    
    *id = (buf[0] << 16) | (buf[1] << 8) | buf[2];
    return 0;
}

/* 讀取資料 */
static int w25q_read(struct w25q_flash *flash, u32 addr, 
                     u8 *buf, size_t len)
{
    u8 cmd[4];
    struct spi_transfer xfers[2] = { };
    struct spi_message msg;
    int ret;
    
    cmd[0] = CMD_READ_DATA;
    cmd[1] = (addr >> 16) & 0xFF;
    cmd[2] = (addr >> 8) & 0xFF;
    cmd[3] = addr & 0xFF;
    
    spi_message_init(&msg);
    
    /* 第一個 transfer: 發送命令 + 地址 */
    xfers[0].tx_buf = cmd;
    xfers[0].len = 4;
    spi_message_add_tail(&xfers[0], &msg);
    
    /* 第二個 transfer: 接收資料 */
    xfers[1].rx_buf = buf;
    xfers[1].len = len;
    spi_message_add_tail(&xfers[1], &msg);
    
    mutex_lock(&flash->lock);
    ret = spi_sync(flash->spi, &msg);
    mutex_unlock(&flash->lock);
    
    return ret;
}

/* Probe 函式 */
static int w25q_probe(struct spi_device *spi)
{
    struct w25q_flash *flash;
    u32 id;
    int ret;
    
    flash = devm_kzalloc(&spi->dev, sizeof(*flash), GFP_KERNEL);
    if (!flash)
        return -ENOMEM;
    
    flash->spi = spi;
    mutex_init(&flash->lock);
    
    spi_set_drvdata(spi, flash);
    
    /* 設定 SPI Mode */
    spi->mode = SPI_MODE_0;
    spi->bits_per_word = 8;
    ret = spi_setup(spi);
    if (ret)
        return ret;
    
    /* 讀取 ID 確認裝置 */
    ret = w25q_read_id(flash, &id);
    if (ret)
        return ret;
    
    dev_info(&spi->dev, "W25Q Flash detected, JEDEC ID: 0x%06X\n", id);
    
    return 0;
}

static const struct of_device_id w25q_of_match[] = {
    { .compatible = "winbond,w25q64" },
    { }
};
MODULE_DEVICE_TABLE(of, w25q_of_match);

static struct spi_driver w25q_driver = {
    .driver = {
        .name = "w25q64",
        .of_match_table = w25q_of_match,
    },
    .probe = w25q_probe,
};
module_spi_driver(w25q_driver);
```

### SPI DMA 傳輸

```c
/* 對於大量資料傳輸，使用 DMA 可提高效能 */

static int my_spi_dma_transfer(struct spi_device *spi, 
                               void *tx, void *rx, size_t len)
{
    struct spi_transfer xfer = {
        .tx_buf = tx,
        .rx_buf = rx,
        .len = len,
        /* 如果 controller 支援 DMA，會自動使用 */
    };
    
    return spi_sync_transfer(spi, &xfer, 1);
}

/* Controller 端設定 DMA Threshold */
static bool my_spi_can_dma(struct spi_controller *ctlr,
                           struct spi_device *spi,
                           struct spi_transfer *xfer)
{
    /* 只有當傳輸長度超過 threshold 時才使用 DMA */
    return xfer->len >= 256;
}
```

---

## 🔷 Linux Kernel UART/TTY Subsystem 架構

### TTY Subsystem 概述

```
┌─────────────────────────────────────────────────────────────────────────┐
│                     Linux TTY Subsystem 架構                             │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│   Application                                                            │
│       ↓ open("/dev/ttyS0")                                               │
│   ┌──────────────────────────────────────────────────────────────┐      │
│   │                     TTY Core                                  │      │
│   │   • /dev/ttyS*, /dev/ttyUSB*, /dev/ttyAMA*                   │      │
│   │   • Line Discipline (N_TTY, PPP, SLIP...)                    │      │
│   └──────────────────────────┬───────────────────────────────────┘      │
│                              ↓                                           │
│   ┌──────────────────────────────────────────────────────────────┐      │
│   │                    TTY Driver                                 │      │
│   │   • tty_operations (open, close, write, ioctl...)            │      │
│   └──────────────────────────┬───────────────────────────────────┘      │
│                              ↓                                           │
│   ┌──────────────────────────────────────────────────────────────┐      │
│   │                  Serial Core                                  │      │
│   │   • uart_driver / uart_port                                   │      │
│   │   • uart_ops (start_tx, stop_tx, tx_empty...)                │      │
│   └──────────────────────────┬───────────────────────────────────┘      │
│                              ↓                                           │
│   ┌──────────────────────────────────────────────────────────────┐      │
│   │                UART Hardware                                  │      │
│   │            (SoC UART Controller)                              │      │
│   └──────────────────────────────────────────────────────────────┘      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### Serial Core 核心結構

```c
/* include/linux/serial_core.h */

/* UART Driver - 代表一類 UART (例如 8250 系列) */
struct uart_driver {
    struct module *owner;
    const char *driver_name;         /* "serial" */
    const char *dev_name;            /* "ttyS" */
    int major;                       /* 主裝置號 */
    int minor;                       /* 起始次裝置號 */
    int nr;                          /* 最大 port 數量 */
    
    struct console *cons;            /* Console 指標 */
    
    /* ... */
};

/* UART Port - 代表一個 UART */
struct uart_port {
    spinlock_t lock;
    unsigned long iobase;            /* I/O port base */
    unsigned char __iomem *membase;  /* Memory mapped base */
    unsigned int irq;                /* IRQ 號碼 */
    
    unsigned int uartclk;            /* UART clock */
    unsigned int fifosize;           /* FIFO 大小 */
    unsigned char x_char;            /* XON/XOFF 字元 */
    unsigned char regshift;          /* 暫存器偏移 */
    
    unsigned int line;               /* Port 編號 */
    unsigned int type;               /* PORT_16550A 等 */
    
    const struct uart_ops *ops;      /* 操作函式 */
    
    struct device *dev;
    
    /* ... */
};

/* UART 操作函式 */
struct uart_ops {
    unsigned int (*tx_empty)(struct uart_port *port);
    void (*set_mctrl)(struct uart_port *port, unsigned int mctrl);
    unsigned int (*get_mctrl)(struct uart_port *port);
    void (*stop_tx)(struct uart_port *port);
    void (*start_tx)(struct uart_port *port);
    void (*stop_rx)(struct uart_port *port);
    void (*break_ctl)(struct uart_port *port, int ctl);
    int (*startup)(struct uart_port *port);
    void (*shutdown)(struct uart_port *port);
    void (*set_termios)(struct uart_port *port, struct ktermios *new,
                        const struct ktermios *old);
    /* ... */
};
```

### 簡單 UART Driver 範例

```c
/* 極簡 UART Driver 框架 */

#include <linux/serial_core.h>
#include <linux/platform_device.h>

#define MY_UART_NR   4

static struct uart_driver my_uart_driver = {
    .owner      = THIS_MODULE,
    .driver_name = "my_uart",
    .dev_name   = "ttyMY",
    .major      = 0,  /* 動態分配 */
    .minor      = 0,
    .nr         = MY_UART_NR,
};

static unsigned int my_uart_tx_empty(struct uart_port *port)
{
    /* 檢查 TX FIFO 是否為空 */
    u32 status = readl(port->membase + REG_STATUS);
    return (status & TX_EMPTY) ? TIOCSER_TEMT : 0;
}

static void my_uart_start_tx(struct uart_port *port)
{
    /* 啟動發送 */
    u32 ctrl = readl(port->membase + REG_CTRL);
    ctrl |= TX_ENABLE;
    writel(ctrl, port->membase + REG_CTRL);
}

static void my_uart_stop_tx(struct uart_port *port)
{
    /* 停止發送 */
    u32 ctrl = readl(port->membase + REG_CTRL);
    ctrl &= ~TX_ENABLE;
    writel(ctrl, port->membase + REG_CTRL);
}

static int my_uart_startup(struct uart_port *port)
{
    /* Port 啟動初始化 */
    /* 請求中斷、啟用 RX 等 */
    return 0;
}

static void my_uart_shutdown(struct uart_port *port)
{
    /* Port 關閉清理 */
}

static void my_uart_set_termios(struct uart_port *port,
                                struct ktermios *new,
                                const struct ktermios *old)
{
    unsigned int baud;
    
    /* 計算 baud rate */
    baud = uart_get_baud_rate(port, new, old, 9600, 4000000);
    
    /* 設定硬體 baud rate */
    writel(port->uartclk / (16 * baud), port->membase + REG_BAUD);
    
    /* 設定其他參數 (data bits, parity, stop bits) */
}

static const struct uart_ops my_uart_ops = {
    .tx_empty     = my_uart_tx_empty,
    .start_tx     = my_uart_start_tx,
    .stop_tx      = my_uart_stop_tx,
    .startup      = my_uart_startup,
    .shutdown     = my_uart_shutdown,
    .set_termios  = my_uart_set_termios,
    /* ... */
};

static int my_uart_probe(struct platform_device *pdev)
{
    struct uart_port *port;
    struct resource *res;
    int ret;
    
    port = devm_kzalloc(&pdev->dev, sizeof(*port), GFP_KERNEL);
    if (!port)
        return -ENOMEM;
    
    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    port->membase = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(port->membase))
        return PTR_ERR(port->membase);
    
    port->irq = platform_get_irq(pdev, 0);
    port->ops = &my_uart_ops;
    port->dev = &pdev->dev;
    port->type = PORT_16550A;
    port->line = pdev->id;
    
    ret = uart_add_one_port(&my_uart_driver, port);
    if (ret)
        return ret;
    
    platform_set_drvdata(pdev, port);
    
    return 0;
}
```

---

## 📝 進階面試題庫

### Q1: i2c_smbus_read_byte_data 和 i2c_transfer 的區別？

**難度**：⭐⭐⭐⭐
**常見於**：NVIDIA / 聯發科

**答案**：

```c
/* i2c_smbus_* 系列 */
/* - 高階 API，封裝 SMBus 協定 */
/* - 較常用，支援大部分 I2C 裝置 */
/* - 自動處理 Start/Stop/ACK */

s32 val = i2c_smbus_read_byte_data(client, 0x10);
/* 相當於：S - Addr+W - 0x10 - Sr - Addr+R - [data] - P */

/* i2c_transfer */
/* - 低階 API，完全控制傳輸序列 */
/* - 可以自訂複雜的傳輸模式 */
/* - 需要自己組裝 i2c_msg */

struct i2c_msg msgs[2];
u8 reg = 0x10;
u8 data;

msgs[0].addr = client->addr;
msgs[0].flags = 0;
msgs[0].len = 1;
msgs[0].buf = &reg;

msgs[1].addr = client->addr;
msgs[1].flags = I2C_M_RD;
msgs[1].len = 1;
msgs[1].buf = &data;

i2c_transfer(client->adapter, msgs, 2);
```

**何時用 i2c_transfer**：
- 需要連續傳輸多個 bytes 到不同暫存器
- 需要特殊的傳輸序列
- 裝置不符合標準 SMBus 協定

---

### Q2: SPI 的 spi_sync 和 spi_async 區別？

**難度**：⭐⭐⭐⭐
**常見於**：普遍

**答案**：

```c
/* spi_sync - 同步傳輸 */
/* - 阻塞直到傳輸完成 */
/* - 簡單易用 */
/* - 不能在 interrupt context 使用 */

ret = spi_sync(spi, &msg);
/* 這裡傳輸已完成 */
if (ret == 0) {
    /* 成功，可以使用 rx_buf 中的資料 */
}

/* spi_async - 非同步傳輸 */
/* - 立即返回，不等待完成 */
/* - 透過 callback 通知完成 */
/* - 可以在 interrupt context 使用 */

static void my_complete(void *ctx)
{
    struct my_data *data = ctx;
    /* 傳輸完成，處理 rx_buf */
    complete(&data->done);
}

msg.complete = my_complete;
msg.context = data;

ret = spi_async(spi, &msg);
/* 立即返回，傳輸可能還在進行 */

wait_for_completion(&data->done);
/* 現在傳輸完成了 */
```

---

### Q3: I2C Bus Recovery 是什麼？如何實現？

**難度**：⭐⭐⭐⭐⭐
**常見於**：NVIDIA / 硬體相關職位

**答案**：

當 I2C Slave 裝置卡住（例如中途斷電），SDA 可能被拉低，導致 Bus 無法使用。

**Recovery 方法**：
```c
/* 標準方法：發送 9 個 Clock Pulse */
/* Slave 看到 9 個 clock 後會釋放 SDA */

static int i2c_recover_bus(struct i2c_adapter *adap)
{
    int i;
    
    /* 1. 確認 SDA 是低電位 (Bus stuck) */
    if (gpio_get_value(sda_gpio))
        return 0;  /* SDA 是高，Bus 正常 */
    
    /* 2. 發送 9 個 Clock */
    for (i = 0; i < 9; i++) {
        gpio_set_value(scl_gpio, 1);
        udelay(5);
        gpio_set_value(scl_gpio, 0);
        udelay(5);
    }
    
    /* 3. 發送 STOP 條件 */
    gpio_set_value(sda_gpio, 0);
    udelay(5);
    gpio_set_value(scl_gpio, 1);
    udelay(5);
    gpio_set_value(sda_gpio, 1);  /* SDA 從 0 變 1 */
    
    /* 4. 檢查是否恢復 */
    if (!gpio_get_value(sda_gpio)) {
        dev_err(&adap->dev, "Bus recovery failed\n");
        return -EIO;
    }
    
    return 0;
}

/* Linux Kernel 內建支援 */
static const struct i2c_bus_recovery_info my_recovery = {
    .recover_bus = i2c_generic_scl_recovery,
    .get_scl = my_get_scl,
    .set_scl = my_set_scl,
    .get_sda = my_get_sda,
    .set_sda = my_set_sda,
};

adap->bus_recovery_info = &my_recovery;
```

---

### Q4: UART 的 termios 結構是什麼？

**難度**：⭐⭐⭐⭐
**常見於**：普遍

**答案**：

`termios` 是用來設定終端機/串列埠參數的結構。

```c
/* include/uapi/asm-generic/termbits.h */

struct termios {
    tcflag_t c_iflag;   /* 輸入模式 */
    tcflag_t c_oflag;   /* 輸出模式 */
    tcflag_t c_cflag;   /* 控制模式 */
    tcflag_t c_lflag;   /* 本地模式 */
    cc_t c_cc[NCCS];    /* 特殊字元 */
};

/* 常用的 c_cflag 設定 */
#define CSIZE    000000060   /* 資料位數遮罩 */
#define   CS5    000000000   /* 5 bits */
#define   CS6    000000020   /* 6 bits */
#define   CS7    000000040   /* 7 bits */
#define   CS8    000000060   /* 8 bits */
#define CSTOPB   000000100   /* 2 stop bits */
#define CREAD    000000200   /* 啟用接收 */
#define PARENB   000000400   /* 啟用 parity */
#define PARODD   000001000   /* 奇數 parity */
#define CLOCAL   000004000   /* 忽略 modem 控制線 */
#define CRTSCTS  020000000   /* 硬體流控 */

/* 設定 115200 8N1 */
struct termios tio;
tcgetattr(fd, &tio);

tio.c_cflag &= ~CSIZE;
tio.c_cflag |= CS8;        /* 8 bits */
tio.c_cflag &= ~PARENB;    /* No parity */
tio.c_cflag &= ~CSTOPB;    /* 1 stop bit */

cfsetispeed(&tio, B115200);
cfsetospeed(&tio, B115200);

tcsetattr(fd, TCSANOW, &tio);
```

---

### Q5: 如何在 Driver 中處理 I2C NACK？

**難度**：⭐⭐⭐⭐
**常見於**：普遍

**答案**：

```c
/* I2C 傳輸可能因為 NACK 而失敗 */

static int my_read_reg(struct i2c_client *client, u8 reg, u8 *val)
{
    int ret;
    int retries = 3;
    
    do {
        ret = i2c_smbus_read_byte_data(client, reg);
        if (ret >= 0) {
            *val = ret;
            return 0;
        }
        
        /* 常見錯誤碼 */
        switch (ret) {
        case -ENXIO:     /* No ACK received (裝置不存在) */
            dev_dbg(&client->dev, "Device not responding\n");
            break;
        case -EIO:       /* I/O error */
            dev_dbg(&client->dev, "I2C I/O error\n");
            break;
        case -ETIMEDOUT: /* 超時 */
            dev_dbg(&client->dev, "I2C timeout\n");
            break;
        }
        
        msleep(10);  /* 等待後重試 */
        
    } while (--retries > 0);
    
    dev_err(&client->dev, "I2C read failed after retries: %d\n", ret);
    return ret;
}

/* 檢測裝置是否存在 */
static bool my_device_present(struct i2c_client *client)
{
    int ret;
    
    /* 發送一個 Quick Command */
    ret = i2c_smbus_quick(client, I2C_SMBUS_READ);
    
    return (ret == 0);
}
```

---

### Q6: SPI 的四種 Mode (0-3) 差異？

**難度**：⭐⭐⭐
**常見於**：基礎題

**答案**：

```
SPI Mode = CPOL + CPHA

CPOL (Clock Polarity): 閒置時 SCK 電位
CPHA (Clock Phase): 資料取樣時機

┌──────┬──────┬──────┬─────────────────────────────────────────┐
│ Mode │ CPOL │ CPHA │                  說明                    │
├──────┼──────┼──────┼─────────────────────────────────────────┤
│  0   │  0   │  0   │ 閒置時 SCK=0，第一個邊沿取樣（上升沿）    │
│  1   │  0   │  1   │ 閒置時 SCK=0，第二個邊沿取樣（下降沿）    │
│  2   │  1   │  0   │ 閒置時 SCK=1，第一個邊沿取樣（下降沿）    │
│  3   │  1   │  1   │ 閒置時 SCK=1，第二個邊沿取樣（上升沿）    │
└──────┴──────┴──────┴─────────────────────────────────────────┘

時序圖 (Mode 0):

SCK:  _____|‾‾‾‾‾|_____|‾‾‾‾‾|_____|‾‾‾‾‾|_____
          ↑           ↑           ↑
         取樣         取樣         取樣

時序圖 (Mode 3):

SCK:  ‾‾‾‾‾|_____|‾‾‾‾‾|_____|‾‾‾‾‾|_____|‾‾‾‾‾
                 ↑           ↑           ↑
                取樣         取樣         取樣
```

**設定方法**：
```c
spi->mode = SPI_MODE_0;  /* CPOL=0, CPHA=0 */
spi->mode = SPI_MODE_3;  /* CPOL=1, CPHA=1 */
spi_setup(spi);
```

---

## 📚 延伸閱讀

1. **Linux Kernel 文件**
   - Documentation/i2c/
   - Documentation/spi/
   - Documentation/serial/

2. **Kernel Source**
   - drivers/i2c/
   - drivers/spi/
   - drivers/tty/serial/

3. **書籍**
   - Linux Device Drivers, 3rd Edition
   - Understanding the Linux Kernel

4. **線上資源**
   - [Bootlin I2C Training](https://bootlin.com/doc/training/linux-kernel/)
   - [SPI Tutorial](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html)
