# 🔌 I2C / SPI / UART 通訊協定詳解

> 這三個通訊協定是嵌入式和韌體工程師的必備知識  
> 面試幾乎一定會問！

---

## 📌 三種協定比較

| 特性 | I2C | SPI | UART |
|-----|-----|-----|------|
| **全名** | Inter-Integrated Circuit | Serial Peripheral Interface | Universal Asynchronous Receiver-Transmitter |
| **線數** | 2 條（SDA + SCL）| 4 條（MOSI + MISO + SCK + CS）| 2 條（TX + RX）|
| **速度** | 100kHz / 400kHz / 1MHz+ | 可達 50MHz+ | 通常 9600-115200 bps |
| **傳輸模式** | ❌ 半雙工 (SDA 共用，不可同時收發) | ✅ 全雙工 (MOSI/MISO 獨立，可同時收發) | ✅ 全雙工 (TX/RX 獨立，可同時收發) |
| **Master/Slave** | 多 Master 多 Slave | 1 Master 多 Slave | 點對點 |
| **定址方式** | 7-bit 或 10-bit 位址 | CS（Chip Select）線 | 無需定址 |
| **常見用途** | Sensor、EEPROM、RTC | Flash、顯示器、SD卡 | Debug console、GPS |

---

## 🔷 I2C 協定詳解

### 💡 什麼是 I2C？為什麼需要它？

**I2C (Inter-Integrated Circuit)** = 積體電路間通訊，由 Philips（現 NXP）發明

**最大特色：只需要 2 條線，就能連接很多裝置！**

想像一間教室：
- **SPI** 像是每個學生都有專線電話找老師（每人一條 CS 線）
- **I2C** 像是全班共用一個廣播系統，老師喊學號（地址）再指定誰回答

**I2C 的特點：**
```
✅ 省線！只需要 2 條線（SDA + SCL）
✅ 可以接很多裝置（用地址區分，理論上 128 個）
✅ 有 ACK 機制，知道對方有沒有收到
✅ 支援多 Master（進階功能）
❌ 速度較慢（通常 100kHz ~ 400kHz）
❌ 半雙工（不能同時收發）
❌ 需要外部上拉電阻
```

**常見使用場景：**
- 溫度/濕度 Sensor（DHT12、BME280）
- EEPROM（24C02、AT24C256）
- RTC 即時時鐘（DS1307、DS3231）
- 加速度計/陀螺儀（MPU6050）
- OLED 顯示器（SSD1306）

---

### 硬體連接

```
       MCU (Master)                    Sensor (Slave)
    ┌─────────────┐                 ┌─────────────┐
    │         SDA ├─────────────────┤ SDA         │
    │         SCL ├─────────────────┤ SCL         │
    │         GND ├─────────────────┤ GND         │
    └─────────────┘                 └─────────────┘
                    │    │
                    R    R  ← 上拉電阻（Pull-up Resistor）
                    │    │
                   VCC  VCC
```

---

### 基本概念（詳細解釋）

#### 🔌 兩條線的功能

```
┌───────┬─────────────────────────────────────────────────────┐
│  線名 │                     白話解釋                        │
├───────┼─────────────────────────────────────────────────────┤
│  SDA  │ Serial Data = 資料線                                │
│       │ 雙向！Master 和 Slave 輪流用這條線傳資料             │
│       │ 想像：一條單線道的路，車子輪流通行                    │
├───────┼─────────────────────────────────────────────────────┤
│  SCL  │ Serial Clock = 時脈線                               │
│       │ 單向！永遠由 Master 產生                             │
│       │ 想像：指揮交通的紅綠燈，告訴大家什麼時候該看資料       │
└───────┴─────────────────────────────────────────────────────┘
```

#### 🔧 什麼是 Open-Drain？為什麼需要上拉電阻？

這是 I2C 最重要但最難懂的概念！用圖解說明：

```
一般輸出（Push-Pull）：
    VCC ─────┬─────
             │
         【開關1】← 可以主動輸出「高」
             │
    輸出 ────┼──────→
             │
         【開關2】← 可以主動輸出「低」
             │
    GND ─────┴─────
    
    優點：可以主動輸出高和低
    缺點：如果兩個裝置同時輸出，一個高一個低 = 短路！💥


Open-Drain 輸出（I2C 使用）：
    VCC ─────┬───── R（上拉電阻）
             │        ↓
             └────────┼──────→ 輸出
                      │
                  【開關】← 只能主動拉「低」
                      │
    GND ──────────────┴─────
    
    工作原理：
    - 開關關閉（不導通）→ 電阻把線拉到 VCC → 輸出「高」
    - 開關打開（導通）  → 線直接接地       → 輸出「低」
    
    優點：多個裝置可以共用同一條線！
         任何一個拉低，線就是低（Wired-AND 邏輯）
         沒人拉低，電阻把線拉高
```

**Wired-AND 實例：**
```
              VCC
               │
               R（上拉電阻）
               │
    ───────────┼─────────── SDA
         │     │     │
        裝置A  裝置B  裝置C
         │     │     │
        GND   GND   GND

如果大家都放開（不拉低）：SDA = 高
只要有人拉低：SDA = 低

這就是為什麼 ACK 要用「低電位」表示！
接收成功的裝置會主動把 SDA 拉低，Master 就知道有人收到了。
```

---

### 🏷️ I2C 地址詳解

每個 I2C 裝置都有一個「地址」，就像學生的學號。

#### 7-bit 地址格式

```
發送的第一個 byte：
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ A6│ A5│ A4│ A3│ A2│ A1│ A0│R/W│
└───┴───┴───┴───┴───┴───┴───┴───┘
│<────── 7-bit 地址 ──────>│ │
                              │
                              └── 0 = Write（Master 要寫）
                                  1 = Read（Master 要讀）
```

#### 地址計算範例

```
假設一個 Sensor 的 7-bit 地址是 0x48

要「寫入」資料時：
  地址 0x48 = 0b1001000
  加上 R/W = 0（寫）
  完整 byte = 0b10010000 = 0x90

要「讀取」資料時：
  地址 0x48 = 0b1001000  
  加上 R/W = 1（讀）
  完整 byte = 0b10010001 = 0x91

💡 面試技巧：
有些 Datasheet 會直接寫 8-bit 地址（含 R/W bit）
例如寫成「Write: 0x90, Read: 0x91」
實際的 7-bit 地址 = 0x90 >> 1 = 0x48
```

#### 常見裝置地址表

```
┌────────────────────┬───────────────┬────────────────────────┐
│       裝置         │  7-bit 地址   │         備註           │
├────────────────────┼───────────────┼────────────────────────┤
│ EEPROM AT24C02     │   0x50-0x57   │ 可用 A0-A2 調整        │
├────────────────────┼───────────────┼────────────────────────┤
│ RTC DS3231         │     0x68      │ 固定地址               │
├────────────────────┼───────────────┼────────────────────────┤
│ 溫溼度 BME280      │   0x76/0x77   │ SDO 接地=0x76          │
├────────────────────┼───────────────┼────────────────────────┤
│ OLED SSD1306       │   0x3C/0x3D   │ 常見 0x3C              │
├────────────────────┼───────────────┼────────────────────────┤
│ 加速度計 MPU6050   │   0x68/0x69   │ AD0 接地=0x68          │
└────────────────────┴───────────────┴────────────────────────┘

⚠️ 注意：DS3231 和 MPU6050 地址都是 0x68，不能同時接在同一條 I2C！
```

---

### 如何解讀時序圖？

1. **SCL (時脈) 是節拍器**：所有的動作都必須跟著 SCL 的節奏。當 **SCL 為高電位 (High)** 時，SDA 上的資料被視為「有效」且不可改變。
2. **SDA 的改變時機**：只有當 **SCL 為低電位 (Low)** 時，SDA 才可以改變數值（0 變 1 或 1 變 0）。這也是為什麼資料切換都發生在 SCL 的低谷。
3. **唯一的例外 (Start/Stop)**：若 **SCL 保持高電位** 時 SDA 發生了跳變，這代表特殊的通訊信號而非資料：
    - **Start**：SCL 為 High 時，SDA 從高變低。
    - **Stop**：SCL 為 High 時，SDA 從低變高。

```
視覺化：什麼時候 SDA 可以變？

SCL:  ──────┐      ┌──────┐      ┌──────
            │      │      │      │
            └──────┘      └──────┘
              ↑              ↑
            可以變         可以變
            SDA            SDA
            
SCL 高的時候：SDA 必須穩定（這時在讀取資料）
SCL 低的時候：SDA 可以變化（準備下一個 bit）
```

---

### I2C 通訊流程（圖解版）

```
完整的 I2C 寫入流程：向 Slave 0x48 寫入 1 byte 資料 0xAB

    Master                                          Slave 0x48
      │                                                  │
      │  1. 發送 Start Condition                         │
      │────────────────────────────────────────────────→│
      │     (通知所有人：我要開始了！)                     │
      │                                                  │
      │  2. 發送地址 + Write bit (0x90)                  │
      │────────────────────────────────────────────────→│
      │     (喊：0x48 號同學！我要寫資料給你！)            │
      │                                                  │
      │  3. Slave 回應 ACK                               │
      │←────────────────────────────────────────────────│
      │     (0x48：有！我在！)                            │
      │                                                  │
      │  4. 發送資料 0xAB                                │
      │────────────────────────────────────────────────→│
      │                                                  │
      │  5. Slave 回應 ACK                               │
      │←────────────────────────────────────────────────│
      │     (收到！)                                      │
      │                                                  │
      │  6. 發送 Stop Condition                          │
      │────────────────────────────────────────────────→│
      │     (好，結束！)                                  │
      │                                                  │
```

---

### 時序圖（詳細版）

```
寫入 1 byte 到 Slave 0x48 的完整時序：

SCL:  ────┐  ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐...
          └──┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─
              1   2   3   4   5   6   7   8   9

SDA:  ─┐                                             ┌────
       └──┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─────┘
          │ 1 │ 0 │ 0 │ 1 │ 0 │ 0 │ 0 │ 0 │ACK│
          │<───── 0x48 地址 ─────>│R/W│   │
       ↑                              │   └── Slave 拉低=收到
     Start                            └── 0=Write
     
地址 0x48 = 0b1001000
R/W = 0 (Write)
ACK = SDA 被 Slave 拉低（表示有收到）
```

---

### ACK 和 NACK 的意義

```
┌────────┬─────────────┬────────────────────────────────────┐
│  狀態  │  SDA 電位   │              意義                  │
├────────┼─────────────┼────────────────────────────────────┤
│  ACK   │     低      │ 「收到了！」                        │
│        │             │ 接收方主動把 SDA 拉低                │
├────────┼─────────────┼────────────────────────────────────┤
│  NACK  │     高      │ 「沒收到」或「不想收了」             │
│        │             │ 接收方沒有拉低，上拉電阻使其為高     │
└────────┴─────────────┴────────────────────────────────────┘

NACK 的常見原因：
1. 沒有這個地址的裝置（根本沒人回應）
2. Slave 正在忙，無法處理
3. Master 讀取時，最後一個 byte 會故意送 NACK，表示「不用再送了」
```

---

### 常見面試問題

**Q1：I2C 為什麼需要上拉電阻？**
```
I2C 使用 open-drain 輸出：
- 只能主動拉低電壓（接地）
- 無法主動輸出高電壓
- 需要上拉電阻把線拉到 VCC，才能有高電位

好處：
- 允許多個裝置共用同一條線，不會互相干擾
- 實現 wired-AND 邏輯
- ACK 機制就是靠這個原理：Slave 拉低 = ACK，沒人拉低 = NACK
```

**Q2：如果 Slave 沒有回應 ACK 會怎樣？**
```
- Master 會檢測到 NACK（SDA 保持高電位）
- 通常表示：
  1. 位址錯誤（沒有這個 Slave）
  2. Slave 忙碌無法處理
  3. 資料傳輸有問題
- Master 應該發送 Stop 或重試
```

**Q3：什麼是 Clock Stretching？**
```
Slave 可以拉住 SCL 使其保持低電位，暫停通訊。

原理圖：
    Master 想拉高 SCL ─┐
                       ├─→ SCL 還是低！（被 Slave 拉住）
    Slave 拉低 SCL ────┘
    
用途：Slave 處理速度較慢時，需要時間準備資料。
Master 必須在 SCL 恢復高電位後才能繼續。

⚠️ 注意：不是所有 Master 都支援 Clock Stretching！
         要查 datasheet 確認。
```

**Q4：I2C 有時會「卡住」，如何處理？**
```
可能原因：Slave 在傳輸途中被 reset，導致 SDA 被拉低

現象：SDA 一直是低電位，Master 無法發送 Start Condition

解決方法：
1. 發送 9 個 Clock pulse（讓 Slave 完成可能的傳輸）
2. 發送 Stop Condition
3. 重新初始化 I2C

程式碼範例：
for (int i = 0; i < 9; i++) {
    SCL = 0; delay();
    SCL = 1; delay();
}
// 發送 Stop
SDA = 0;
SCL = 1;
SDA = 1;
```

---

## 🔷 SPI 協定詳解

### 💡 什麼是 SPI？為什麼需要它？

**SPI (Serial Peripheral Interface)** = 串列周邊介面

想像你是一個老闆（Master），要同時管理多個員工（Slave）：
- **I2C** 像是用對講機：所有人共用一個頻道，說話前要先喊對方名字（地址）
- **SPI** 像是每人一條專線電話（CS 線）：直接按鈕接通特定員工，不用喊名字

**SPI 的特點：**
```
✅ 超快！可達數十 MHz（比 I2C 快上百倍）
✅ 全雙工：可以同時「說」和「聽」
✅ 簡單：沒有複雜的地址系統
❌ 線多：每多一個 Slave，就多一條 CS 線
❌ 只適合短距離（同一塊電路板上）
```

**常見使用場景：**
- SPI Flash（儲存韌體/程式碼）
- SD 記憶卡
- LCD 顯示器
- 高速 ADC/DAC

---

### 硬體連接

```
       MCU (Master)                    Flash (Slave)
    ┌─────────────┐                 ┌─────────────┐
    │        MOSI ├─────────────────┤ MOSI (DI)   │
    │        MISO ├─────────────────┤ MISO (DO)   │
    │         SCK ├─────────────────┤ SCK         │
    │          CS ├─────────────────┤ CS (SS)     │
    │         GND ├─────────────────┤ GND         │
    └─────────────┘                 └─────────────┘
```

---

### 基本概念（詳細解釋）

#### 🔌 四條線的功能

```
┌──────────┬────────────────────────────────────────────────────────┐
│   線名   │                       白話解釋                         │
├──────────┼────────────────────────────────────────────────────────┤
│   MOSI   │ Master 的「嘴巴」→ Slave 的「耳朵」                    │
│          │ Master Out, Slave In = Master 說話，Slave 聽           │
├──────────┼────────────────────────────────────────────────────────┤
│   MISO   │ Slave 的「嘴巴」→ Master 的「耳朵」                    │
│          │ Master In, Slave Out = Slave 說話，Master 聽           │
├──────────┼────────────────────────────────────────────────────────┤
│   SCK    │ 「節拍器」，所有動作都跟著它的節奏                      │
│          │ Serial Clock = 時脈，永遠由 Master 產生                 │
├──────────┼────────────────────────────────────────────────────────┤
│   CS     │ 「點名」用的線，拉低 = 叫到這個 Slave                   │
│          │ Chip Select = 選擇晶片，低電位有效 (Active Low)        │
└──────────┴────────────────────────────────────────────────────────┘
```

#### 📞 通訊流程比喻

想像打電話給朋友：
```
1. 📱 拿起電話撥號      → CS 拉低（選擇 Slave）
2. 🗣️ 開始交談         → 透過 MOSI/MISO 傳資料，跟著 SCK 節奏
3. 📞 掛電話           → CS 拉高（結束通訊）
```

#### 🔄 全雙工的意義

```
I2C (半雙工) - 像對講機：
    按住說話 ────→        （不能同時聽）
              ←──── 放開才能聽

SPI (全雙工) - 像電話：
    說話 ────────────→     （同時雙向）
        ←────────────聽
              
實際上，SPI 的 MOSI 和 MISO 是「同時」在傳資料的！
每個 SCK 週期，兩邊各傳 1 bit。
```

---

### SPI 模式（圖解）

SPI 有 4 種模式，由 **CPOL** 和 **CPHA** 兩個設定決定。

#### 🎯 先理解兩個關鍵設定

```
CPOL (Clock Polarity) - 時脈極性
└── 問：「沒事的時候，時脈停在高還是低？」
    ├── CPOL = 0：閒置時 SCK = 低電位 ───┐
    └── CPOL = 1：閒置時 SCK = 高電位 ───┘

CPHA (Clock Phase) - 時脈相位  
└── 問：「在時脈的哪個邊緣讀取資料？」
    ├── CPHA = 0：第一個邊緣取樣（較早）
    └── CPHA = 1：第二個邊緣取樣（較晚）
```

#### 📊 四種模式對照表

| Mode | CPOL | CPHA | 時脈閒置狀態 | 資料取樣時機 |
|------|------|------|------------|------------|
| 0 | 0 | 0 | 低 | SCK 上升沿 |
| 1 | 0 | 1 | 低 | SCK 下降沿 |
| 2 | 1 | 0 | 高 | SCK 下降沿 |
| 3 | 1 | 1 | 高 | SCK 上升沿 |

#### 🖼️ 視覺化時序圖

**Mode 0（CPOL=0, CPHA=0）- 最常見！**
```
CS:   ────┐                                         ┌────
          └─────────────────────────────────────────┘
          ▲ CS 拉低開始                             ▲ CS 拉高結束
          
SCK:  ────┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐
     (低) └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──
              ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
              取樣  取樣  取樣  取樣  取樣  取樣  取樣  取樣
              (在上升沿讀取資料)

MOSI: ────┬────┬────┬────┬────┬────┬────┬────┬────
          │ D7 │ D6 │ D5 │ D4 │ D3 │ D2 │ D1 │ D0 │
          (MSB First: 最高位元先傳)
```

**Mode 3（CPOL=1, CPHA=1）- 也常見**
```
CS:   ────┐                                         ┌────
          └─────────────────────────────────────────┘

SCK:  ────┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──┐  ┌──
     (高) └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──┘  └──
              ↑    ↑    ↑    ↑    ↑    ↑    ↑    ↑
              取樣  取樣  取樣  取樣  取樣  取樣  取樣  取樣
              (在上升沿讀取資料，但閒置時是高電位)
```

**⚠️ 重要提醒：Mode 不對會怎樣？**
```
如果 Master 和 Slave 的 Mode 設定不一樣：
→ 資料會讀錯！因為取樣的時機對不上
→ 常見症狀：讀到的資料全是 0xFF 或亂碼

💡 面試常問：查 Datasheet 確認裝置使用哪個 SPI Mode！
```

---

### 多 Slave 連接（詳細說明）

#### 方式一：獨立 CS（最常見）

每個 Slave 都有自己專屬的 CS 線，像是每人一個開關。

```
           MCU
        ┌───────┐
        │   CS0 ├──┐                    只有被選中的 Slave
        │   CS1 ├──┼──────────────┐     會回應（CS = 低）
        │   CS2 ├──┼──────────────┼────────────────┐
        │       │  │              │                │
        │  MOSI ├──┼──────────────┼──────┬─────────┼── (並聯)
        │  MISO ├──┼──────────────┼──────┼─────────┼── (並聯)  
        │   SCK ├──┼──────────────┼──────┼─────────┼── (並聯)
        └───────┘  │              │      │         │
                   ▼              ▼      ▼         │
              ┌────────┐    ┌────────┐   │    ┌────────┐
              │Slave 0 │    │Slave 1 │   │    │Slave 2 │
              │CS=LOW  │    │CS=HIGH │   │    │CS=HIGH │
              │(被選中)│    │(忽略)  │   │    │(忽略)  │
              └────────┘    └────────┘   │    └────────┘
                                         │
    同一時間只有一個 Slave 的 CS 是低電位 ──┘
```

**優點：**
- 簡單直觀
- 每個 Slave 獨立控制

**缺點：**
- 每多一個 Slave 就多佔用 MCU 一個 GPIO

---

#### 方式二：Daisy Chain（菊花鍊）

資料像接力賽一樣，一個傳一個。

```
                    資料流向
    MCU MOSI ──→ Slave0 ──→ Slave1 ──→ Slave2
                   ↓          ↓          ↓
                 (處理)     (處理)     (處理)
                   ↓          ↓          ↓
    MCU MISO ←── Slave0 ←── Slave1 ←── Slave2

    CS 只需要一條，同時選中所有 Slave！
```

**原理解釋：**
```
假設要寫 3 個 byte 給 3 個 Slave：

時間 T1: Master 送 Byte_A
         Slave0 收到 Byte_A
         
時間 T2: Master 送 Byte_B
         Slave0 把 Byte_A 往後傳給 Slave1
         Slave0 收到 Byte_B
         
時間 T3: Master 送 Byte_C
         Slave1 把 Byte_A 往後傳給 Slave2
         Slave0 把 Byte_B 往後傳給 Slave1
         Slave0 收到 Byte_C

最終結果：
Slave0: Byte_C
Slave1: Byte_B  
Slave2: Byte_A
```

**優點：**
- 只需要一條 CS 線（省 GPIO！）
- 很多 LED 驅動 IC 使用這種方式（例如 WS2812B LED Strip 類似概念）

**缺點：**
- 延遲較大（資料要經過前面的 Slave）
- 如果中間一個壞了，後面全斷

### 常見面試問題

**Q1：SPI 和 I2C 的主要差異？**
```
1. 速度：SPI 更快（可達數十 MHz）
2. 線數：SPI 需要更多線（每加一個 Slave 多一條 CS）
3. 全雙工：SPI 可同時收發，I2C 不行
4. 定址：I2C 用地址，SPI 用 CS 線
5. 距離：SPI 只適合短距離（同一 PCB 上）
```


**Q2：CPOL 和 CPHA 是什麼？**
```
CPOL (Clock Polarity)：時脈閒置時的電位
- CPOL=0：閒置時 SCK 為低
- CPOL=1：閒置時 SCK 為高

CPHA (Clock Phase)：資料取樣的時機
- CPHA=0：在第一個邊沿取樣（上升或下降沿，取決於 CPOL）
- CPHA=1：在第二個邊沿取樣
```

**Q3：「讀寫 SPI Flash」是什麼意思？和一般讀寫檔案一樣嗎？**

這是初學者容易搞混的概念！

```
┌──────────────────────────────────────────────────────────────────┐
│  一般「讀寫檔案」（高階操作）                                       │
│  ─────────────────────────                                       │
│  fopen("test.txt", "r")  →  作業系統幫你處理一切                   │
│                              （檔案系統、硬碟驅動...）              │
│                                                                  │
│  像是叫別人幫你存東西到倉庫，你不用管倉庫內部怎麼擺                   │
└──────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────┐
│ 「讀寫 SPI Flash」（底層操作）                                     │
│  ────────────────────────                                        │
│  直接用 SPI 發送命令給 Flash 晶片：                                │
│  - 發送 0x03 + 地址 → 讀取資料                                    │
│  - 發送 0x02 + 地址 + 資料 → 寫入資料                              │
│  - 發送 0x20 + 地址 → 擦除 Sector                                 │
│                                                                  │
│  像是你親自去倉庫的特定格子放東西，要自己處理所有細節                  │
└──────────────────────────────────────────────────────────────────┘
```

**SPI Flash 常見用途：**
```
┌─────────────────┬────────────────────────────────────────────────┐
│      用途       │                    說明                        │
├─────────────────┼────────────────────────────────────────────────┤
│ 1. 存 Firmware  │ 系統開機時從 SPI Flash 讀取韌體來執行           │
│    (最常見！)   │ 例如：BIOS/UEFI、U-Boot、BMC 韌體               │
├─────────────────┼────────────────────────────────────────────────┤
│ 2. 存 設定資料  │ NVRAM 區域，存裝置設定（斷電不消失）             │
│                 │ 例如：MAC 地址、序號、校準參數                   │
├─────────────────┼────────────────────────────────────────────────┤
│ 3. 存 Log/資料  │ 比較少見，但有些嵌入式系統會這樣用               │
│                 │ 例如：事件 log、感測器歷史資料                   │
└─────────────────┴────────────────────────────────────────────────┘

💡 在 BMC 工作中，「讀寫 SPI Flash」通常指：
   ✅ 更新 BMC 韌體（Flash Firmware）
   ✅ 更新 BIOS/ME 韌體
   ✅ 備份現有韌體
   ✅ 讀寫 FRU/設定資料區域
```

**⚠️ Flash 寫入的特殊限制（重要！）：**
```
一般硬碟/RAM：想寫什麼就寫什麼
    地址 0x100 原本是 0xAB → 直接寫成 0xCD ✓

Flash：只能從 1 變 0，不能從 0 變 1！
    原本是 0xFF → 寫成 0xAB ✓（1→0 可以）
    原本是 0xAB → 寫成 0x00 ✓（1→0 可以）
    原本是 0xAB → 寫成 0xFF ✗（0→1 不行！無法改回去！）
    
解決方法：先「擦除」(Erase)，把整個 Sector 變回 0xFF，再寫入

完整寫入流程：
    1. 讀取整個 Sector 到 RAM（備份）
    2. 在 RAM 中修改要改的部分
    3. 擦除整個 Sector（變成全 0xFF）
    4. 把修改後的資料寫回去

這也是為什麼 Flash 壽命有限（擦寫次數限制，通常 10 萬次）
```

---


## 🔷 UART 協定詳解

### 💡 什麼是 UART？為什麼需要它？

**UART (Universal Asynchronous Receiver-Transmitter)** = 通用非同步收發傳輸器

**最大特色：不需要時脈線！**

想像兩個人用燈號通訊：
- **I2C/SPI** 像是有人在旁邊打鼓給節奏：「咚！」看一下，「咚！」再看一下
- **UART** 像是沒人打鼓，雙方事先約定：「我們每秒閃 10 次」，然後各自計時

**UART 的特點：**
```
✅ 簡單！只需要 2 條線（TX + RX）
✅ 不需要時脈線（非同步）
✅ 全雙工：可以同時收發
✅ 歷史悠久，幾乎所有 MCU 都支援
❌ 速度較慢（通常 115200 bps）
❌ 只能點對點（一對一通訊）
❌ 距離有限（除非轉成 RS-232/RS-485）
```

**常見使用場景：**
- Debug console（printf 輸出訊息）
- GPS 模組通訊
- 藍牙模組（HC-05）
- WiFi 模組（ESP8266 AT 指令）
- 與 PC 通訊（透過 USB-to-UART 轉接器）

---

### 硬體連接

```
       MCU                          另一裝置
    ┌───────┐                     ┌───────┐
    │    TX ├─────────────────────┤ RX    │
    │    RX ├─────────────────────┤ TX    │
    │   GND ├─────────────────────┤ GND   │
    └───────┘                     └───────┘
    （注意：TX 接 RX，交叉連接）
```

#### 🔌 為什麼要「交叉連接」？

```
TX = Transmit = 發送（我的嘴巴）
RX = Receive  = 接收（我的耳朵）

想像兩個人打電話：
┌──────────┐                    ┌──────────┐
│  我的嘴  │ ───── 說話 ─────→ │  你的耳  │
│  (TX)    │                    │   (RX)   │
├──────────┤                    ├──────────┤
│  我的耳  │ ←──── 聽話 ────── │  你的嘴  │
│  (RX)    │                    │   (TX)   │
└──────────┘                    └──────────┘

所以：我的 TX 接你的 RX，我的 RX 接你的 TX！
```

#### ⚠️ 常見錯誤

```
錯誤：TX 接 TX，RX 接 RX
結果：兩個人都在講話沒人聽 / 兩個人都在聽沒人講

正確：TX 接 RX（交叉連接）
```

---

### 基本概念（詳細解釋）

#### 🔄 什麼是「非同步」(Asynchronous)？

```
同步通訊（I2C、SPI）：
┌────────────┐     有時脈線     ┌────────────┐
│   Master   │ ────────────────→│    Slave   │
│            │    「看這裡！」   │            │
│   發送方   │ ═══════════════> │   接收方   │
└────────────┘     資料線       └────────────┘
時脈線告訴你「什麼時候該看資料」

非同步通訊（UART）：
┌────────────┐     沒有時脈線    ┌────────────┐
│   發送方   │ ═══════════════> │   接收方   │
└────────────┘                  └────────────┘
雙方事先約定好速度（Baud Rate），各自計時！
```

#### ⏱️ Baud Rate 是什麼？

**Baud Rate = 每秒傳輸幾個 bit**

```
常見的 Baud Rate：
┌───────────┬──────────────────────────────────────┐
│ Baud Rate │           每個 bit 的時間            │
├───────────┼──────────────────────────────────────┤
│    9600   │  1/9600 = 104.17 μs (微秒)           │
│   115200  │  1/115200 = 8.68 μs                  │
│  1000000  │  1/1000000 = 1 μs                    │
└───────────┴──────────────────────────────────────┘

白話解釋：
- 9600 bps = 每秒傳 9600 個 0 或 1
- 115200 bps = 每秒傳 115200 個 0 或 1（比 9600 快 12 倍！）
```

#### ⚠️ Baud Rate 不一致會怎樣？

```
假設：發送方 115200，接收方 9600

發送方想傳：01010101（每個 bit 約 8.68 μs）

                  8.68μs
    發送方：┌─┐ ┌─┐ ┌─┐ ┌─┐
            │0│1│0│1│0│1│0│1│
            └─┘ └─┘ └─┘ └─┘
    
    接收方以為：（每個 bit 約 104 μs）
               ────────────────────────
               │         0            │ ← 只看到第一個 bit 拉很長
               ────────────────────────

結果：資料全錯！收到的是亂碼！

💡 所以雙方 Baud Rate 必須完全一致！
```

---

### UART Frame 格式（詳細圖解）

一次傳輸一個「Frame」（框架），包含起始、資料、校驗、結束。

```
閒置狀態（高電位）
    ─────────────────────────────────────────────
                 ↓ 開始傳輸
    ┌───┬──┬──┬──┬──┬──┬──┬──┬──┬───────┬──────┐
    │ S │D0│D1│D2│D3│D4│D5│D6│D7│Parity │ Stop │
    └───┴──┴──┴──┴──┴──┴──┴──┴──┴───────┴──────┘
    │   │                      │       │      │
    │   └──────────────────────┘       │      │
    │         資料位元 (8 bits)         │      │
    │                                  │      │
    └── Start bit (1 bit, 固定 = 0)    │      │
                                       │      │
        Parity bit (0 或 1 bit, 可選) ──┘      │
                                              │
        Stop bit (1 或 2 bits, 固定 = 1) ──────┘
```

#### 📊 各部分功能說明

```
┌──────────────┬────────┬──────────────────────────────────────┐
│     名稱     │ 位元數 │              功能說明                 │
├──────────────┼────────┼──────────────────────────────────────┤
│  Start bit   │   1    │ 固定是 0（低電位）                   │
│              │        │ 告訴接收方：「資料要來了！」          │
├──────────────┼────────┼──────────────────────────────────────┤
│  Data bits   │  5-9   │ 實際的資料內容                        │
│              │        │ 常見是 8 bits（1 個 byte）           │
│              │        │ 注意：LSB First（最低位元先傳）       │
├──────────────┼────────┼──────────────────────────────────────┤
│  Parity bit  │  0-1   │ 可選的錯誤檢查                        │
│              │        │ N = None（不用）                      │
│              │        │ E = Even（偶校驗）                    │
│              │        │ O = Odd（奇校驗）                     │
├──────────────┼────────┼──────────────────────────────────────┤
│  Stop bit    │  1-2   │ 固定是 1（高電位）                   │
│              │        │ 告訴接收方：「這次資料結束了」        │
└──────────────┴────────┴──────────────────────────────────────┘
```

#### 🖼️ 傳送 0x55 ('U') 的時序圖

```
假設設定：115200 8N1
傳送資料：0x55 = 0b01010101

電壓
 高 ─────┐   ┌───┐   ┌───┐   ┌───┐   ┌───┬─────────
         │   │   │   │   │   │   │   │   │
 低      └───┘   └───┘   └───┘   └───┘   │
         │   │   │   │   │   │   │   │   │
         S  D0  D1  D2  D3  D4  D5  D6  D7  Stop
         │   │   │   │   │   │   │   │   │
         0   1   0   1   0   1   0   1   0    1
         ↑                                    ↑
      Start                                 Stop
      
時間：每個 bit 約 8.68 μs（115200 bps）
總時間：10 bits × 8.68 μs ≈ 86.8 μs 傳完一個 byte

注意：資料是 LSB First！
0x55 = 01010101，但傳輸順序是 D0→D7 = 1,0,1,0,1,0,1,0
```

---

### 常見設定（如何解讀）

當看到 **"115200 8N1"** 這種格式，代表：

```
┌─────────┬─────────┬─────────┬─────────┐
│ 115200  │    8    │    N    │    1    │
├─────────┼─────────┼─────────┼─────────┤
│Baud Rate│Data bits│ Parity  │Stop bits│
│ 波特率  │ 資料位元 │ 校驗位元 │ 停止位元│
└─────────┴─────────┴─────────┴─────────┘

完整解讀：
- 115200：每秒傳 115200 個 bit
- 8：每個 frame 有 8 個 data bits
- N：No parity（不使用校驗位元）
- 1：1 個 stop bit
```

#### 📋 常見設定組合

```
┌──────────────┬────────────────────────────────────────┐
│    設定      │               適用場景                  │
├──────────────┼────────────────────────────────────────┤
│  9600 8N1    │ 傳統設備、GPS 模組、藍牙模組預設       │
├──────────────┼────────────────────────────────────────┤
│ 115200 8N1   │ Debug console（最常用！）             │
├──────────────┼────────────────────────────────────────┤
│ 115200 8E1   │ 工業通訊（需要錯誤檢查）               │
├──────────────┼────────────────────────────────────────┤
│ 1000000 8N1  │ 高速傳輸（1 Mbps）                    │
└──────────────┴────────────────────────────────────────┘
```

---

### 常見面試問題

**Q1：UART 沒有時脈線，如何同步？**
```
1. 收發雙方預先設定相同的 Baud Rate
2. 接收端偵測 Start bit（從高變低）
3. 根據 Baud Rate 計算每個 bit 的時間
4. 在每個 bit 的中間取樣

視覺化說明：
               
    ─────┐         取樣點（在 bit 中間）
         │    ↓    ↓    ↓    ↓
         └────┼────┼────┼────┼────
         │    │    │    │    │
        Start D0   D1   D2   D3 ...

為什麼在「中間」取樣？
→ 避免在邊緣取樣，那裡電壓還在變化，不穩定

所以 Baud Rate 必須完全一致！如果差太多會讀錯資料。
```

**Q2：什麼是 Parity Check？**
```
用來檢測資料傳輸是否有錯誤。

原理：數一數資料有幾個「1」

- Even Parity（偶校驗）：確保「1 的總數」是偶數
- Odd Parity（奇校驗）：確保「1 的總數」是奇數

範例：資料 0x55 = 0b01010101（有 4 個 1）
┌────────────┬─────────────┬───────────────────────┐
│   類型     │ Parity bit  │         原因          │
├────────────┼─────────────┼───────────────────────┤
│Even Parity │      0      │ 4 + 0 = 4（偶數 ✓）   │
│Odd Parity  │      1      │ 4 + 1 = 5（奇數 ✓）   │
└────────────┴─────────────┴───────────────────────┘

⚠️ 重要限制：
- 只能檢測「單一 bit」錯誤
- 無法檢測「兩個 bit」同時錯誤（因為偶數個錯誤會互相抵消）
- 無法「糾正」錯誤，只能「發現」錯誤
```

**Q3：什麼是 Flow Control（流量控制）？**
```
問題：如果發送方太快，接收方來不及處理怎麼辦？

解決方案：Flow Control（流量控制）

方式一：Hardware Flow Control（硬體流控）
────────────────────────────────────────
額外需要 2 條線：RTS（要送了）、CTS（可以收）

    發送方                    接收方
    ┌─────┐                  ┌─────┐
    │ RTS ├─────────────────→│ CTS │
    │ CTS │←─────────────────┤ RTS │
    └─────┘                  └─────┘

流程：
1. 發送方拉低 RTS：「我想送資料」
2. 接收方拉低 CTS：「我準備好了，送吧」
3. 開始傳輸
4. 接收方 buffer 快滿了，拉高 CTS：「等一下！」
5. 發送方暫停傳輸

方式二：Software Flow Control（軟體流控）
────────────────────────────────────────
用特殊字元來控制：
- XON  (0x11)：繼續傳
- XOFF (0x13)：暫停傳

不需要額外接線，但資料中不能出現這兩個字元！
```

---

## ✅ 總結：面試時如何回答「請說明 I2C/SPI/UART」

### 📝 回答架構

```
1. 先說全名和基本概念
2. 說明硬體連接（幾條線、各自功能）
3. 說明通訊流程（起始/結束條件、傳輸方式）
4. 提到常見問題或注意事項
5. 最好能舉自己用過的經驗
```

---

### 🎤 I2C 標準回答範例

```
「I2C 全名是 Inter-Integrated Circuit，是一種兩線式的串列通訊協定，
由 Philips 發明。

硬體上使用 SDA 資料線和 SCL 時脈線，採用 Open-Drain 輸出，
所以需要外部上拉電阻，通常用 4.7kΩ。

通訊時 Master 先發 Start Condition（SCL 高時 SDA 下降），
接著送 7-bit 地址加 R/W bit，Slave 回應 ACK 後開始傳輸資料，
每 8 bits 後接收方回應一次 ACK。
傳輸完成發送 Stop Condition（SCL 高時 SDA 上升）。

常見速度有 Standard Mode 100kHz、Fast Mode 400kHz。
要注意的是如果 Bus 卡住，可以用 9 個 Clock Pulse 來恢復。

在我之前的工作中，我用 I2C 讀取 BME280 溫溼度 Sensor 
和 AT24C256 EEPROM 的資料...」
```

---

### 🎤 SPI 標準回答範例

```
「SPI 全名是 Serial Peripheral Interface，是一種四線式的同步串列通訊協定。

硬體上使用：
- MOSI（Master Out Slave In）：Master 發送資料
- MISO（Master In Slave Out）：Slave 回傳資料
- SCK（Serial Clock）：時脈，由 Master 產生
- CS（Chip Select）：選擇要通訊的 Slave，低電位有效

特點是全雙工，可以同時收發，速度很快，可達數十 MHz。
有四種模式，由 CPOL 和 CPHA 決定，要根據 Slave 的 Datasheet 設定正確的模式。

缺點是每多一個 Slave 就要多一條 CS 線，佔用較多 GPIO。

在我之前的工作中，我用 SPI 讀寫 SPI Flash 的韌體資料，
它需要高速傳輸才能快速更新韌體...」
```

---

### 🎤 UART 標準回答範例

```
「UART 全名是 Universal Asynchronous Receiver-Transmitter，
是一種非同步的串列通訊協定。

硬體上只需要 TX（發送）和 RX（接收）兩條線，要交叉連接。
因為沒有時脈線，所以雙方必須預先設定相同的 Baud Rate，
常見設定是 115200 8N1，表示 115200 bps、8 個 data bits、
無 parity、1 個 stop bit。

傳輸時以 Frame 為單位，包含 Start bit、Data bits、
可選的 Parity bit、以及 Stop bit。
接收端偵測 Start bit（從高變低）後，根據 Baud Rate 
在每個 bit 的中間取樣。

在我之前的工作中，我用 UART 作為 Debug Console 輸出 Log，
也用來和 GPS 模組、藍牙模組通訊...」
```

---

## 🎯 何時選用 I2C / SPI / UART？（場景決策指南）

很多人看完三種協定的說明還是搞不清楚何時該用哪個，
這裡用**實際場景**和**決策流程**來幫你理解！

### 📊 快速決策表

```
┌────────────────────────────────────────────────────────────────────────┐
│                           你的需求是什麼？                              │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│   需要 Debug 輸出 / 和 PC 通訊？           ────→  用 UART              │
│                                                                        │
│   需要接很多 Sensor，想省線？              ────→  用 I2C               │
│                                                                        │
│   需要高速傳輸（Flash、顯示器）？          ────→  用 SPI               │
│                                                                        │
│   GPIO 很少，只能再拉 2 條線？             ────→  用 I2C               │
│                                                                        │
│   需要同時讀寫（全雙工）？                 ────→  用 SPI 或 UART        │
│                                                                        │
│   裝置只支援某種協定？                     ────→  沒得選，照裝置規格！   │
│                                                                        │
└────────────────────────────────────────────────────────────────────────┘
```

---

### 🎬 場景一：讀取溫度 Sensor（BME280）→ 選 I2C

**為什麼不選其他的？**
```
✅ 選 I2C 的原因：
   - 溫度 Sensor 資料量小（幾個 byte），不需要高速
   - 只用 2 條線就能接，省 GPIO
   - 可以同時接很多其他 Sensor（用不同地址區分）
   - BME280 本身就支援 I2C

❌ 不選 SPI 的原因：
   - 雖然 BME280 也支援 SPI，但會多佔一條 CS 線
   - 沒有速度需求，用 SPI 是「殺雞用牛刀」

❌ 不選 UART 的原因：
   - BME280 不支援 UART
   - UART 是點對點，不適合接多個 Sensor
```

---

### 🎬 場景二：讀寫 SPI Flash（存韌體）→ 選 SPI

**為什麼不選其他的？**
```
✅ 選 SPI 的原因：
   - Flash 讀寫需要高速（例如更新 8MB 韌體）
   - SPI 可達 50MHz+，I2C 最快才 1MHz
   - 全雙工可以同時送 Command 和收 Data
   - SPI Flash 本身就是 SPI 介面

❌ 不選 I2C 的原因：
   - 太慢了！讀 8MB 要等很久
   - Flash 操作通常需要連續大量資料傳輸

❌ 不選 UART 的原因：
   - Flash 不支援 UART
   - UART 更慢（通常 115200 bps = 14KB/s）
   
💡 實際速度比較：
   - UART 115200 bps: 讀 1MB 約需 73 秒
   - I2C 400kHz:      讀 1MB 約需 20 秒
   - SPI 10MHz:       讀 1MB 約需 0.8 秒
```

---

### 🎬 場景三：Debug 輸出 Log → 選 UART

**為什麼不選其他的？**
```
✅ 選 UART 的原因：
   - printf 輸出是「發出去就好」，不需要對方回應
   - UART 設定簡單，只要 Baud Rate 對就能用
   - 可以直接接 USB-to-UART 轉接器連到 PC
   - 大部分 MCU 的 printf 預設就是輸出到 UART

❌ 不選 I2C 的原因：
   - I2C 是 Master-Slave 架構，PC 不適合當 Slave
   - Debug Log 不需要地址定址

❌ 不選 SPI 的原因：
   - SPI 連 PC 很麻煩，沒有標準的 USB-to-SPI 轉接器
   - Debug 不需要高速
```

---

### 🎬 場景四：接 GPS 模組 → 選 UART

**為什麼不選其他的？**
```
✅ 選 UART 的原因：
   - GPS 模組會「主動」輸出位置資料，不是你問它才回答
   - GPS 資料格式是 NMEA 字串，本來就是設計給 UART
   - GPS 模組通常預設就是 UART 介面（9600 bps）

❌ 不選 I2C 的原因：
   - GPS 不是你問它才回答，它會一直吐資料
   - I2C 是 Master 主導，不適合這種「Slave 主動輸出」的場景

❌ 不選 SPI 的原因：
   - 大部分 GPS 模組不支援 SPI
```

---

### 🎬 場景五：接 OLED 顯示器（SSD1306）→ 可選 I2C 或 SPI

**這個場景兩種都可以！**
```
情況 A：GPIO 有限 → 選 I2C
   - SSD1306 通常支援 I2C 和 SPI 兩種
   - I2C 只要 2 條線
   - 小畫面刷新率要求不高

情況 B：需要高刷新率 → 選 SPI
   - SPI 速度快，畫面更新更流暢
   - 適合需要快速動畫的應用

💡 實際考量：
   大部分 Arduino 玩家會選 I2C 版本（接線少）
   需要專業顯示效果的會選 SPI 版本（速度快）
```

---

### 🎬 場景六：同一個 MCU 接多個不同裝置

```
典型的嵌入式系統可能同時需要：
┌─────────────────────────────────────────────────────────────┐
│                         MCU                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   I2C Bus ─────┬──── 溫度 Sensor (BME280)                  │
│                ├──── EEPROM (AT24C256)                      │
│                ├──── RTC 時鐘 (DS3231)                      │
│                └──── 加速度計 (MPU6050)                     │
│                                                             │
│   SPI Bus ─────┬──── SPI Flash (W25Q64)                    │
│                └──── 大型 LCD 顯示器                        │
│                                                             │
│   UART ────────┬──── Debug Console (printf)                 │
│                └──── GPS 模組                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

設計原則：
1. 低速、多裝置 → I2C（省線）
2. 高速、大資料 → SPI（快）
3. Debug / 外部設備通訊 → UART（簡單）
```

---

### 🔀 決策流程圖

```
                    開始
                      │
                      ▼
            ┌─────────────────┐
            │  裝置支援哪種   │
            │  通訊協定？     │
            └────────┬────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
        ▼            ▼            ▼
    只支援一種    支援多種      不確定
        │            │            │
        │            ▼            ▼
        │     ┌─────────────┐   查 Datasheet！
        │     │ 需要高速？  │
        │     └──────┬──────┘
        │            │
        │      ┌─────┴─────┐
        │      │           │
        │      ▼           ▼
        │     是          否
        │      │           │
        │      ▼           ▼
        │   用 SPI    ┌────────────┐
        │             │ GPIO 緊張？│
        │             └─────┬──────┘
        │                   │
        │             ┌─────┴─────┐
        │             │           │
        │             ▼           ▼
        │            是          否
        │             │           │
        │             ▼           ▼
        └────────→ 用 I2C      都可以
                              （選簡單的）
```

---

### ⚡ 面試加分回答：「如何選擇通訊協定？」

```
「選擇通訊協定時，我會考慮以下幾點：

1. 裝置支援度：先確認裝置支援哪些協定，有時沒得選

2. 速度需求：
   - 高速（Flash、顯示器）→ 選 SPI
   - 中速（Sensor、EEPROM）→ 選 I2C
   - 低速（Debug、GPS）→ 選 UART

3. 資源限制：
   - GPIO 不夠 → 選 I2C（只要 2 條線）
   - 需要接很多裝置 → 選 I2C（共用 Bus）

4. 通訊模式：
   - 需要同時收發 → 選 SPI 或 UART（全雙工）
   - Slave 主動輸出 → 選 UART

5. 實際經驗：
   我在 OpenBMC 專案中，I2C 用來讀取各種 Sensor，
   SPI 用來讀寫 SPI Flash 韌體，
   UART 用來輸出 Debug Log...」
```
