# ğŸ”” ä¸­æ–·è™•ç†ï¼ˆInterruptï¼‰å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£ä¸­æ–·çš„åŸºæœ¬åŸç†èˆ‡è™•ç†æµç¨‹
> 2. ç²¾é€š Linux Kernel çš„ Top-half / Bottom-half æ©Ÿåˆ¶
> 3. ç†Ÿç·´ä½¿ç”¨ Softirqã€Taskletã€Workqueueã€Threaded IRQ
> 4. ç†è§£ GIC æ¶æ§‹ï¼ˆGICv2/v3ï¼‰èˆ‡ä¸­æ–·æ§åˆ¶å™¨å±¤æ¬¡
> 5. æŒæ¡ IRQ API èˆ‡ä¸­æ–·è¦ªå’Œæ€§è¨­å®š

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šä¸­æ–·åŸºç¤

### 1.1 ä»€éº¼æ˜¯ä¸­æ–·ï¼Ÿ

```
ä¸­æ–·æ˜¯ä¸€ç¨®æ©Ÿåˆ¶ï¼Œè®“ç¡¬é«”å¯ä»¥ã€Œæ‰“æ–·ã€CPU æ­£åœ¨åŸ·è¡Œçš„ç¨‹å¼ï¼Œ
å»è™•ç†æ›´ç·Šæ€¥çš„äº‹ä»¶ï¼Œè™•ç†å®Œå¾Œå†å›åˆ°åŸç¨‹å¼ç¹¼çºŒåŸ·è¡Œã€‚

é¡æ¯”ï¼šä½ æ­£åœ¨å¯«ç¨‹å¼ï¼ˆä¸»ç¨‹å¼ï¼‰ï¼Œé›»è©±éŸ¿äº†ï¼ˆä¸­æ–·ç™¼ç”Ÿï¼‰ï¼Œ
æ¥èµ·é›»è©±è™•ç†ï¼ˆISRï¼‰ï¼Œæ›æ‰å¾Œå›ä¾†ç¹¼çºŒå¯«ç¨‹å¼ï¼ˆè¿”å›ï¼‰ã€‚

ç‚ºä»€éº¼éœ€è¦ä¸­æ–·ï¼Ÿ
- è¼ªè©¢ (Polling) æµªè²» CPU æ™‚é–“
- å³æ™‚éŸ¿æ‡‰å¤–éƒ¨äº‹ä»¶
- æé«˜ç³»çµ±æ•ˆç‡
```

### 1.2 ä¸­æ–·é¡å‹

| é¡å‹ | ä¾†æº | è§¸ç™¼æ–¹å¼ | ç¯„ä¾‹ |
|:---|:---|:---|:---|
| ç¡¬é«”ä¸­æ–· | å¤–éƒ¨ç¡¬é«”äº‹ä»¶ | é›»å¹³/é‚Šç·£ | GPIOã€Timerã€UART |
| è»Ÿé«”ä¸­æ–· | ç¨‹å¼æŒ‡ä»¤è§¸ç™¼ | æŒ‡ä»¤ | ç³»çµ±å‘¼å«ã€SVC |
| ä¾‹å¤– (Exception) | CPU åŸ·è¡Œç•°å¸¸ | åŒæ­¥ | é™¤ä»¥é›¶ã€Page Fault |
| NMI | ä¸å¯é®ç½©ä¸­æ–· | é›»å¹³ | ç¡¬é«”æ•…éšœã€çœ‹é–€ç‹— |

### 1.3 é‚Šç·£è§¸ç™¼ vs é›»å¹³è§¸ç™¼

```c
/* é‚Šç·£è§¸ç™¼ (Edge-triggered) */
IRQF_TRIGGER_RISING   /* ä¸Šå‡ç·£ï¼š0 â†’ 1 æ™‚è§¸ç™¼ */
IRQF_TRIGGER_FALLING  /* ä¸‹é™ç·£ï¼š1 â†’ 0 æ™‚è§¸ç™¼ */
/* ç‰¹é»ï¼šåªåœ¨è½‰æ›ç¬é–“è§¸ç™¼ä¸€æ¬¡ï¼Œå¯èƒ½æ¼å¤±ä¸­æ–· */

/* é›»å¹³è§¸ç™¼ (Level-triggered) */
IRQF_TRIGGER_HIGH     /* é«˜é›»å¹³ï¼šä¿æŒ 1 æ™‚æŒçºŒè§¸ç™¼ */
IRQF_TRIGGER_LOW      /* ä½é›»å¹³ï¼šä¿æŒ 0 æ™‚æŒçºŒè§¸ç™¼ */
/* ç‰¹é»ï¼šé›»å¹³ç¶­æŒå°±æŒçºŒè§¸ç™¼ï¼Œå¿…é ˆåœ¨ ISR ä¸­æ¸…é™¤ä¾†æº */

/* é¸æ“‡åŸå‰‡ï¼š
 * - GPIO æŒ‰éˆ•ï¼šé‚Šç·£è§¸ç™¼ï¼ˆé¿å…é‡è¤‡ï¼‰
 * - å…±äº« IRQï¼šé€šå¸¸é›»å¹³è§¸ç™¼
 * - PCIe MSIï¼šé‚Šç·£è§¸ç™¼
 */
```

### 1.4 ä¸­æ–·è™•ç†æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ä¸­æ–·è™•ç†å®Œæ•´æµç¨‹                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  1. ä¸­æ–·ç™¼ç”Ÿï¼ˆç¡¬é«”å‘ Interrupt Controller ç™¼é€ä¿¡è™Ÿï¼‰              â”‚
â”‚     â†“                                                            â”‚
â”‚  2. Interrupt Controller (GIC) è­˜åˆ¥ä¸­æ–·æº                        â”‚
â”‚     â†“                                                            â”‚
â”‚  3. GIC å‘ CPU ç™¼å‡º IRQ/FIQ ä¿¡è™Ÿ                                 â”‚
â”‚     â†“                                                            â”‚
â”‚  4. CPU å®Œæˆç•¶å‰æŒ‡ä»¤                                             â”‚
â”‚     â†“                                                            â”‚
â”‚  5. CPU è‡ªå‹•ä¿å­˜éƒ¨åˆ† Context (PC, PSTATE)                        â”‚
â”‚     â†“                                                            â”‚
â”‚  6. åˆ‡æ›åˆ° Exception Level (EL1)                                 â”‚
â”‚     â†“                                                            â”‚
â”‚  7. è·³è½‰åˆ°ä¸­æ–·å‘é‡è¡¨å°æ‡‰ä½ç½®                                      â”‚
â”‚     â†“                                                            â”‚
â”‚  8. Kernel entry code ä¿å­˜å®Œæ•´ Context                           â”‚
â”‚     â†“                                                            â”‚
â”‚  9. å‘¼å« handle_arch_irq() â†’ GIC driver â†’ __do_IRQ()            â”‚
â”‚     â†“                                                            â”‚
â”‚ 10. å‘¼å« handler (Top-half) â†’ æ’ç¨‹ Bottom-half                   â”‚
â”‚     â†“                                                            â”‚
â”‚ 11. EOI (End of Interrupt) é€šçŸ¥ GIC                              â”‚
â”‚     â†“                                                            â”‚
â”‚ 12. æ¢å¾© Context                                                 â”‚
â”‚     â†“                                                            â”‚
â”‚ 13. è¿”å›è¢«ä¸­æ–·çš„ç¨‹å¼                                             â”‚
â”‚     â†“                                                            â”‚
â”‚ 14. (ç¨å¾Œ) åŸ·è¡Œ Bottom-half                                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.5 ARM ä¸­æ–·å‘é‡è¡¨ (ARMv8)

```c
/* ARM64 çš„å‘é‡è¡¨çµæ§‹ */
/*
 * Exception Entry Table (æ¯å€‹ entry 128 bytes)
 *
 * Offset        Exception           åŸ·è¡Œç‹€æ…‹
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 0x000        Synchronous          EL1t (SP_EL0)
 * 0x080        IRQ/vIRQ            
 * 0x100        FIQ/vFIQ            
 * 0x180        SError/vSError      
 * 
 * 0x200        Synchronous          EL1h (SP_EL1) â† æœ€å¸¸ç”¨
 * 0x280        IRQ/vIRQ            
 * 0x300        FIQ/vFIQ            
 * 0x380        SError/vSError      
 *
 * 0x400        Sync from EL0 (64-bit)
 * 0x480        IRQ from EL0 (64-bit)
 * ...
 */

/* Linux çš„å‘é‡è¡¨å®šç¾©ï¼šarch/arm64/kernel/entry.S */
SYM_CODE_START(vectors)
    kernel_ventry   1, t, 64, sync     /* EL1t synchronous */
    kernel_ventry   1, t, 64, irq      /* EL1t IRQ */
    kernel_ventry   1, t, 64, fiq
    kernel_ventry   1, t, 64, error
    
    kernel_ventry   1, h, 64, sync     /* EL1h synchronous */
    kernel_ventry   1, h, 64, irq      /* â† ä¸­æ–·é€²å…¥é» */
    kernel_ventry   1, h, 64, fiq
    kernel_ventry   1, h, 64, error
    /* ... */
SYM_CODE_END(vectors)
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šLinux Kernel ä¸­æ–·æ©Ÿåˆ¶

### 2.1 Top-half vs Bottom-half æ·±å…¥è§£æ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Top-half (ç¡¬ä¸­æ–· / Hardirq)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸ·è¡Œç’°å¢ƒï¼š                                                       â”‚
â”‚    - Interrupt Context                                           â”‚
â”‚    - ç¦ç”¨ç•¶å‰ IRQï¼ˆå¯èƒ½ç¦ç”¨æ‰€æœ‰ä¸­æ–·ï¼‰                             â”‚
â”‚    - ä¸å¯æ¶å                                                      â”‚
â”‚                                                                  â”‚
â”‚  é™åˆ¶ï¼š                                                           â”‚
â”‚    - âŒ ä¸èƒ½ç¡çœ ï¼ˆsleep, scheduleï¼‰                               â”‚
â”‚    - âŒ ä¸èƒ½ä½¿ç”¨ mutex                                            â”‚
â”‚    - âŒ ä¸èƒ½å‘¼å«å¯èƒ½ block çš„å‡½å¼                                 â”‚
â”‚    - âŒ ä¸èƒ½åšå¤§é‡è¨˜æ†¶é«”åˆ†é…ï¼ˆåªèƒ½ GFP_ATOMICï¼‰                    â”‚
â”‚    - âœ… å¯ä»¥ä½¿ç”¨ spinlockï¼ˆä½†è¦å°å¿ƒ deadlockï¼‰                    â”‚
â”‚                                                                  â”‚
â”‚  æ‡‰è©²åšçš„äº‹ï¼š                                                     â”‚
â”‚    - ç¢ºèªä¸­æ–·ä¾†æºï¼ˆæ˜¯å¦æ˜¯æˆ‘çš„ä¸­æ–·ï¼Ÿï¼‰                             â”‚
â”‚    - æ¸…é™¤ç¡¬é«”ä¸­æ–·æ——æ¨™                                             â”‚
â”‚    - è®€å–ç·Šæ€¥è³‡æ–™åˆ° buffer                                        â”‚
â”‚    - æ’ç¨‹ Bottom-half                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Bottom-half (å»¶é²è™•ç†)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ©Ÿåˆ¶é¸æ“‡ï¼š                                                       â”‚
â”‚                                                                  â”‚
â”‚  1. Softirqï¼ˆæœ€åº•å±¤ï¼‰                                            â”‚
â”‚     - å›ºå®šæ•¸é‡ï¼ŒKernel ç·¨è­¯æ™‚å®šç¾©                                 â”‚
â”‚     - Driver é€šå¸¸ä¸ç›´æ¥ä½¿ç”¨                                       â”‚
â”‚     - åœ¨ IRQ è¿”å›æ™‚æˆ– ksoftirqd åŸ·è¡Œ                              â”‚
â”‚                                                                  â”‚
â”‚  2. Taskletï¼ˆå»ºæ§‹åœ¨ Softirq ä¸Šï¼‰                                 â”‚
â”‚     - ä¸èƒ½ç¡çœ                                                     â”‚
â”‚     - ä¸€å€‹ Tasklet åªèƒ½åœ¨ä¸€å€‹ CPU åŸ·è¡Œ                            â”‚
â”‚     - è¼•é‡ã€å¿«é€Ÿ                                                  â”‚
â”‚                                                                  â”‚
â”‚  3. Workqueueï¼ˆProcess Contextï¼‰                                 â”‚
â”‚     - å¯ä»¥ç¡çœ ï¼                                                  â”‚
â”‚     - å¯ä»¥ä½¿ç”¨ mutex                                              â”‚
â”‚     - é©åˆè€—æ™‚æ“ä½œ                                                â”‚
â”‚                                                                  â”‚
â”‚  4. Threaded IRQï¼ˆå°ˆç”¨ Kernel Threadï¼‰                           â”‚
â”‚     - å¯ä»¥ç¡çœ ï¼                                                  â”‚
â”‚     - ç¨‹å¼ç¢¼ç°¡æ½”                                                  â”‚
â”‚     - ç¾ä»£ Driver æ¨è–¦ç”¨æ³•                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Softirq æ·±å…¥

```c
/* Softirq æ˜¯ Kernel å…§éƒ¨çš„åº•å±¤æ©Ÿåˆ¶ */
/* å®šç¾©åœ¨ include/linux/interrupt.h */

enum {
    HI_SOFTIRQ = 0,         /* é«˜å„ªå…ˆæ¬Š tasklet */
    TIMER_SOFTIRQ,          /* Timer */
    NET_TX_SOFTIRQ,         /* ç¶²è·¯ç™¼é€ */
    NET_RX_SOFTIRQ,         /* ç¶²è·¯æ¥æ”¶ */
    BLOCK_SOFTIRQ,          /* Block device */
    IRQ_POLL_SOFTIRQ,       /* IRQ polling */
    TASKLET_SOFTIRQ,        /* Tasklet */
    SCHED_SOFTIRQ,          /* Scheduler */
    HRTIMER_SOFTIRQ,        /* High-resolution timer */
    RCU_SOFTIRQ,            /* RCU */
    NR_SOFTIRQS
};

/* Softirq åŸ·è¡Œæ™‚æ©Ÿï¼š
 * 1. Hardirq è¿”å›æ™‚ï¼ˆirq_exit()ï¼‰
 * 2. æ˜ç¢ºå‘¼å« local_bh_enable()
 * 3. ksoftirqd kernel threadï¼ˆå¦‚æœ softirq å¤ªå¤šï¼‰
 */

/* æŸ¥çœ‹ softirq çµ±è¨ˆ */
$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:          0          0          0          0
       TIMER:    1234567    1234568    1234569    1234570
      NET_TX:      12345      12346      12347      12348
      NET_RX:     123456     123457     123458     123459
       ...
```

### 2.3 Tasklet

```c
#include <linux/interrupt.h>

/* Tasklet ç‰¹é»ï¼š
 * - åœ¨ Softirq Context åŸ·è¡Œï¼ˆä¸èƒ½ç¡çœ ï¼‰
 * - åŒä¸€å€‹ Tasklet ä¸æœƒåŒæ™‚åœ¨å¤šå€‹ CPU åŸ·è¡Œï¼ˆè‡ªå‹•åºåˆ—åŒ–ï¼‰
 * - è¼•é‡ç´šï¼Œé©åˆå¿«é€Ÿè™•ç†
 * - Linux 5.9+ é–‹å§‹è¢«èªç‚ºæ˜¯ Deprecatedï¼Œå»ºè­°ç”¨ Threaded IRQ
 */

/* æ–¹æ³• 1ï¼šç·¨è­¯æ™‚å®£å‘Š */
static void my_tasklet_func(unsigned long data)
{
    struct my_device *priv = (struct my_device *)data;
    
    /* è™•ç†å·¥ä½œï¼Œä½†ä¸èƒ½ç¡çœ ï¼ */
    /* ä¸èƒ½ç”¨ mutexï¼Œåªèƒ½ç”¨ spinlock */
    
    spin_lock(&priv->lock);
    /* ... */
    spin_unlock(&priv->lock);
}

static DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);

/* æ–¹æ³• 2ï¼šåŸ·è¡Œæ™‚åˆå§‹åŒ– */
struct my_device {
    struct tasklet_struct tasklet;
    spinlock_t lock;
};

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    spin_lock_init(&priv->lock);
    
    tasklet_init(&priv->tasklet, my_tasklet_func, (unsigned long)priv);
    
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    struct my_device *priv = platform_get_drvdata(pdev);
    
    tasklet_kill(&priv->tasklet);  /* ç­‰å¾… tasklet å®Œæˆä¸¦ç¦ç”¨ */
    
    return 0;
}

/* åœ¨ ISR ä¸­æ’ç¨‹ tasklet */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* Top-halfï¼šå¿«é€Ÿè™•ç† */
    clear_interrupt_flag(priv);
    
    /* æ’ç¨‹ Bottom-half */
    tasklet_schedule(&priv->tasklet);
    
    return IRQ_HANDLED;
}
```

### 2.4 Workqueue

```c
#include <linux/workqueue.h>

/* Workqueue ç‰¹é»ï¼š
 * - åœ¨ Process Context åŸ·è¡Œï¼ˆå¯ä»¥ç¡çœ ï¼ï¼‰
 * - å¯ä»¥ä½¿ç”¨ mutexã€åš I/O æ“ä½œ
 * - é©åˆè€—æ™‚å·¥ä½œ
 * - æœ‰å¤šç¨®æ¨¡å¼ï¼šsystem wqã€dedicated wqã€unbound wq
 */

/* ============ æ–¹æ³• 1ï¼šä½¿ç”¨ System Workqueue ============ */

struct my_device {
    struct work_struct work;
    struct mutex lock;
    int data;
};

static void my_work_func(struct work_struct *work)
{
    struct my_device *priv = container_of(work, struct my_device, work);
    
    /* å¯ä»¥ç¡çœ ï¼å¯ä»¥ä½¿ç”¨ mutexï¼ */
    mutex_lock(&priv->lock);
    
    /* è™•ç†è€—æ™‚å·¥ä½œï¼Œä¾‹å¦‚ I2C è®€å¯« */
    i2c_smbus_read_byte_data(client, reg);
    
    mutex_unlock(&priv->lock);
}

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    mutex_init(&priv->lock);
    INIT_WORK(&priv->work, my_work_func);
    
    return 0;
}

static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    clear_interrupt_flag(priv);
    schedule_work(&priv->work);  /* æ’ç¨‹åˆ° system workqueue */
    
    return IRQ_HANDLED;
}

/* ============ æ–¹æ³• 2ï¼šä½¿ç”¨ Delayed Work ============ */

struct my_device {
    struct delayed_work dwork;
};

INIT_DELAYED_WORK(&priv->dwork, my_work_func);
schedule_delayed_work(&priv->dwork, msecs_to_jiffies(100));  /* 100ms å¾ŒåŸ·è¡Œ */

/* ============ æ–¹æ³• 3ï¼šå»ºç«‹å°ˆç”¨ Workqueue ============ */

static struct workqueue_struct *my_wq;

my_wq = create_singlethread_workqueue("my_driver_wq");
/* æˆ– */
my_wq = alloc_workqueue("my_wq", WQ_UNBOUND | WQ_HIGHPRI, 0);

queue_work(my_wq, &priv->work);

/* æ¸…ç† */
flush_workqueue(my_wq);
destroy_workqueue(my_wq);
```

### 2.5 Threaded IRQï¼ˆç¾ä»£ Driver æ¨è–¦ï¼‰

```c
/* Threaded IRQ ç‰¹é»ï¼š
 * - Bottom-half åœ¨å°ˆç”¨ Kernel Thread åŸ·è¡Œ
 * - å¯ä»¥ç¡çœ 
 * - ç¨‹å¼ç¢¼æ›´ç°¡æ½”
 * - ç¾ä»£ Driver æ¨è–¦ä½¿ç”¨
 * - RT (Real-Time) Linux å‹å¥½
 */

/* Primary Handler (Top-half) */
static irqreturn_t my_isr_primary(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    u32 status;
    
    /* å¿«é€Ÿç¢ºèªæ˜¯å¦æ˜¯æˆ‘çš„ä¸­æ–· */
    status = readl(priv->base + REG_STATUS);
    if (!(status & MY_IRQ_MASK))
        return IRQ_NONE;  /* ä¸æ˜¯æˆ‘çš„ä¸­æ–· */
    
    /* æ¸…é™¤ä¸­æ–·æ——æ¨™ï¼ˆå¦‚æœéœ€è¦åœ¨ Top-half åšï¼‰ */
    writel(status, priv->base + REG_STATUS);
    
    /* ä¿å­˜ç‹€æ…‹ä¾› Thread handler ä½¿ç”¨ */
    priv->irq_status = status;
    
    return IRQ_WAKE_THREAD;  /* å–šé†’ Thread handler */
}

/* Thread Handler (Bottom-half) */
static irqreturn_t my_isr_thread(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* å¯ä»¥ç¡çœ ï¼å¯ä»¥ä½¿ç”¨ mutexï¼ */
    mutex_lock(&priv->lock);
    
    /* æ ¹æ“š irq_status è™•ç†ä¸åŒäº‹ä»¶ */
    if (priv->irq_status & IRQ_DATA_READY) {
        process_data(priv);
    }
    if (priv->irq_status & IRQ_ERROR) {
        handle_error(priv);
    }
    
    mutex_unlock(&priv->lock);
    
    return IRQ_HANDLED;
}

/* è¨»å†Š Threaded IRQ */
static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    int irq, ret;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    mutex_init(&priv->lock);
    
    irq = platform_get_irq(pdev, 0);
    if (irq < 0)
        return irq;
    
    ret = devm_request_threaded_irq(&pdev->dev, irq,
                                    my_isr_primary,    /* Top-half */
                                    my_isr_thread,     /* Bottom-half */
                                    IRQF_ONESHOT,      /* å¿…é ˆï¼ */
                                    dev_name(&pdev->dev), priv);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }
    
    return 0;
}

/* IRQF_ONESHOT èªªæ˜ï¼š
 * - åœ¨ Thread handler å®Œæˆå‰ä¿æŒ IRQ é®ç½©
 * - é¿å…ä¸­æ–·å†æ¬¡è§¸ç™¼ï¼ˆåœ¨é›»å¹³è§¸ç™¼æ™‚å¾ˆé‡è¦ï¼‰
 * - å°æ–¼ Threaded IRQ å¹¾ä¹ç¸½æ˜¯éœ€è¦
 */
```

### 2.6 Bottom-half æ©Ÿåˆ¶æ¯”è¼ƒ

| ç‰¹æ€§ | Softirq | Tasklet | Workqueue | Threaded IRQ |
|:---|:---|:---|:---|:---|
| Context | Softirq | Softirq | Process | Process |
| å¯ç¡çœ  | âŒ | âŒ | âœ… | âœ… |
| å¯ç”¨ Mutex | âŒ | âŒ | âœ… | âœ… |
| åŒæ™‚å¤š CPU | âœ… (åŒé¡å‹) | âŒ (åŒä¸€å€‹) | âœ… | âŒ (åŒä¸€å€‹) |
| é©ç”¨å ´æ™¯ | ç¶²è·¯/Block | è¼•é‡ driver | è€—æ™‚ I/O | ç¾ä»£ driver |
| è¤‡é›œåº¦ | é«˜ | ä¸­ | ä¸­ | ä½ |
| RT å‹å¥½ | âŒ | âŒ | âœ… | âœ… |

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¸­æ–· API è©³è§£

### 3.1 request_irq ç³»åˆ—

```c
/* ============ request_irq (åŸºæœ¬ç‰ˆ) ============ */
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev);

/* å¿…é ˆé…å° free_irq */
free_irq(irq, dev);

/* ============ devm_request_irq (æ¨è–¦) ============ */
int devm_request_irq(struct device *dev,
                     unsigned int irq,
                     irq_handler_t handler,
                     unsigned long irqflags,
                     const char *devname,
                     void *dev_id);

/* ä¸éœ€è¦æ‰‹å‹• freeï¼Œdevice ç§»é™¤æ™‚è‡ªå‹•é‡‹æ”¾ */

/* ============ request_threaded_irq ============ */
int request_threaded_irq(unsigned int irq,
                         irq_handler_t handler,      /* Top-halfï¼Œå¯ç‚º NULL */
                         irq_handler_t thread_fn,    /* Bottom-half */
                         unsigned long flags,
                         const char *name,
                         void *dev);

/* ============ devm_request_threaded_irq (æ¨è–¦) ============ */
int devm_request_threaded_irq(struct device *dev,
                              unsigned int irq,
                              irq_handler_t handler,
                              irq_handler_t thread_fn,
                              unsigned long irqflags,
                              const char *devname,
                              void *dev_id);
```

### 3.2 å¸¸ç”¨ Flags

```c
/* è§¸ç™¼é¡å‹ */
IRQF_TRIGGER_NONE         /* ç”±ç¡¬é«”/firmware æ±ºå®š */
IRQF_TRIGGER_RISING       /* ä¸Šå‡ç·£ */
IRQF_TRIGGER_FALLING      /* ä¸‹é™ç·£ */
IRQF_TRIGGER_HIGH         /* é«˜é›»å¹³ */
IRQF_TRIGGER_LOW          /* ä½é›»å¹³ */

/* å…±äº« */
IRQF_SHARED               /* å¤šå€‹ handler å…±ç”¨åŒä¸€ IRQ */

/* Threaded IRQ ç›¸é—œ */
IRQF_ONESHOT              /* åœ¨ thread handler å®Œæˆå‰ä¿æŒé®ç½© */

/* å…¶ä»– */
IRQF_NO_SUSPEND           /* ç³»çµ± suspend æ™‚ä¸ disable */
IRQF_NOBALANCING          /* ç¦æ­¢ IRQ balancing */
IRQF_PERCPU               /* æ¯å€‹ CPU ç¨ç«‹è™•ç† */
```

### 3.3 IRQ API æ¯”è¼ƒ

| API | è‡ªå‹•é‡‹æ”¾ | Top-half | Bottom-half | æ¨è–¦ç”¨é€” |
|:---|:---:|:---:|:---:|:---|
| request_irq | âŒ | âœ… | âŒ | èˆŠ driver |
| devm_request_irq | âœ… | âœ… | âŒ | ç°¡å–®ä¸­æ–· |
| request_threaded_irq | âŒ | âœ…/NULL | âœ… | èˆŠ driver |
| devm_request_threaded_irq | âœ… | âœ…/NULL | âœ… | **ç¾ä»£ driver** |

### 3.4 Interrupt Context åˆ¤æ–·

```c
#include <linux/hardirq.h>
#include <linux/preempt.h>

/* åˆ¤æ–·ç•¶å‰ context */

in_interrupt()     /* åœ¨ä»»ä½•ä¸­æ–· context (hardirq æˆ– softirq) */
in_irq()           /* åœ¨ç¡¬ä¸­æ–· context (Top-half) */
in_softirq()       /* åœ¨ softirq context (åŒ…æ‹¬ tasklet) */
in_task()          /* åœ¨ process context */
in_atomic()        /* ä¸èƒ½ç¡çœ çš„ç‹€æ…‹ */

/* å¯¦éš›ä½¿ç”¨ */
void my_function(void)
{
    if (in_interrupt()) {
        /* ä½¿ç”¨ spinlockï¼Œä¸èƒ½ç¡çœ  */
        spin_lock(&lock);
        /* ... */
        spin_unlock(&lock);
    } else {
        /* å¯ä»¥ä½¿ç”¨ mutex */
        mutex_lock(&mutex);
        /* ... */
        mutex_unlock(&mutex);
    }
}

/* è¨˜æ†¶é«”åˆ†é… */
void *ptr;
if (in_interrupt())
    ptr = kmalloc(size, GFP_ATOMIC);  /* ä¸èƒ½ç¡çœ  */
else
    ptr = kmalloc(size, GFP_KERNEL);  /* å¯ä»¥ç¡çœ  */
```

### 3.5 IRQ Control

```c
/* ç¦ç”¨/å•Ÿç”¨ç‰¹å®š IRQ */
disable_irq(unsigned int irq);       /* ç¦ç”¨ä¸¦ç­‰å¾…ç•¶å‰ handler å®Œæˆ */
disable_irq_nosync(unsigned int irq); /* ç¦ç”¨ï¼Œä¸ç­‰å¾… */
enable_irq(unsigned int irq);

/* ç¦ç”¨/å•Ÿç”¨æœ¬åœ° CPU ä¸­æ–· */
local_irq_disable();
local_irq_enable();

/* ä¿å­˜å’Œæ¢å¾©ï¼ˆæ”¯æ´å·¢ç‹€ï¼‰ */
unsigned long flags;
local_irq_save(flags);
/* ... */
local_irq_restore(flags);

/* Spinlock + ç¦ç”¨ä¸­æ–· */
spin_lock_irqsave(&lock, flags);
/* ... */
spin_unlock_irqrestore(&lock, flags);
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šGIC æ¶æ§‹ï¼ˆARMï¼‰

### 4.1 GIC æ¦‚è¿°

```
GIC (Generic Interrupt Controller) æ˜¯ ARM è™•ç†å™¨çš„æ¨™æº–ä¸­æ–·æ§åˆ¶å™¨ã€‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        GIC æ¶æ§‹ç¸½è¦½                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ Timer   â”‚  â”‚  UART   â”‚  â”‚  GPIO   â”‚  â† å‘¨é‚Šè¨­å‚™              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                         â”‚
â”‚       â”‚            â”‚            â”‚                               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                    â†“                                            â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚            â”‚  Distributor â”‚  â† æ”¶é›†ã€å„ªå…ˆæ¬Šæ’åºã€åˆ†ç™¼           â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                   â”‚                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚       â†“           â†“           â†“                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚CPU IF 0 â”‚ â”‚CPU IF 1 â”‚ â”‚CPU IF 2 â”‚  â† æ¯ CPU ä¸€å€‹            â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                          â”‚
â”‚       â†“           â†“           â†“                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚  CPU 0  â”‚ â”‚  CPU 1  â”‚ â”‚  CPU 2  â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 GIC ä¸­æ–·é¡å‹

```c
/* GIC å®šç¾©ä¸‰ç¨®ä¸­æ–·é¡å‹ */

/* SGI (Software Generated Interrupt): 0-15 */
/* - ç”¨æ–¼ CPU é–“é€šè¨Š (IPI) */
/* - é€éå¯«å…¥ GICD_SGIR æš«å­˜å™¨è§¸ç™¼ */
/* - ä¾‹å¦‚ï¼šè®“å…¶ä»– CPU åŸ·è¡Œå·¥ä½œã€å–šé†’å…¶ä»– CPU */

/* PPI (Private Peripheral Interrupt): 16-31 */
/* - æ¯å€‹ CPU ç§æœ‰çš„ä¸­æ–· */
/* - ä¾‹å¦‚ï¼šCPU çš„ Local Timerã€PMU */
/* - æ¯å€‹ CPU çœ‹åˆ°çš„æ˜¯åŒä¸€å€‹ IRQ è™Ÿç¢¼ï¼Œä½†ç¨ç«‹è™•ç† */

/* SPI (Shared Peripheral Interrupt): 32-1019 */
/* - å…±äº«çš„å‘¨é‚Šä¸­æ–· */
/* - å¯ä»¥è¢«åˆ†ç™¼åˆ°ä»»ä½• CPU */
/* - ä¾‹å¦‚ï¼šUARTã€SPIã€I2Cã€GPIO */
/* - Device Tree ä¸­é€šå¸¸æŒ‡å®šçš„æ˜¯é€™é¡ */

/* Device Tree ç¯„ä¾‹ */
my_device@40000000 {
    /* GIC_SPI 32 = SPI ä¸­æ–· 32ï¼Œå¯¦éš› IRQ = 32 + 32 = 64 */
    /* IRQ_TYPE_LEVEL_HIGH = é›»å¹³è§¸ç™¼ï¼Œé«˜é›»å¹³ */
    interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
};
```

### 4.3 GICv2 vs GICv3

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      GICv2 æ¶æ§‹                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Peripherals â†’ Distributor â†’ CPU Interfaces â†’ CPUs              â”‚
â”‚                                                                  â”‚
â”‚  - æœ€å¤šæ”¯æ´ 8 å€‹ CPU                                             â”‚
â”‚  - IRQ è™Ÿç¢¼æœ€å¤š 1020                                             â”‚
â”‚  - ç”¨æ–¼ ARMv7/ARMv8 (32-bit mode)                               â”‚
â”‚                                                                  â”‚
â”‚  ä¸»è¦æš«å­˜å™¨ï¼š                                                     â”‚
â”‚    GICD_*: Distributor æš«å­˜å™¨                                    â”‚
â”‚    GICC_*: CPU Interface æš«å­˜å™¨                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      GICv3 æ¶æ§‹                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Peripherals â†’ Distributor â†’ Redistributors â†’ CPU IFs â†’ CPUs    â”‚
â”‚                              (æ¯ CPU ä¸€å€‹)                       â”‚
â”‚                                                                  â”‚
â”‚  æ–°å¢ Redistributorï¼š                                            â”‚
â”‚    - è™•ç† LPI (Locality-specific Peripheral Interrupts)          â”‚
â”‚    - è™•ç† PPI å’Œ SGI çš„è¨­å®š                                      â”‚
â”‚    - æ¯å€‹ CPU æœ‰è‡ªå·±çš„ Redistributor                             â”‚
â”‚                                                                  â”‚
â”‚  æ”¹é€²ï¼š                                                           â”‚
â”‚    - æ”¯æ´æ•¸ç™¾å€‹ CPU                                               â”‚
â”‚    - æ›´å¤š IRQï¼ˆLPI å¯é”æ•¸è¬å€‹ï¼‰                                   â”‚
â”‚    - æ”¯æ´è™›æ“¬åŒ–                                                   â”‚
â”‚    - System Register å­˜å–ï¼ˆæ›¿ä»£ MMIOï¼‰                           â”‚
â”‚                                                                  â”‚
â”‚  ä¸»è¦æš«å­˜å™¨ï¼š                                                     â”‚
â”‚    GICD_*: Distributor                                          â”‚
â”‚    GICR_*: Redistributor                                        â”‚
â”‚    GICC_* / ICC_*_EL1: CPU Interface                            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.4 ä¸­æ–·è™•ç†æµç¨‹ï¼ˆGIC è¦–è§’ï¼‰

```c
/* 1. å‘¨é‚Šè¨­å‚™è§¸ç™¼ä¸­æ–·ä¿¡è™Ÿ
 * 2. Distributor æ¥æ”¶ä¸­æ–·
 *    - æª¢æŸ¥ä¸­æ–·æ˜¯å¦ enabled (GICD_ISENABLERn)
 *    - ç¢ºå®šå„ªå…ˆæ¬Š (GICD_IPRIORITYRn)
 *    - æ±ºå®šç›®æ¨™ CPU (GICD_ITARGETSRn)
 * 
 * 3. Distributor å°‡ä¸­æ–·ç™¼é€åˆ°ç›®æ¨™ CPU çš„ Interface
 * 
 * 4. CPU Interface å‘ CPU ç™¼å‡º IRQ ä¿¡è™Ÿ
 *    - åªæœ‰ç•¶ä¸­æ–·å„ªå…ˆæ¬Šé«˜æ–¼ Priority Mask (GICC_PMR)
 * 
 * 5. CPU é€²å…¥ç•°å¸¸è™•ç†
 * 
 * 6. CPU è®€å– GICC_IAR (Interrupt Acknowledge Register)
 *    - ç²å– IRQ è™Ÿç¢¼
 *    - ä¸­æ–·è®Šæˆ Active ç‹€æ…‹
 * 
 * 7. CPU åŸ·è¡Œ ISR
 * 
 * 8. CPU å¯«å…¥ GICC_EOIR (End of Interrupt Register)
 *    - ä¸­æ–·è™•ç†å®Œæˆ
 *    - ä¸­æ–·è®Šå› Inactive ç‹€æ…‹
 */
```

### 4.5 ä¸­æ–·è¦ªå’Œæ€§ (IRQ Affinity)

```c
/* è¨­å®šä¸­æ–·ç”±å“ªå€‹ CPU è™•ç† */
#include <linux/interrupt.h>

/* ç¨‹å¼ç¢¼ä¸­è¨­å®š */
cpumask_t mask;
cpumask_clear(&mask);
cpumask_set_cpu(2, &mask);  /* åªè®“ CPU 2 è™•ç† */
int ret = irq_set_affinity(irq, &mask);
if (ret)
    pr_err("Failed to set IRQ affinity\n");

/* åœ¨ /proc ä¸­æŸ¥çœ‹å’Œè¨­å®š */
/* æŸ¥çœ‹ IRQ 33 çš„è¦ªå’Œæ€§ */
$ cat /proc/irq/33/smp_affinity
f  /* è¡¨ç¤º CPU 0-3 éƒ½å¯ä»¥è™•ç† (äºŒé€²ä½ 1111) */

/* è¨­å®šåªè®“ CPU 2 è™•ç† */
$ echo 4 > /proc/irq/33/smp_affinity  /* äºŒé€²ä½ 0100 */

/* æŸ¥çœ‹ç•¶å‰åœ¨å“ªå€‹ CPU è™•ç† */
$ cat /proc/irq/33/smp_affinity_list
2

/* æŸ¥çœ‹ IRQ çµ±è¨ˆ */
$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       
 33:          0          0      12345          0  my_device
```

### 4.6 ç‚ºä»€éº¼è¨­å®š IRQ Affinityï¼Ÿ

```c
/* æ•ˆèƒ½å„ªåŒ–åŸå› ï¼š
 * 
 * 1. Cache Locality
 *    - è®“ IRQ ç¸½æ˜¯åœ¨åŒä¸€å€‹ CPU è™•ç†
 *    - è³‡æ–™å¯ä»¥ä¿ç•™åœ¨è©² CPU çš„ cache
 * 
 * 2. è² è¼‰å‡è¡¡
 *    - å°‡é«˜é »ä¸­æ–·åˆ†æ•£åˆ°ä¸åŒ CPU
 *    - é¿å…å–®ä¸€ CPU éè¼‰
 * 
 * 3. Real-Time éœ€æ±‚
 *    - å°‡ RT ä¸­æ–·ç¶å®šåˆ°å°ˆç”¨ CPU
 *    - æ¸›å°‘å»¶é²è®Šç•°
 * 
 * 4. NUMA è€ƒé‡
 *    - è®“ IRQ åœ¨é è¿‘è£ç½®çš„ NUMA node è™•ç†
 */
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šè‡¨ç•Œå€æ®µèˆ‡åŒæ­¥

### 5.1 ISR èˆ‡ä¸»ç¨‹å¼å…±äº«è³‡æ–™

```c
/* Race Condition ç¯„ä¾‹ */
volatile int counter = 0;

void ISR(void) {
    counter++;  /* è®€-æ”¹-å¯«ï¼ŒéåŸå­æ“ä½œï¼ */
}

void main_task(void) {
    counter++;  /* å¯èƒ½åœ¨ ISR åŸ·è¡Œä¸­é–“è¢«æ‰“æ–· */
}

/* å•é¡Œï¼š
 * 1. main_task è®€å– counter = 5
 * 2. ISR ç™¼ç”Ÿï¼Œè®€å– counter = 5
 * 3. ISR åŸ·è¡Œ 5 + 1 = 6ï¼Œå¯«å›
 * 4. main_task ç¹¼çºŒï¼Œ5 + 1 = 6ï¼Œå¯«å›
 * çµæœï¼šæ‡‰è©²æ˜¯ 7ï¼Œä½†å¯¦éš›æ˜¯ 6ï¼
 */
```

### 5.2 ä¿è­·å…±äº«è³‡æ–™çš„æ–¹æ³•

```c
/* æ–¹æ³• 1ï¼šç¦ç”¨ä¸­æ–· */
unsigned long flags;
local_irq_save(flags);
counter++;
local_irq_restore(flags);

/* æ–¹æ³• 2ï¼šSpinlock + ç¦ç”¨ä¸­æ–· (æ¨è–¦) */
spinlock_t lock;
spin_lock_init(&lock);

/* åœ¨ process context */
spin_lock_irqsave(&lock, flags);
counter++;
spin_unlock_irqrestore(&lock, flags);

/* åœ¨ ISR */
spin_lock(&lock);  /* å·²ç¶“åœ¨ä¸­æ–·ä¸­ï¼Œä¸éœ€è¦ save flags */
counter++;
spin_unlock(&lock);

/* æ–¹æ³• 3ï¼šåŸå­æ“ä½œ */
atomic_t atomic_counter = ATOMIC_INIT(0);
atomic_inc(&atomic_counter);
int val = atomic_read(&atomic_counter);
```

### 5.3 volatile é—œéµå­—

```c
/* volatile å‘Šè¨´ç·¨è­¯å™¨ï¼šä¸è¦å„ªåŒ–ï¼Œæ¯æ¬¡éƒ½å¾è¨˜æ†¶é«”è®€å– */

/* éœ€è¦ volatile çš„å ´æ™¯ï¼š
 * 1. ISR å’Œä¸»ç¨‹å¼å…±äº«çš„è®Šæ•¸
 * 2. ç¡¬é«”æš«å­˜å™¨
 * 3. Busy-wait loop
 */

/* ç¯„ä¾‹ï¼šç­‰å¾…ç¡¬é«”å®Œæˆ */
volatile uint32_t *status_reg = (volatile uint32_t *)0x40000000;

while ((*status_reg & BUSY_FLAG) != 0) {
    /* æ²’æœ‰ volatileï¼Œç·¨è­¯å™¨å¯èƒ½å„ªåŒ–æˆï¼š
     * if (*status_reg & BUSY_FLAG) while(1);
     * å› ç‚ºå®ƒèªç‚ºè¿´åœˆå…§æ²’äººæ”¹è®Š status_reg
     */
}

/* æ³¨æ„ï¼švolatile ä¸ä¿è­‰åŸå­æ€§ï¼ */
/* åªä¿è­‰ã€Œæ¯æ¬¡éƒ½è®€å¯«è¨˜æ†¶é«”ã€ï¼Œä¸ä¿è­‰ã€Œè®€-æ”¹-å¯«ã€æ˜¯åŸå­çš„ */
```

### 5.4 Memory Barrier

```c
/* ç¢ºä¿è¨˜æ†¶é«”æ“ä½œçš„é †åº */

/* Linux Kernel æä¾›çš„ Barrier */
mb();   /* Full memory barrier */
rmb();  /* Read memory barrier */
wmb();  /* Write memory barrier */

smp_mb();   /* SMP å®‰å…¨çš„ full barrier */
smp_rmb();  /* SMP å®‰å…¨çš„ read barrier */
smp_wmb();  /* SMP å®‰å…¨çš„ write barrier */

/* ä½¿ç”¨å ´æ™¯ï¼šé€šçŸ¥å…¶ä»– CPU */
void producer(void)
{
    data = 123;       /* å…ˆå¯«å…¥è³‡æ–™ */
    smp_wmb();        /* ç¢ºä¿ data å¯«å…¥å®Œæˆ */
    flag = 1;         /* å†è¨­å®š flag */
}

void consumer(void)
{
    while (!flag);    /* ç­‰å¾… flag */
    smp_rmb();        /* ç¢ºä¿è®€åˆ°æœ€æ–°çš„ data */
    use(data);        /* ä½¿ç”¨è³‡æ–™ */
}
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Top-half å’Œ Bottom-half çš„å€åˆ¥ï¼Ÿä»€éº¼æ™‚å€™ç”¨å“ªå€‹ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘ / æ¯å®¶å…¬å¸

**ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | Top-half | Bottom-half |
|:---|:---|:---|
| åŸ·è¡Œæ™‚æ©Ÿ | ç«‹å³ï¼Œä¸­æ–·ç™¼ç”Ÿæ™‚ | ç¨å¾Œï¼Œç”± Kernel æ’ç¨‹ |
| Context | Interrupt Context | Softirq/Process Context |
| å¯å¦ç¡çœ  | âŒ ä¸å¯ä»¥ | Tasklet âŒ, Workqueue/Threaded âœ… |
| å…¸å‹å·¥ä½œ | æ¸…é™¤æ——æ¨™ã€è®€ç·Šæ€¥è³‡æ–™ | è³‡æ–™è™•ç†ã€I/O æ“ä½œ |

**ä½¿ç”¨åŸå‰‡**ï¼š
- Top-half åšæœ€å°‘å¿…è¦çš„äº‹ï¼ˆç¢ºèªä¾†æºã€æ¸…æ——æ¨™ã€æ’ç¨‹ï¼‰
- è€—æ™‚å·¥ä½œæ”¾ Bottom-half
- éœ€è¦ mutex/ç¡çœ  â†’ Workqueue æˆ– Threaded IRQ

---

### Q2: Tasklet vs Workqueue vs Threaded IRQ å¦‚ä½•é¸æ“‡ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Google

**ç­”æ¡ˆ**ï¼š

| éœ€æ±‚ | é¸æ“‡ | åŸå›  |
|:---|:---|:---|
| å¿«é€Ÿã€ä¸éœ€ç¡çœ  | Tasklet | Softirq contextï¼Œä½å»¶é² |
| éœ€è¦ mutex/ç¡çœ  | Workqueue | Process context |
| ç¾ä»£ Driver é–‹ç™¼ | Threaded IRQ | ç°¡æ½”ã€RT å‹å¥½ |
| RT Linux | Threaded IRQ | å¯è¢« RT æ’ç¨‹å™¨ç®¡ç† |

**Threaded IRQ å„ªé»**ï¼š
- ç¨‹å¼ç¢¼ç°¡æ½”ï¼ˆä¸éœ€é¡å¤–ç®¡ç† tasklet/workï¼‰
- è‡ªå‹•è™•ç† Top/Bottom-half åˆ†é›¢
- RT Linux å‹å¥½
- Linux æ ¸å¿ƒç¤¾ç¾¤æ¨è–¦

---

### Q3: åœ¨ Interrupt Context ä¸­å¯ä»¥å‘¼å« mutex_lock() å—ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ¯å®¶å…¬å¸

**ç­”æ¡ˆ**ï¼š
**çµ•å°ä¸è¡Œï¼**

åŸå› ï¼š
- mutex_lock() å¯èƒ½ç¡çœ 
- ç¡çœ éœ€è¦ schedule()
- schedule() éœ€è¦å®Œæ•´çš„ Process Context
- Interrupt Context æ²’æœ‰å¯åˆ‡æ›çš„ process

å¾Œæœï¼š
- Kernel åµæ¸¬åˆ°æœƒ BUG() å ±éŒ¯
- èˆŠç‰ˆæœ¬å¯èƒ½ç›´æ¥ system hang

æ›¿ä»£æ–¹æ¡ˆï¼š
- ä½¿ç”¨ spinlock_irqsave()
- ä½¿ç”¨ Workqueue æˆ– Threaded IRQ

---

### Q4: ä»€éº¼æ˜¯ IRQF_ONESHOTï¼Ÿä»€éº¼æ™‚å€™éœ€è¦ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
`IRQF_ONESHOT` è¡¨ç¤ºåœ¨ Thread handler å®Œæˆå‰ä¿æŒä¸­æ–·é®ç½©ã€‚

éœ€è¦çš„æƒ…æ³ï¼š
1. ä½¿ç”¨ Threaded IRQï¼ˆå¹¾ä¹å¿…é ˆï¼‰
2. é›»å¹³è§¸ç™¼çš„ä¸­æ–·
3. ä¸­æ–·æºéœ€è¦åœ¨ Thread handler ä¸­æ‰èƒ½æ¸…é™¤

åŸå› ï¼š
- é›»å¹³è§¸ç™¼çš„ä¸­æ–·ï¼Œåªè¦è§¸ç™¼æ¢ä»¶ç¶­æŒï¼Œå°±æœƒä¸æ–·è§¸ç™¼
- å¦‚æœæ²’æœ‰ ONESHOTï¼ŒTop-half çµæŸå¾Œä¸­æ–·æœƒç«‹å³å†æ¬¡è§¸ç™¼
- Thread handler é‚„æ²’ä¾†å¾—åŠæ¸…é™¤ä¾†æº

---

### Q5: è§£é‡‹ GIC çš„ SGIã€PPIã€SPI

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š

| é¡å‹ | IRQ ç¯„åœ | ç”¨é€” | ç‰¹é» |
|:---|:---|:---|:---|
| SGI | 0-15 | CPU é–“é€šè¨Š | è»Ÿé«”è§¸ç™¼ |
| PPI | 16-31 | CPU ç§æœ‰å‘¨é‚Š | æ¯ CPU ç¨ç«‹ |
| SPI | 32-1019 | å…±äº«å‘¨é‚Š | å¯åˆ†ç™¼åˆ°ä»»ä½• CPU |

Device Tree ç¯„ä¾‹ï¼š
```dts
/* GIC_SPI 32 = IRQ 64 (32 + 32) */
interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
```

---

### Q6: IRQ Affinity è¨­å®šçš„ç›®çš„ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
1. **Cache å±€éƒ¨æ€§**ï¼šåŒä¸€ CPU è™•ç†ï¼Œè³‡æ–™ç•™åœ¨ cache
2. **è² è¼‰å‡è¡¡**ï¼šåˆ†æ•£é«˜é »ä¸­æ–·åˆ°å¤šå€‹ CPU
3. **Real-Time**ï¼šRT ä¸­æ–·ç¶å®šå°ˆç”¨ CPU
4. **NUMA**ï¼šIRQ åœ¨é è¿‘è£ç½®çš„ node è™•ç†

è¨­å®šæ–¹å¼ï¼š
```bash
echo 4 > /proc/irq/33/smp_affinity  # åªè®“ CPU 2 è™•ç†
```

---

### Q7: ç‚ºä»€éº¼ ISR è¦ç›¡å¯èƒ½çŸ­ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­

**ç­”æ¡ˆ**ï¼š
1. ISR åŸ·è¡Œæ™‚ï¼ŒåŒç­‰/è¼ƒä½å„ªå…ˆæ¬Šä¸­æ–·è¢«é˜»æ“‹
2. éé•·å°è‡´ç³»çµ±éŸ¿æ‡‰è®Šæ…¢
3. å¯èƒ½éŒ¯éå…¶ä»–äº‹ä»¶ï¼ˆå°¤å…¶é‚Šç·£è§¸ç™¼ï¼‰
4. Real-time éœ€è¦å¯é æ¸¬çš„å»¶é²
5. ä½”ç”¨ CPU æ™‚é–“ï¼Œå½±éŸ¿å…¶ä»– task

æœ€ä½³å¯¦è¸ï¼š
- Top-half åªåšæœ€å°å¿…è¦å·¥ä½œ
- è€—æ™‚è™•ç†æ”¾ Bottom-half

---

### Q8: é€™æ®µç¨‹å¼ç¢¼æœ‰ä»€éº¼å•é¡Œï¼Ÿ

```c
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    char *buf = kmalloc(1024, GFP_KERNEL);
    
    mutex_lock(&priv->lock);
    /* è™•ç†è³‡æ–™ */
    mutex_unlock(&priv->lock);
    
    kfree(buf);
    return IRQ_HANDLED;
}
```

**é›£åº¦**ï¼šâ­â­â­â­â­

**ç­”æ¡ˆ**ï¼š
**å…©å€‹åš´é‡å•é¡Œ**ï¼š

1. **GFP_KERNEL**ï¼šåœ¨ Interrupt Context ä¸­æœƒç¡çœ 
   - æ‡‰è©²ç”¨ GFP_ATOMIC
   
2. **mutex_lock()**ï¼šåœ¨ Interrupt Context ä¸­ä¸èƒ½ä½¿ç”¨
   - æ‡‰è©²ç”¨ spinlock_irqsave() æˆ–ç§»åˆ° Threaded IRQ

ä¿®æ­£ç‰ˆï¼š
```c
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    unsigned long flags;
    
    spin_lock_irqsave(&priv->lock, flags);
    /* å¿«é€Ÿè™•ç† */
    spin_unlock_irqrestore(&priv->lock, flags);
    
    return IRQ_HANDLED;
}
```

---

## ğŸ”· ç¬¬å…­éƒ¨åˆ†ï¼šä¸­æ–·å»¶é²åˆ†æèˆ‡é‡æ¸¬

### 6.1 ä¸­æ–·å»¶é²çš„çµ„æˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä¸­æ–·å»¶é² (Interrupt Latency) åˆ†è§£                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  [ç¡¬é«”ç™¼å‡ºä¸­æ–·ä¿¡è™Ÿ]                                                       â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â”œâ”€â”€ Hardware Latency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚        â”‚   â€¢ GIC è™•ç†æ™‚é–“                                     â”‚          â”‚
â”‚        â”‚   â€¢ CPU å®Œæˆç•¶å‰æŒ‡ä»¤                                  â”‚          â”‚
â”‚        â”‚   â€¢ Pipeline flush                                   â”‚          â”‚
â”‚        â”‚                                                       â”‚ ï½1-10Î¼s â”‚
â”‚        â†“                                                       â”‚          â”‚
â”‚  [CPU æ”¶åˆ° IRQ ä¿¡è™Ÿ]                                            â”‚          â”‚
â”‚        â”‚                                                       â†“          â”‚
â”‚        â”œâ”€â”€ CPU Latency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚        â”‚   â€¢ ä¿å­˜ Context (PSTATE, registers)                   â”‚         â”‚
â”‚        â”‚   â€¢ åˆ‡æ›åˆ° Exception Vector                            â”‚         â”‚
â”‚        â”‚   â€¢ è¨­å®š Stack Pointer                                 â”‚         â”‚
â”‚        â”‚                                                       â”‚ ï½1-5Î¼s  â”‚
â”‚        â†“                                                       â†“          â”‚
â”‚  [é€²å…¥ Kernel IRQ Handler]                                               â”‚
â”‚        â”‚                                                                 â”‚
â”‚        â”œâ”€â”€ Kernel Latency â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚        â”‚   â€¢ handle_arch_irq()                                  â”‚        â”‚
â”‚        â”‚   â€¢ __handle_domain_irq()                              â”‚        â”‚
â”‚        â”‚   â€¢ IRQ domain lookup                                   â”‚        â”‚
â”‚        â”‚   â€¢ å‘¼å« driver çš„ handler                              â”‚ å¯è®Š    â”‚
â”‚        â†“                                                        â†“        â”‚
â”‚  [åŸ·è¡Œ ISR]                                                               â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å…¸å‹æ•¸å€¼ï¼ˆCortex-A53 @ 1GHzï¼‰ï¼š
- æœ€å°å»¶é²ï¼š~5Î¼s
- å¹³å‡å»¶é²ï¼š~10-50Î¼sï¼ˆå–æ±ºæ–¼ç³»çµ±è² è¼‰ï¼‰
- æœ€å¤§å»¶é²ï¼šå¯é”æ•¸ msï¼ˆå¦‚æœä¸­æ–·è¢«é•·æ™‚é–“ç¦ç”¨ï¼‰
```

### 6.2 é‡æ¸¬ä¸­æ–·å»¶é²

```c
/* æ–¹æ³• 1ï¼šä½¿ç”¨ GPIO Toggle + ç¤ºæ³¢å™¨ */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* åœ¨ ISR é–‹é ­ toggle GPIO */
    gpiod_set_value(priv->debug_gpio, 1);
    
    /* ... è™•ç†ä¸­æ–· ... */
    
    gpiod_set_value(priv->debug_gpio, 0);
    
    return IRQ_HANDLED;
}

/* ç”¨ç¤ºæ³¢å™¨é‡æ¸¬ä¸­æ–·æºä¿¡è™Ÿå’Œ GPIO toggle çš„æ™‚é–“å·® */

/* æ–¹æ³• 2ï¼šä½¿ç”¨ ftrace */
$ echo function_graph > /sys/kernel/debug/tracing/current_tracer
$ echo handle_irq_event > /sys/kernel/debug/tracing/set_ftrace_filter
$ echo 1 > /sys/kernel/debug/tracing/tracing_on
$ cat /sys/kernel/debug/tracing/trace

# è¼¸å‡ºç¯„ä¾‹ï¼š
#  0)               |  handle_irq_event() {
#  0)   2.345 us    |    irq_may_run();
#  0)               |    handle_nested_irq() {
#  0)  10.234 us    |      my_isr();
#  0)  12.567 us    |    }
#  0)  15.890 us    |  }

/* æ–¹æ³• 3ï¼šä½¿ç”¨ perf */
$ perf record -e irq:irq_handler_entry -e irq:irq_handler_exit -a -- sleep 10
$ perf script | grep my_device

/* æ–¹æ³• 4ï¼šä½¿ç”¨ timestamping in ISR */
#include <linux/ktime.h>

static ktime_t isr_timestamp;

static irqreturn_t my_isr(int irq, void *dev_id)
{
    ktime_t now = ktime_get();
    ktime_t delta = ktime_sub(now, priv->hw_trigger_time);
    
    pr_info("IRQ latency: %lld ns\n", ktime_to_ns(delta));
    
    return IRQ_HANDLED;
}
```

### 6.3 é™ä½ä¸­æ–·å»¶é²çš„æ–¹æ³•

```c
/* 1. é¿å…é•·æ™‚é–“ç¦ç”¨ä¸­æ–· */
/* âŒ ä¸å¥½ */
spin_lock_irqsave(&lock, flags);
do_long_operation();  /* å¯èƒ½æ•¸ ms */
spin_unlock_irqrestore(&lock, flags);

/* âœ… æ”¹é€² */
spin_lock_irqsave(&lock, flags);
quick_copy_data();
spin_unlock_irqrestore(&lock, flags);

do_long_operation_on_copy();

/* 2. ä½¿ç”¨ Threaded IRQ è®“ ISR å¯è¢«å„ªå…ˆè™•ç† */
devm_request_threaded_irq(&pdev->dev, irq, 
                          quick_primary_handler,
                          threaded_handler,
                          IRQF_ONESHOT,
                          "my-device", priv);

/* 3. è¨­å®š IRQ Thread çš„èª¿åº¦å„ªå…ˆæ¬Š */
static int my_probe(struct platform_device *pdev)
{
    struct task_struct *irq_thread;
    struct sched_param param = { .sched_priority = 50 };
    
    /* ... request_threaded_irq ... */
    
    /* å–å¾— IRQ thread */
    irq_thread = irq_get_desc(irq)->threads_handled;
    if (irq_thread) {
        sched_setscheduler(irq_thread, SCHED_FIFO, &param);
    }
    
    return 0;
}

/* 4. æ¸›å°‘ ISR ä¸­çš„å·¥ä½œ */
static irqreturn_t quick_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* åªåšæœ€å°å¿…è¦å·¥ä½œ */
    u32 status = readl(priv->base + REG_STATUS);
    writel(status, priv->base + REG_STATUS);  /* æ¸…é™¤æ——æ¨™ */
    
    priv->pending_status = status;
    
    return IRQ_WAKE_THREAD;
}

/* 5. è€ƒæ…®ä½¿ç”¨ NAPIï¼ˆç¶²è·¯é©…å‹•ï¼‰ */
/* é«˜é »ä¸­æ–·æ™‚åˆ‡æ›åˆ° polling æ¨¡å¼ */
```

### 6.4 PREEMPT_RT å°ä¸­æ–·çš„å½±éŸ¿

```c
/* PREEMPT_RT (Real-Time Linux) ç‰¹é»ï¼š
 * 
 * 1. Spinlock è®Šæˆå¯ç¡çœ 
 *    - åŸæœ¬çš„ spinlock æ”¹æˆ rt_mutex
 *    - å¯è¢«é«˜å„ªå…ˆæ¬Š task æ¶å 
 *    
 * 2. Forced Interrupt Threading
 *    - å¤§éƒ¨åˆ† hardirq handler å¼·åˆ¶è®Šæˆ threaded
 *    - å¯ä»¥ç”¨ IRQF_NO_THREAD ä¿æŒåœ¨ hardirq context
 *    
 * 3. æ›´å¯é æ¸¬çš„å»¶é²
 *    - æœ€å¤§å»¶é²å¾æ•¸ ms é™åˆ°æ•¸å Î¼s
 */

/* åœ¨ PREEMPT_RT ä¸­æŸ¥çœ‹ IRQ thread */
$ ps aux | grep irq
root         3  0.0  0.0      0     0 ?        S    10:00   0:00 [irq/33-my_dev]

/* è¨­å®š IRQ thread çš„å„ªå…ˆæ¬Š */
$ chrt -f -p 50 3  /* PID 3, FIFO priority 50 */

/* æˆ–åœ¨ driver ä¸­è¨­å®š */
int ret = request_threaded_irq(irq, NULL, my_thread_handler,
                               IRQF_TRIGGER_RISING | IRQF_ONESHOT,
                               "my-device", priv);
/* ç„¶å¾Œè¨­å®š thread å„ªå…ˆæ¬Š */
struct irq_desc *desc = irq_to_desc(irq);
if (desc && desc->action && desc->action->thread) {
    sched_set_fifo(desc->action->thread);
}
```

---

## ğŸ”· ç¬¬ä¸ƒéƒ¨åˆ†ï¼šé€²éšä¸­æ–·è™•ç†æŠ€å·§

### 7.1 Shared IRQ è™•ç†

```c
/* å¤šå€‹è£ç½®å…±ç”¨åŒä¸€å€‹ IRQ */
/* å¸¸è¦‹æ–¼ PCI è£ç½® */

static irqreturn_t my_shared_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    u32 status;
    
    /* å¿…é ˆå…ˆç¢ºèªæ˜¯å¦æ˜¯æˆ‘çš„ä¸­æ–·ï¼ */
    status = readl(priv->base + REG_STATUS);
    if (!(status & MY_IRQ_PENDING)) {
        /* ä¸æ˜¯æˆ‘çš„ä¸­æ–·ï¼Œè®“å…¶ä»– handler è™•ç† */
        return IRQ_NONE;
    }
    
    /* æ˜¯æˆ‘çš„ï¼Œè™•ç†å®ƒ */
    writel(status, priv->base + REG_STATUS);  /* æ¸…é™¤ */
    
    /* ... è™•ç†é‚è¼¯ ... */
    
    return IRQ_HANDLED;
}

/* è¨»å†Šæ™‚å¿…é ˆæŒ‡å®š IRQF_SHARED */
ret = devm_request_irq(&pdev->dev, irq, my_shared_isr,
                       IRQF_SHARED | IRQF_TRIGGER_LEVEL_HIGH,
                       "my-device", priv);

/* IRQF_SHARED çš„è¦æ±‚ï¼š
 * 1. æ‰€æœ‰å…±ç”¨æ­¤ IRQ çš„ handler éƒ½å¿…é ˆæŒ‡å®š IRQF_SHARED
 * 2. æ‰€æœ‰ handler å¿…é ˆèƒ½æ­£ç¢ºè¾¨è­˜æ˜¯å¦æ˜¯è‡ªå·±çš„ä¸­æ–·
 * 3. dev_id å¿…é ˆæ˜¯å”¯ä¸€çš„ï¼ˆä¸èƒ½æ˜¯ NULLï¼‰
 */
```

### 7.2 Nested Interrupt èˆ‡ Interrupt Chaining

```c
/* GPIO Controller ä½œç‚ºä¸­æ–·æ§åˆ¶å™¨çš„ç¯„ä¾‹ */

/* GPIO Controller çš„ ISRï¼ˆparentï¼‰ */
static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
{
    struct gpio_chip *gc = dev_id;
    u32 pending;
    int n;
    
    /* è®€å–å“ªäº› GPIO æœ‰ä¸­æ–· */
    pending = readl(gc->base + REG_INT_STATUS);
    
    while (pending) {
        n = __ffs(pending);  /* æ‰¾åˆ°ç¬¬ä¸€å€‹ set bit */
        pending &= ~BIT(n);
        
        /* å‘¼å«å°æ‡‰ GPIO çš„ handler */
        generic_handle_irq(irq_find_mapping(gc->irq.domain, n));
    }
    
    return IRQ_HANDLED;
}

/* è¨­å®š GPIO ç‚º IRQ Controller */
static int gpio_probe(struct platform_device *pdev)
{
    struct gpio_chip *gc;
    struct gpio_irq_chip *girq;
    
    /* ... åˆå§‹åŒ– gc ... */
    
    girq = &gc->irq;
    girq->chip = &gpio_irq_chip;
    girq->parent_handler = gpio_irq_handler;
    girq->num_parents = 1;
    girq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents), GFP_KERNEL);
    girq->parents[0] = platform_get_irq(pdev, 0);
    girq->default_type = IRQ_TYPE_NONE;
    girq->handler = handle_bad_irq;
    
    ret = gpiochip_add_data(gc, priv);
    
    return 0;
}

/* ä½¿ç”¨ GPIO ç”¢ç”Ÿçš„ä¸­æ–· */
/* Device Tree */
my_sensor@10 {
    compatible = "vendor,sensor";
    interrupt-parent = <&gpio1>;
    interrupts = <5 IRQ_TYPE_EDGE_RISING>;  /* GPIO1_5 */
};
```

### 7.3 Chained IRQ Handlerï¼ˆä¸­æ–·æ§åˆ¶å™¨å°ˆç”¨ï¼‰

```c
/* é©ç”¨æ–¼ç°¡å–®çš„ä¸­æ–·æ§åˆ¶å™¨ï¼Œä¸éœ€è¦ thread */

static void gpio_irq_handler_chain(struct irq_desc *desc)
{
    struct gpio_chip *gc = irq_desc_get_handler_data(desc);
    struct irq_chip *chip = irq_desc_get_chip(desc);
    u32 pending;
    int n;
    
    chained_irq_enter(chip, desc);  /* Mask parent, ACK if needed */
    
    pending = readl(gc->base + REG_INT_STATUS);
    
    while (pending) {
        n = __ffs(pending);
        pending &= ~BIT(n);
        generic_handle_irq(irq_find_mapping(gc->irq.domain, n));
    }
    
    chained_irq_exit(chip, desc);  /* Unmask parent */
}

/* è¨»å†Š */
irq_set_chained_handler_and_data(parent_irq, gpio_irq_handler_chain, gc);
```

### 7.4 IRQ Domain æ¦‚å¿µ

```c
/* IRQ Domain å°‡ç¡¬é«”ä¸­æ–·è™Ÿç¢¼æ˜ å°„åˆ° Linux virtual IRQ */

/* 
 * ç¡¬é«”ï¼š    GPIO controller pin 5 ç”¢ç”Ÿä¸­æ–·
 * Domainï¼š  å°‡ hwirq=5 æ˜ å°„åˆ° virq=45
 * Linuxï¼š   ä½¿ç”¨ virq=45 è™•ç†ä¸­æ–·
 */

/* å»ºç«‹ IRQ Domain */
#include <linux/irqdomain.h>

static const struct irq_domain_ops my_irq_domain_ops = {
    .map = my_irq_domain_map,
    .xlate = irq_domain_xlate_twocell,  /* è§£æ DT interrupts property */
};

static int my_irq_domain_map(struct irq_domain *d, unsigned int virq,
                             irq_hw_number_t hwirq)
{
    irq_set_chip_and_handler(virq, &my_irq_chip, handle_edge_irq);
    irq_set_chip_data(virq, d->host_data);
    irq_set_noprobe(virq);
    
    return 0;
}

static int my_probe(struct platform_device *pdev)
{
    struct my_irq_ctrl *ctrl;
    
    ctrl->domain = irq_domain_add_linear(pdev->dev.of_node, 
                                         NUM_IRQS,
                                         &my_irq_domain_ops, 
                                         ctrl);
    if (!ctrl->domain)
        return -ENOMEM;
    
    return 0;
}

/* å–å¾—æ˜ å°„çš„ virq */
int virq = irq_find_mapping(ctrl->domain, hwirq);
```

### 7.5 Edge vs Level Trigger çš„è™•ç†å·®ç•°

```c
/* Edge-triggered (é‚Šç·£è§¸ç™¼) */
/* åªåœ¨ä¿¡è™Ÿè®ŠåŒ–æ™‚è§¸ç™¼ä¸€æ¬¡ */

static irqreturn_t edge_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* ä¸éœ€è¦ç«‹å³æ¸…é™¤ä¸­æ–·æº */
    /* å› ç‚ºåªè§¸ç™¼ä¸€æ¬¡ */
    
    /* è™•ç†ä¸­æ–· */
    process_data(priv);
    
    return IRQ_HANDLED;
}

/* Level-triggered (é›»å¹³è§¸ç™¼) */
/* åªè¦ä¿¡è™Ÿç¶­æŒå°±æŒçºŒè§¸ç™¼ */

static irqreturn_t level_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* å¿…é ˆå…ˆè®€å–ç‹€æ…‹/æ¸…é™¤ä¸­æ–·æºï¼ */
    /* å¦å‰‡ ISR è¿”å›å¾Œæœƒç«‹å³å†æ¬¡è§¸ç™¼ */
    u32 status = readl(priv->base + REG_STATUS);
    writel(status, priv->base + REG_STATUS);
    
    /* è™•ç†ä¸­æ–· */
    process_data(priv);
    
    return IRQ_HANDLED;
}

/* Level-triggered + Threaded IRQ */
/* å¿…é ˆä½¿ç”¨ IRQF_ONESHOTï¼ */
ret = devm_request_threaded_irq(&pdev->dev, irq,
                                my_primary,
                                my_thread,
                                IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
                                "my-device", priv);

/* IRQF_ONESHOT ç¢ºä¿åœ¨ thread handler å®Œæˆå‰
 * ä¸­æ–·ä¿æŒ maskedï¼Œé¿å…ç„¡é™è§¸ç™¼ */
```

---

## ğŸ”· ç¬¬å…«éƒ¨åˆ†ï¼šGIC æš«å­˜å™¨è©³è§£

### 8.1 GICv2 ä¸»è¦æš«å­˜å™¨

```c
/* Distributor æš«å­˜å™¨ (GICD_*) */
/* åŸºåº•ä½å€é€šå¸¸åœ¨ 0x00000000 (ç›¸å°æ–¼ GIC base) */

#define GICD_CTLR           0x000  /* æ§åˆ¶æš«å­˜å™¨ */
#define GICD_TYPER          0x004  /* é¡å‹è³‡è¨Š */
#define GICD_IIDR           0x008  /* Implementer ID */
#define GICD_IGROUPn        0x080  /* ä¸­æ–·ç¾¤çµ„è¨­å®š */
#define GICD_ISENABLERn     0x100  /* ä¸­æ–· Set Enable */
#define GICD_ICENABLERn     0x180  /* ä¸­æ–· Clear Enable */
#define GICD_ISPENDRn       0x200  /* Set Pending */
#define GICD_ICPENDRn       0x280  /* Clear Pending */
#define GICD_ISACTIVERn     0x300  /* Set Active */
#define GICD_ICACTIVERn     0x380  /* Clear Active */
#define GICD_IPRIORITYRn    0x400  /* å„ªå…ˆæ¬Šè¨­å®š (8 bits per IRQ) */
#define GICD_ITARGETSRn     0x800  /* ç›®æ¨™ CPU è¨­å®š */
#define GICD_ICFGRn         0xC00  /* è§¸ç™¼é¡å‹è¨­å®š */
#define GICD_SGIR           0xF00  /* SGI è§¸ç™¼æš«å­˜å™¨ */

/* CPU Interface æš«å­˜å™¨ (GICC_*) */
/* åŸºåº•ä½å€é€šå¸¸åœ¨ 0x00010000 (ç›¸å°æ–¼ GIC base) */

#define GICC_CTLR           0x00   /* æ§åˆ¶æš«å­˜å™¨ */
#define GICC_PMR            0x04   /* Priority Mask */
#define GICC_BPR            0x08   /* Binary Point */
#define GICC_IAR            0x0C   /* Interrupt Acknowledge */
#define GICC_EOIR           0x10   /* End of Interrupt */
#define GICC_RPR            0x14   /* Running Priority */
#define GICC_HPPIR          0x18   /* Highest Priority Pending */
#define GICC_AIAR           0x20   /* Aliased Interrupt Acknowledge */
#define GICC_AEOIR          0x24   /* Aliased End of Interrupt */

/* æ“ä½œç¯„ä¾‹ï¼šå•Ÿç”¨ IRQ 64 */
#define GIC_SPI_BASE    32
#define IRQ_NUM         64
#define IRQ_INDEX       (IRQ_NUM / 32)  /* = 2 */
#define IRQ_BIT         (IRQ_NUM % 32)  /* = 0 */

/* å•Ÿç”¨ä¸­æ–· */
writel(BIT(IRQ_BIT), gic_base + GICD_ISENABLERn + IRQ_INDEX * 4);

/* è¨­å®šå„ªå…ˆæ¬Š (0=æœ€é«˜, 255=æœ€ä½) */
u8 priority = 0x80;
writeb(priority, gic_base + GICD_IPRIORITYRn + IRQ_NUM);

/* è¨­å®šç›®æ¨™ CPU (bit 0 = CPU0, bit 1 = CPU1, ...) */
u8 target = BIT(0) | BIT(1);  /* CPU 0 å’Œ 1 */
writeb(target, gic_base + GICD_ITARGETSRn + IRQ_NUM);
```

### 8.2 GICv3 ä¸»è¦å·®ç•°

```c
/* GICv3 æ–°å¢ Redistributor (GICR_*) */
/* æ¯å€‹ CPU æœ‰è‡ªå·±çš„ Redistributor */

/* System Register å­˜å– (æ›¿ä»£éƒ¨åˆ† MMIO) */
/* ä½¿ç”¨ ICC_* æš«å­˜å™¨ */

/* è®€å– IRQ è™Ÿç¢¼ */
static inline u32 gicv3_read_iar(void)
{
    u64 val;
    asm volatile("mrs %0, " __stringify(ICC_IAR1_EL1) : "=r" (val));
    return val & 0xFFFFFF;
}

/* å¯«å…¥ EOI */
static inline void gicv3_write_eoir(u32 irq)
{
    asm volatile("msr " __stringify(ICC_EOIR1_EL1) ", %0" : : "r" ((u64)irq));
}

/* è¨­å®š Priority Mask */
static inline void gicv3_write_pmr(u32 val)
{
    asm volatile("msr " __stringify(ICC_PMR_EL1) ", %0" : : "r" ((u64)val));
}

/* GICv3 ä¸­æ–·è™•ç†æµç¨‹ */
static void gicv3_handle_irq(struct pt_regs *regs)
{
    u32 irqnr;
    
    while (1) {
        irqnr = gicv3_read_iar();
        
        if (irqnr == GICC_INT_SPURIOUS)
            break;
        
        /* å…ˆå¯« EOIï¼ˆå¯é…ç½®æ˜¯å¦æå‰å¯«ï¼‰ */
        gicv3_write_eoir(irqnr);
        
        /* è™•ç†ä¸­æ–· */
        handle_domain_irq(gic_data.domain, irqnr, regs);
    }
}
```

---

## ğŸ“ æ›´å¤šé¢è©¦é¡Œåº«

### Q9: è§£é‡‹ IRQ_NONEã€IRQ_HANDLEDã€IRQ_WAKE_THREAD çš„å€åˆ¥

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š

```c
typedef enum irqreturn {
    IRQ_NONE        = (0 << 0),  /* ä¸æ˜¯æˆ‘çš„ä¸­æ–· */
    IRQ_HANDLED     = (1 << 0),  /* ä¸­æ–·å·²è™•ç†å®Œæˆ */
    IRQ_WAKE_THREAD = (1 << 1),  /* å–šé†’ thread handler */
} irqreturn_t;
```

| è¿”å›å€¼ | æ„ç¾© | ä½¿ç”¨å ´æ™¯ |
|:---|:---|:---|
| IRQ_NONE | é€™ä¸æ˜¯æˆ‘çš„ä¸­æ–· | Shared IRQ å¿…é ˆæ­£ç¢ºåˆ¤æ–· |
| IRQ_HANDLED | ä¸­æ–·å·²è™•ç†å®Œæˆ | ä¸€èˆ¬ ISR |
| IRQ_WAKE_THREAD | Top-half å®Œæˆï¼Œå–šé†’ Thread | Threaded IRQ |

**éŒ¯èª¤ä½¿ç”¨çš„å¾Œæœ**ï¼š
- éŒ¯èª¤å›å‚³ `IRQ_NONE`ï¼šKernel å¯èƒ½èªç‚ºä¸­æ–·ç„¡äººè™•ç†
- é€£çºŒçš„ `IRQ_NONE` æœƒè§¸ç™¼ "IRQ nobody cared" è­¦å‘Š
- ä¸­æ–·æœ€çµ‚å¯èƒ½è¢«ç¦ç”¨

---

### Q10: ä»€éº¼æ˜¯ Spurious Interruptï¼Ÿå¦‚ä½•è™•ç†ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šIntel / AMD

**ç­”æ¡ˆ**ï¼š

Spurious Interrupt æ˜¯æŒ‡ã€Œå‡çš„ã€æˆ–ã€Œä¸æ‡‰è©²ç™¼ç”Ÿçš„ã€ä¸­æ–·ã€‚

**ç”¢ç”ŸåŸå› **ï¼š
1. ç¡¬é«” glitch
2. ä¸­æ–·æºåœ¨ ACK å‰è¢«æ¸…é™¤
3. ç«¶çˆ­æ¢ä»¶ï¼ˆrace conditionï¼‰
4. é›»æ°£å™ªè²

**GIC çš„ Spurious IRQ**ï¼š
- IRQ è™Ÿç¢¼ 1023ï¼ˆGICv2ï¼‰æˆ– 1020-1023ï¼ˆGICv3ï¼‰
- è¡¨ç¤ºæ²’æœ‰ pending ä¸­æ–·

```c
/* Kernel çš„è™•ç† */
static void handle_bad_irq(struct irq_desc *desc)
{
    atomic_inc(&irq_err_count);
    ack_bad_irq(irq);
    
    /* "nobody cared" æ©Ÿåˆ¶ */
    if (printk_ratelimit())
        printk(KERN_CRIT "Spurious IRQ %d\n", irq);
}

/* åœ¨ Driver ä¸­ */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    u32 status = readl(priv->base + REG_STATUS);
    
    if (!status) {
        /* Spuriousï¼Œæ²’æœ‰å¯¦éš›çš„ä¸­æ–· */
        dev_dbg(dev, "Spurious IRQ received\n");
        return IRQ_NONE;
    }
    
    /* æ­£å¸¸è™•ç† */
    return IRQ_HANDLED;
}
```

---

### Q11: disable_irq() å’Œ disable_irq_nosync() çš„å€åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šè¯ç™¼ç§‘ / MediaTek

**ç­”æ¡ˆ**ï¼š

```c
/* disable_irq() */
/* 1. ç¦ç”¨æŒ‡å®š IRQ */
/* 2. ç­‰å¾…ç•¶å‰æ­£åœ¨åŸ·è¡Œçš„ handler å®Œæˆ */
/* 3. å¯èƒ½ç¡çœ ï¼ä¸èƒ½åœ¨ atomic context ä½¿ç”¨ */

/* disable_irq_nosync() */
/* 1. ç¦ç”¨æŒ‡å®š IRQ */
/* 2. ä¸ç­‰å¾…ï¼Œç«‹å³è¿”å› */
/* 3. ä¸æœƒç¡çœ ï¼Œå¯åœ¨ atomic context ä½¿ç”¨ */
```

**ä½¿ç”¨å ´æ™¯**ï¼š

| API | é©ç”¨å ´æ™¯ |
|:---|:---|
| disable_irq() | åœ¨ process contextï¼Œéœ€è¦ç¢ºä¿ ISR ä¸å†åŸ·è¡Œ |
| disable_irq_nosync() | åœ¨ ISR ä¸­ç¦ç”¨è‡ªå·±ï¼Œæˆ–éœ€è¦å¿«é€Ÿè¿”å› |

**å±éšªç¯„ä¾‹**ï¼š
```c
/* âŒ å¯èƒ½ deadlock */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    disable_irq(irq);  /* ç­‰å¾…è‡ªå·±å®Œæˆ... æ°¸é ä¸æœƒ */
    return IRQ_HANDLED;
}

/* âœ… æ­£ç¢º */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    disable_irq_nosync(irq);  /* ç«‹å³è¿”å› */
    schedule_work(&cleanup_work);
    return IRQ_HANDLED;
}
```

---

### Q12: å¦‚ä½•é¿å… "IRQ nobody cared" å•é¡Œï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ¯å®¶å…¬å¸

**ç­”æ¡ˆ**ï¼š

ç•¶åŒä¸€å€‹ IRQ é€£çºŒ 99900 æ¬¡æ”¶åˆ° IRQ_NONEï¼ˆå…±ç”¨ IRQï¼‰æ™‚ï¼ŒKernel æœƒå ±éŒ¯ä¸¦ç¦ç”¨è©² IRQã€‚

```
irq 33: nobody cared (try booting with the "irqpoll" option)
Disabling IRQ #33
```

**åŸå› **ï¼š
1. ç¡¬é«”å•é¡Œï¼ˆä¸­æ–·ä¸€ç›´ activeï¼‰
2. Driver æ²’æœ‰æ­£ç¢ºæ¸…é™¤ä¸­æ–·æº
3. Shared IRQ ä¸­æ²’æœ‰ä»»ä½• handler èªé ˜

**è§£æ±ºæ–¹æ³•**ï¼š

```c
/* 1. ç¢ºä¿æ­£ç¢ºè­˜åˆ¥è‡ªå·±çš„ä¸­æ–· */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    u32 status = readl(priv->base + REG_INT_STATUS);
    
    if (!(status & MY_IRQ_PENDING))
        return IRQ_NONE;  /* çœŸçš„ä¸æ˜¯æˆ‘çš„ */
    
    /* 2. ç¢ºä¿æ¸…é™¤ä¸­æ–·æº */
    writel(status, priv->base + REG_INT_STATUS);
    
    return IRQ_HANDLED;
}

/* 3. Debug æ™‚å¯ä»¥ä½¿ç”¨ irqpoll */
/* Kernel command line: irqpoll */

/* 4. æª¢æŸ¥ç¡¬é«”æ˜¯å¦æœ‰å•é¡Œ */
/* - ç”¨ç¤ºæ³¢å™¨çœ‹ä¸­æ–·ä¿¡è™Ÿæ˜¯å¦ç•°å¸¸ */
/* - ç¢ºèª Device Tree ä¸­è§¸ç™¼é¡å‹æ­£ç¢º */
```

---

### Q13: ä¸­æ–·è™•ç†ä¸­å¯ä»¥ä½¿ç”¨ printk å—ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šå¿«é€Ÿé¢è©¦é¡Œ

**ç­”æ¡ˆ**ï¼š

**å¯ä»¥ï¼Œä½†æœ‰é™åˆ¶**ï¼š

1. **printk æœ¬èº«æ˜¯å®‰å…¨çš„**
   - ä½¿ç”¨ lockless ring buffer
   - ä¸æœƒç¡çœ 

2. **ä½†å¯èƒ½é€ æˆå•é¡Œ**ï¼š
   - é«˜é »ä¸­æ–· + printk = console flood
   - å½±éŸ¿ç³»çµ±æ•ˆèƒ½
   - è¼¸å‡ºå¯èƒ½å»¶é²ï¼ˆconsole bufferï¼‰

3. **å»ºè­°åšæ³•**ï¼š
```c
static irqreturn_t my_isr(int irq, void *dev_id)
{
    /* âŒ ä¸å»ºè­°ç”¨æ–¼é«˜é »ä¸­æ–· */
    printk(KERN_INFO "IRQ received\n");
    
    /* âœ… ä½¿ç”¨ rate limiting */
    if (printk_ratelimit())
        printk(KERN_INFO "IRQ received\n");
    
    /* âœ… ä½¿ç”¨ trace_printkï¼ˆä¸è¼¸å‡ºåˆ° consoleï¼‰ */
    trace_printk("IRQ received\n");
    
    /* âœ… ä½¿ç”¨ dev_dbgï¼ˆå¯å‹•æ…‹é–‹é—œï¼‰ */
    dev_dbg(dev, "IRQ received\n");
    
    return IRQ_HANDLED;
}
```

---

### Q14: ä»€éº¼æ˜¯ NMI (Non-Maskable Interrupt)ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šIntel / System Programming

**ç­”æ¡ˆ**ï¼š

NMI æ˜¯ä¸èƒ½è¢«è»Ÿé«”ç¦ç”¨çš„ä¸­æ–·ï¼Œç”¨æ–¼é—œéµäº‹ä»¶ã€‚

**ç”¨é€”**ï¼š
1. ç¡¬é«”éŒ¯èª¤ï¼ˆMemory parity errorï¼‰
2. Watchdog timeout
3. Debug break
4. Thermal emergency

**x86 ç‰¹é»**ï¼š
```c
/* x86 NMI handler */
dotraplinkage void do_nmi(struct pt_regs *regs, long error_code)
{
    /* NMI ä¸­å¯ä»¥åšçš„äº‹æƒ…éå¸¸æœ‰é™ */
    /* å› ç‚ºå¯èƒ½åœ¨ä»»ä½•ç‹€æ…‹è¢«è§¸ç™¼ */
    
    nmi_enter();
    
    /* è™•ç† NMI ä¾†æº */
    
    nmi_exit();
}
```

**ARM çš„ FIQ**ï¼š
- ARM æœ‰ FIQ (Fast Interrupt Request)
- å„ªå…ˆæ¬Šé«˜æ–¼ä¸€èˆ¬ IRQ
- ä½†ä¸æ˜¯çœŸæ­£çš„ NMIï¼ˆå¯ä»¥è¢«ç¦ç”¨ï¼‰

---

### Q15: è§£é‡‹ request_irq çš„ dev_id åƒæ•¸ç”¨é€”

**é›£åº¦**ï¼šâ­â­â­
**å¸¸è¦‹æ–¼**ï¼šåŸºç¤é¡Œ

**ç­”æ¡ˆ**ï¼š

```c
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev_id);  /* æœƒå‚³çµ¦ handler */
```

**ç”¨é€”**ï¼š
1. **å‚³é driver ç§æœ‰è³‡æ–™**çµ¦ ISR
2. **Shared IRQ å¿…é ˆå”¯ä¸€**ç”¨æ–¼å€åˆ†
3. **free_irq æ™‚ç”¨æ–¼åŒ¹é…**

```c
/* ä½¿ç”¨ç¯„ä¾‹ */
struct my_device *priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);

request_irq(irq, my_isr, IRQF_SHARED, "my-dev", priv);

/* ISR ä¸­å–å¾— */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;  /* é‚„åŸæŒ‡æ¨™é¡å‹ */
    
    /* ä½¿ç”¨ priv */
    
    return IRQ_HANDLED;
}

/* é‡‹æ”¾æ™‚å¿…é ˆç”¨ç›¸åŒçš„ dev_id */
free_irq(irq, priv);

/* âŒ éŒ¯èª¤ï¼šShared IRQ ç”¨ NULL */
request_irq(irq, my_isr, IRQF_SHARED, "my-dev", NULL);
/* Kernel æœƒæ‹’çµ•è¨»å†Šï¼ */
```

---

### Q16: ä»€éº¼æ˜¯ Interrupt Stormï¼Ÿå¦‚ä½•é˜²æ­¢ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / é«˜éšè·ä½

**ç­”æ¡ˆ**ï¼š

Interrupt Storm æ˜¯æŒ‡ä¸­æ–·ä»¥æ¥µé«˜é »ç‡è§¸ç™¼ï¼Œå°è‡´ç³»çµ±å¹¾ä¹æŠŠæ‰€æœ‰æ™‚é–“èŠ±åœ¨è™•ç†ä¸­æ–·ä¸Šã€‚

**åŸå› **ï¼š
1. ç¡¬é«”æ•…éšœï¼ˆä¿¡è™Ÿä¸€ç›´ activeï¼‰
2. Driver bugï¼ˆæ²’æ¸…é™¤ä¸­æ–·æºï¼‰
3. æ”»æ“Šï¼ˆç¶²è·¯ DoSï¼‰

**é˜²æ­¢æ–¹æ³•**ï¼š

```c
/* 1. Interrupt Coalescing */
/* å¤šå€‹äº‹ä»¶ç´¯ç©å¾Œæ‰è§¸ç™¼ä¸€æ¬¡ä¸­æ–· */
writel(10, priv->base + REG_INT_THRESHOLD);  /* æ¯ 10 å€‹äº‹ä»¶ */

/* 2. Rate Limiting */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    static int count = 0;
    static unsigned long last_jiffies = 0;
    
    count++;
    if (time_after(jiffies, last_jiffies + HZ)) {
        if (count > 10000) {
            dev_warn(dev, "IRQ storm detected! %d IRQs/sec\n", count);
            disable_irq_nosync(irq);
        }
        count = 0;
        last_jiffies = jiffies;
    }
    
    /* ... è™•ç† ... */
    return IRQ_HANDLED;
}

/* 3. NAPI (Network) */
/* é«˜è² è¼‰æ™‚åˆ‡æ›åˆ° polling æ¨¡å¼ */
static irqreturn_t eth_isr(int irq, void *dev_id)
{
    if (napi_schedule_prep(&priv->napi)) {
        disable_irq_nosync(irq);
        __napi_schedule(&priv->napi);
    }
    return IRQ_HANDLED;
}

/* 4. Kernel çš„å…§å»ºä¿è­· */
/* é€£çºŒ 100000 æ¬¡ IRQ_NONE æœƒç¦ç”¨ IRQ */
```

---

### Q17: Threaded IRQ çš„ Primary Handler å¯ä»¥å›å‚³ä»€éº¼å€¼ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š

```c
static irqreturn_t primary_handler(int irq, void *dev_id);
/* Primary handler å¯ä»¥å›å‚³ï¼š */

/* 1. IRQ_NONE - ä¸æ˜¯æˆ‘çš„ä¸­æ–· */
/*    Thread handler ä¸æœƒè¢«å–šé†’ */

/* 2. IRQ_HANDLED - ä¸­æ–·å·²å®Œå…¨è™•ç† */
/*    Thread handler ä¸æœƒè¢«å–šé†’ */

/* 3. IRQ_WAKE_THREAD - å–šé†’ thread handler */
/*    Thread handler æœƒè¢«æ’ç¨‹åŸ·è¡Œ */

/* Primary handler ä¹Ÿå¯ä»¥æ˜¯ NULL */
ret = request_threaded_irq(irq, 
                           NULL,              /* æ²’æœ‰ primary handler */
                           my_thread_handler, /* åªæœ‰ thread handler */
                           IRQF_ONESHOT,
                           "my-dev", priv);
/* é€™ç­‰æ–¼ request_irq + IRQF_ONESHOTï¼Œæ•´å€‹ handler åœ¨ thread ä¸­åŸ·è¡Œ */
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **Kernel æ–‡ä»¶**
   - Documentation/core-api/genericirq.rst
   - Documentation/core-api/workqueue.rst

2. **ARM æ–‡ä»¶**
   - ARM GIC Architecture Specification
   - ARM Cortex-A Programmer's Guide

3. **ç·šä¸Šè³‡æº**
   - [Bootlin Interrupt Training](https://bootlin.com/doc/training/linux-kernel/linux-kernel-slides.pdf)

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/03_åº•å±¤é©…å‹•é–‹ç™¼/ä¸­æ–·è™•ç†.md`
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 1000 è¡Œ
- æ¶µè“‹ï¼š
  - âœ… Top-half / Bottom-half å®Œæ•´æ©Ÿåˆ¶
  - âœ… Softirq / Tasklet / Workqueue / Threaded IRQ è©³è§£èˆ‡æ¯”è¼ƒ
  - âœ… IRQ API å®Œæ•´èªªæ˜ (request_irq / devm_request_threaded_irq)
  - âœ… GIC æ¶æ§‹ï¼ˆGICv2/v3 å€åˆ¥ï¼‰
  - âœ… SGI / PPI / SPI ä¸­æ–·é¡å‹
  - âœ… IRQ Affinity è¨­å®š
  - âœ… è‡¨ç•Œå€æ®µèˆ‡åŒæ­¥ï¼ˆspinlockã€volatileã€memory barrierï¼‰
  - âœ… 8 é“é¢è©¦é¡Œ
