# ğŸ”” ä¸­æ–·è™•ç†ï¼ˆInterruptï¼‰å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. ç†è§£ä¸­æ–·çš„åŸºæœ¬åŸç†èˆ‡è™•ç†æµç¨‹
> 2. æŒæ¡ Linux Kernel çš„ Top-half / Bottom-half æ©Ÿåˆ¶
> 3. ç†Ÿç·´ä½¿ç”¨ taskletã€workqueueã€threaded IRQ
> 4. ç†è§£ GIC æ¶æ§‹èˆ‡ä¸­æ–·è¦ªå’Œæ€§è¨­å®š

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šä¸­æ–·åŸºç¤

### 1.1 ä»€éº¼æ˜¯ä¸­æ–·ï¼Ÿ

```
ä¸­æ–·æ˜¯ä¸€ç¨®æ©Ÿåˆ¶ï¼Œè®“ç¡¬é«”å¯ä»¥ã€Œæ‰“æ–·ã€CPU æ­£åœ¨åŸ·è¡Œçš„ç¨‹å¼ï¼Œ
å»è™•ç†æ›´ç·Šæ€¥çš„äº‹ä»¶ï¼Œè™•ç†å®Œå¾Œå†å›åˆ°åŸç¨‹å¼ç¹¼çºŒåŸ·è¡Œã€‚

é¡æ¯”ï¼šä½ æ­£åœ¨å¯«ç¨‹å¼ï¼ˆä¸»ç¨‹å¼ï¼‰ï¼Œé›»è©±éŸ¿äº†ï¼ˆä¸­æ–·ç™¼ç”Ÿï¼‰ï¼Œ
æ¥èµ·é›»è©±è™•ç†ï¼ˆISRï¼‰ï¼Œæ›æ‰å¾Œå›ä¾†ç¹¼çºŒå¯«ç¨‹å¼ï¼ˆè¿”å›ï¼‰ã€‚
```

### 1.2 ä¸­æ–·é¡å‹

| é¡å‹ | ä¾†æº | ç¯„ä¾‹ |
|:---|:---|:---|
| ç¡¬é«”ä¸­æ–· | å¤–éƒ¨ç¡¬é«”äº‹ä»¶ | GPIOã€Timerã€UART |
| è»Ÿé«”ä¸­æ–· | ç¨‹å¼æŒ‡ä»¤è§¸ç™¼ | ç³»çµ±å‘¼å«ã€SVC æŒ‡ä»¤ |
| ä¾‹å¤– | CPU åŸ·è¡Œç•°å¸¸ | é™¤ä»¥é›¶ã€éæ³•å­˜å– |

### 1.3 ä¸­æ–·è™•ç†æµç¨‹

```
1. ä¸­æ–·ç™¼ç”Ÿ
   â†“
2. CPU å®Œæˆç•¶å‰æŒ‡ä»¤
   â†“
3. ä¿å­˜ Context (PCã€æš«å­˜å™¨ã€ç‹€æ…‹)
   â†“
4. æŸ¥è©¢ä¸­æ–·å‘é‡è¡¨
   â†“
5. è·³è½‰åˆ° ISR
   â†“
6. åŸ·è¡Œ ISR
   â†“
7. æ¢å¾© Context
   â†“
8. è¿”å›åŸç¨‹å¼
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šLinux Kernel ä¸­æ–·æ©Ÿåˆ¶

### 2.1 Top-half vs Bottom-half

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Top-half (ç¡¬ä¸­æ–·)                          â”‚
â”‚  - ä¸­æ–·ç™¼ç”Ÿå¾Œç«‹å³åŸ·è¡Œ                                          â”‚
â”‚  - åœ¨ Interrupt Context ä¸­åŸ·è¡Œ                                â”‚
â”‚  - ä¸èƒ½ç¡çœ  (sleep)ã€ä¸èƒ½ä½¿ç”¨ mutex                           â”‚
â”‚  - å¿…é ˆç›¡å¯èƒ½å¿«é€Ÿå®Œæˆ                                          â”‚
â”‚  - ä¸»è¦å·¥ä½œï¼šç¢ºèªä¸­æ–·ä¾†æºã€æ¸…é™¤ä¸­æ–·æ——æ¨™ã€æ’ç¨‹ Bottom-half       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Bottom-half (å»¶é²è™•ç†)                      â”‚
â”‚  - ç¨å¾ŒåŸ·è¡Œï¼Œè™•ç†è€—æ™‚å·¥ä½œ                                      â”‚
â”‚  - ä¸‰ç¨®æ©Ÿåˆ¶ï¼šSoftirqã€Taskletã€Workqueue                      â”‚
â”‚  - Taskletï¼šä¸èƒ½ç¡çœ ï¼Œåœ¨ Softirq Context                      â”‚
â”‚  - Workqueueï¼šå¯ä»¥ç¡çœ ï¼Œåœ¨ Process Context                    â”‚
â”‚  - Threaded IRQï¼šå¯ä»¥ç¡çœ ï¼Œå°ˆç”¨ Kernel Thread                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Softirqï¼ˆæœ€åº•å±¤ï¼Œdriver é€šå¸¸ä¸ç›´æ¥ç”¨ï¼‰

```c
/* Softirq æ˜¯ Kernel å…§éƒ¨ä½¿ç”¨çš„åº•å±¤æ©Ÿåˆ¶
 * å…±æœ‰å›ºå®šæ•¸é‡çš„ Softirq é¡å‹ï¼ˆå¦‚ NET_TXã€NET_RXã€TASKLETï¼‰
 * Driver é–‹ç™¼è€…é€šå¸¸ä½¿ç”¨ Tasklet æˆ– Workqueue
 */

enum {
    HI_SOFTIRQ = 0,     /* é«˜å„ªå…ˆæ¬Š tasklet */
    TIMER_SOFTIRQ,      /* Timer */
    NET_TX_SOFTIRQ,     /* ç¶²è·¯ç™¼é€ */
    NET_RX_SOFTIRQ,     /* ç¶²è·¯æ¥æ”¶ */
    TASKLET_SOFTIRQ,    /* ä¸€èˆ¬ tasklet */
    /* ... */
};
```

### 2.3 Tasklet

```c
#include <linux/interrupt.h>

/* Tasklet ç‰¹é»ï¼š
 * - åœ¨ Softirq Context åŸ·è¡Œï¼ˆä¸èƒ½ç¡çœ ï¼‰
 * - åŒä¸€å€‹ Tasklet ä¸æœƒåŒæ™‚åœ¨å¤šå€‹ CPU åŸ·è¡Œ
 * - è¼•é‡ç´šï¼Œé©åˆå¿«é€Ÿè™•ç†
 */

/* å®šç¾© tasklet */
static void my_tasklet_func(unsigned long data)
{
    struct my_device *priv = (struct my_device *)data;
    /* è™•ç†å·¥ä½œï¼Œä½†ä¸èƒ½ç¡çœ ï¼ */
    pr_info("Tasklet executed\n");
}

static DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);

/* åœ¨ ISR ä¸­æ’ç¨‹ tasklet */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    /* Top-halfï¼šå¿«é€Ÿè™•ç† */
    clear_interrupt_flag();
    
    /* æ’ç¨‹ Bottom-half */
    tasklet_schedule(&my_tasklet);
    
    return IRQ_HANDLED;
}
```

### 2.4 Workqueue

```c
#include <linux/workqueue.h>

/* Workqueue ç‰¹é»ï¼š
 * - åœ¨ Process Context åŸ·è¡Œï¼ˆå¯ä»¥ç¡çœ ï¼ï¼‰
 * - å¯ä»¥ä½¿ç”¨ mutexã€åš I/O æ“ä½œ
 * - é©åˆè€—æ™‚å·¥ä½œ
 */

/* å®šç¾© work */
static void my_work_func(struct work_struct *work)
{
    struct my_device *priv = container_of(work, struct my_device, my_work);
    
    /* å¯ä»¥ç¡çœ ï¼å¯ä»¥ä½¿ç”¨ mutexï¼ */
    mutex_lock(&priv->lock);
    /* è™•ç†è€—æ™‚å·¥ä½œ */
    mutex_unlock(&priv->lock);
}

struct my_device {
    struct work_struct my_work;
    struct mutex lock;
};

/* åˆå§‹åŒ– */
static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    
    INIT_WORK(&priv->my_work, my_work_func);
    mutex_init(&priv->lock);
    
    return 0;
}

/* åœ¨ ISR ä¸­æ’ç¨‹ work */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    clear_interrupt_flag();
    schedule_work(&priv->my_work);  /* æ’ç¨‹åˆ° system workqueue */
    
    return IRQ_HANDLED;
}
```

### 2.5 Threaded IRQï¼ˆæ¨è–¦ç”¨æ³•ï¼‰

```c
/* Threaded IRQ ç‰¹é»ï¼š
 * - Bottom-half åœ¨å°ˆç”¨ Kernel Thread åŸ·è¡Œ
 * - å¯ä»¥ç¡çœ 
 * - ç¨‹å¼ç¢¼æ›´ç°¡æ½”
 * - ç¾ä»£ Driver æ¨è–¦ä½¿ç”¨
 */

static irqreturn_t my_isr_top(int irq, void *dev_id)
{
    /* Top-halfï¼šå¿«é€Ÿç¢ºèªä¸­æ–· */
    if (!is_my_interrupt())
        return IRQ_NONE;
    
    return IRQ_WAKE_THREAD;  /* å–šé†’ thread handler */
}

static irqreturn_t my_isr_thread(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* Bottom-halfï¼šå¯ä»¥ç¡çœ ï¼ */
    mutex_lock(&priv->lock);
    /* è™•ç†å·¥ä½œ */
    mutex_unlock(&priv->lock);
    
    return IRQ_HANDLED;
}

/* è¨»å†Š */
static int my_probe(struct platform_device *pdev)
{
    ret = devm_request_threaded_irq(&pdev->dev, irq,
                                    my_isr_top,    /* Top-half */
                                    my_isr_thread, /* Bottom-half */
                                    IRQF_ONESHOT,
                                    "my-device", priv);
}
```

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¸­æ–· API

### 3.1 request_irq vs devm_request_irq

```c
/* request_irqï¼šéœ€è¦æ‰‹å‹•é‡‹æ”¾ */
ret = request_irq(irq, handler, flags, name, dev);
/* ... */
free_irq(irq, dev);  /* å¿…é ˆåœ¨ remove æ™‚å‘¼å« */

/* devm_request_irqï¼šè‡ªå‹•ç®¡ç†ç”Ÿå‘½é€±æœŸï¼ˆæ¨è–¦ï¼‰ */
ret = devm_request_irq(&pdev->dev, irq, handler, flags, name, dev);
/* ä¸éœ€è¦æ‰‹å‹• free_irqï¼Œdevice ç§»é™¤æ™‚è‡ªå‹•é‡‹æ”¾ */
```

### 3.2 å¸¸ç”¨ flags

```c
IRQF_SHARED       /* å¤šå€‹ device å…±ç”¨åŒä¸€å€‹ IRQ */
IRQF_TRIGGER_RISING   /* ä¸Šå‡ç·£è§¸ç™¼ */
IRQF_TRIGGER_FALLING  /* ä¸‹é™ç·£è§¸ç™¼ */
IRQF_TRIGGER_HIGH     /* é«˜é›»å¹³è§¸ç™¼ */
IRQF_TRIGGER_LOW      /* ä½é›»å¹³è§¸ç™¼ */
IRQF_ONESHOT      /* Threaded IRQï¼šè™•ç†å®Œæ‰é‡æ–°å•Ÿç”¨ä¸­æ–· */
```

### 3.3 Interrupt Context åˆ¤æ–·

```c
/* åˆ¤æ–·ç•¶å‰æ˜¯å¦åœ¨ Interrupt Context */
if (in_interrupt()) {
    /* åœ¨ä¸­æ–·ä¸Šä¸‹æ–‡ï¼Œä¸èƒ½ç¡çœ ï¼ */
}

if (in_irq()) {
    /* åœ¨ç¡¬ä¸­æ–·è™•ç†ä¸­ (Top-half) */
}

if (in_softirq()) {
    /* åœ¨ Softirq/Tasklet ä¸­ */
}

/* å¯ä»¥å‘¼å«å¯èƒ½ç¡çœ çš„å‡½å¼å—ï¼Ÿ */
if (can_sleep()) {
    mutex_lock(&lock);
}
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šGIC æ¶æ§‹ï¼ˆARMï¼‰

### 4.1 GIC æ¦‚è¿°

```
GIC (Generic Interrupt Controller) æ˜¯ ARM çš„ä¸­æ–·æ§åˆ¶å™¨æ¨™æº–ã€‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        GIC æ¶æ§‹                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Peripheral â†’ Distributor â†’ CPU Interface â†’ CPU Core        â”‚
â”‚                                                              â”‚
â”‚  Distributorï¼š                                               â”‚
â”‚    - æ”¶é›†æ‰€æœ‰ä¸­æ–·ä¾†æº                                         â”‚
â”‚    - æ±ºå®šä¸­æ–·å„ªå…ˆæ¬Š                                           â”‚
â”‚    - åˆ†ç™¼åˆ°ç›®æ¨™ CPU                                           â”‚
â”‚                                                              â”‚
â”‚  CPU Interfaceï¼š                                             â”‚
â”‚    - æ¯å€‹ CPU ä¸€å€‹                                           â”‚
â”‚    - å‘ CPU ç™¼å‡ºä¸­æ–·è«‹æ±‚                                      â”‚
â”‚    - è™•ç†ä¸­æ–·ç¢ºèª (ACK) å’ŒçµæŸ (EOI)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 GICv3 (ARMv8)

```c
/* GICv3 æ–°å¢ Redistributor */
/*
 * Peripheral â†’ Distributor â†’ Redistributor â†’ CPU Interface â†’ CPU
 *                            (æ¯å€‹ CPU ä¸€å€‹)
 */

/* ä¸­æ–·é¡å‹ï¼š
 * SPI (Shared Peripheral Interrupt): 32-1019ï¼Œå¯åˆ†ç™¼åˆ°ä»»ä½• CPU
 * PPI (Private Peripheral Interrupt): 16-31ï¼Œæ¯å€‹ CPU ç§æœ‰
 * SGI (Software Generated Interrupt): 0-15ï¼Œç”¨æ–¼ CPU é–“é€šè¨Š
 */
```

### 4.3 ä¸­æ–·è¦ªå’Œæ€§ (IRQ Affinity)

```c
/* è¨­å®šä¸­æ–·ç”±å“ªå€‹ CPU è™•ç† */
#include <linux/interrupt.h>

/* è¨­å®šè¦ªå’Œæ€§ */
cpumask_t mask;
cpumask_clear(&mask);
cpumask_set_cpu(2, &mask);  /* åªè®“ CPU 2 è™•ç† */
irq_set_affinity(irq, &mask);

/* åœ¨ /proc ä¸­æŸ¥çœ‹å’Œè¨­å®š */
/* cat /proc/irq/XX/smp_affinity */
/* echo 4 > /proc/irq/XX/smp_affinity */  /* åªè®“ CPU 2 è™•ç† */
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šè‡¨ç•Œå€æ®µèˆ‡ volatile

### 5.1 ç‚ºä»€éº¼éœ€è¦ç¦ç”¨ä¸­æ–·ï¼Ÿ

```c
/* Race Condition ç¯„ä¾‹ */
volatile int shared_counter = 0;

void ISR(void) {
    shared_counter++;  /* è®€-æ”¹-å¯« */
}

void main_loop(void) {
    shared_counter++;  /* å¦‚æœåœ¨ä¸­é–“è¢« ISR æ‰“æ–·ï¼Ÿ */
}

/* è§£æ±ºæ–¹æ¡ˆï¼šç¦ç”¨ä¸­æ–· */
void safe_increment(void) {
    unsigned long flags;
    local_irq_save(flags);    /* ç¦ç”¨ä¸­æ–·ä¸¦ä¿å­˜ç‹€æ…‹ */
    shared_counter++;
    local_irq_restore(flags); /* æ¢å¾©ä¹‹å‰çš„ç‹€æ…‹ */
}
```

### 5.2 Linux Kernel ä¸­çš„ç¦ç”¨ä¸­æ–·

```c
/* ç¦ç”¨æœ¬åœ° CPU ä¸­æ–· */
local_irq_disable();
/* ... */
local_irq_enable();

/* ä¿å­˜å’Œæ¢å¾©ç‹€æ…‹ï¼ˆæ›´å®‰å…¨ï¼Œæ”¯æ´å·¢ç‹€ï¼‰ */
unsigned long flags;
local_irq_save(flags);
/* ... */
local_irq_restore(flags);

/* Spinlock + ç¦ç”¨ä¸­æ–·ï¼ˆæœ€å¸¸ç”¨ï¼‰ */
spin_lock_irqsave(&lock, flags);
/* ... */
spin_unlock_irqrestore(&lock, flags);
```

### 5.3 volatile é—œéµå­—

```c
/* volatile å‘Šè¨´ç·¨è­¯å™¨ï¼šä¸è¦å„ªåŒ–ï¼Œæ¯æ¬¡éƒ½å¾è¨˜æ†¶é«”è®€å– */

volatile int flag = 0;

void ISR(void) {
    flag = 1;
}

int main(void) {
    while (flag == 0) {
        /* æ²’æœ‰ volatileï¼Œç·¨è­¯å™¨å¯èƒ½åªè®€ä¸€æ¬¡ */
    }
}

/* ä½¿ç”¨å ´æ™¯ï¼š
 * 1. ISR å’Œä¸»ç¨‹å¼å…±äº«çš„è®Šæ•¸
 * 2. ç¡¬é«”æš«å­˜å™¨
 * 3. å¤šåŸ·è¡Œç·’å…±äº«è®Šæ•¸ï¼ˆä½†æ›´å»ºè­°ç”¨ atomicï¼‰
 */
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Top-half å’Œ Bottom-half çš„å€åˆ¥ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘

**ç­”æ¡ˆ**ï¼š
| ç‰¹æ€§ | Top-half | Bottom-half |
|:---|:---|:---|
| åŸ·è¡Œæ™‚æ©Ÿ | ç«‹å³ | ç¨å¾Œ |
| Context | Interrupt | Softirq/Process |
| å¯å¦ç¡çœ  | âŒ | Tasklet âŒ, Workqueue âœ… |
| å…¸å‹å·¥ä½œ | æ¸…é™¤æ——æ¨™ã€æ’ç¨‹ | è³‡æ–™è™•ç† |

### Q2: Tasklet vs Workqueueï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
- **Tasklet**ï¼šSoftirq Contextï¼Œä¸èƒ½ç¡çœ ï¼Œè¼•é‡å¿«é€Ÿ
- **Workqueue**ï¼šProcess Contextï¼Œå¯ä»¥ç¡çœ ï¼Œé©åˆè€—æ™‚æ“ä½œ

### Q3: ä»€éº¼æ™‚å€™ç”¨ Threaded IRQï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
- éœ€è¦åœ¨ä¸­æ–·è™•ç†ä¸­ä½¿ç”¨ mutex æˆ–åš I/O
- ç¾ä»£ Driver æ¨è–¦åšæ³•
- ç¨‹å¼ç¢¼æ›´ç°¡æ½”ï¼ŒTop-half åªç¢ºèªä¸­æ–·ï¼ŒBottom-half åšå¯¦éš›è™•ç†

### Q4: åœ¨ Interrupt Context ä¸­å¯ä»¥å‘¼å« mutex_lock() å—ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Google

**ç­”æ¡ˆ**ï¼š
**çµ•å°ä¸è¡Œï¼** å› ç‚º mutex å¯èƒ½ç¡çœ ï¼Œè€Œ Interrupt Context ä¸èƒ½ç¡çœ ã€‚

- ç¡çœ æœƒå‘¼å« scheduler
- Scheduler éœ€è¦å®Œæ•´çš„ Process Context
- Interrupt Context æ²’æœ‰å¯è®“å‡ºçš„ process
- æœƒå°è‡´ Kernel Panic

**æ›¿ä»£æ–¹æ¡ˆ**ï¼š
- ä½¿ç”¨ spinlock_irqsave()
- ä½¿ç”¨ Workqueue æˆ– Threaded IRQ ä¾†è™•ç†éœ€è¦ mutex çš„æ“ä½œ

### Q5: ç‚ºä»€éº¼ ISR è¦ç›¡å¯èƒ½çŸ­ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­

**ç­”æ¡ˆ**ï¼š
1. ISR åŸ·è¡Œæ™‚ï¼Œç›¸åŒ/è¼ƒä½å„ªå…ˆæ¬Šä¸­æ–·è¢«é˜»æ“‹
2. éé•·å°è‡´ç³»çµ±éŸ¿æ‡‰è®Šæ…¢
3. å¯èƒ½éŒ¯éå…¶ä»–äº‹ä»¶
4. Real-time ç³»çµ±éœ€è¦å¯é æ¸¬çš„å»¶é²

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/03_åº•å±¤é©…å‹•é–‹ç™¼/ä¸­æ–·è™•ç†.md`
- æ“´å……å‰è¡Œæ•¸ï¼š573 è¡Œ
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 500 è¡Œ
- æ¶µè“‹ï¼šTop/Bottom-halfã€Taskletã€Workqueueã€Threaded IRQã€GICã€IRQ Affinity
