# ğŸ”” ä¸­æ–·è™•ç†ï¼ˆInterruptï¼‰å®Œæ•´æŒ‡å—

> **å­¸ç¿’ç›®æ¨™**
> 1. æ·±å…¥ç†è§£ä¸­æ–·çš„åŸºæœ¬åŸç†èˆ‡è™•ç†æµç¨‹
> 2. ç²¾é€š Linux Kernel çš„ Top-half / Bottom-half æ©Ÿåˆ¶
> 3. ç†Ÿç·´ä½¿ç”¨ Softirqã€Taskletã€Workqueueã€Threaded IRQ
> 4. ç†è§£ GIC æ¶æ§‹ï¼ˆGICv2/v3ï¼‰èˆ‡ä¸­æ–·æ§åˆ¶å™¨å±¤æ¬¡
> 5. æŒæ¡ IRQ API èˆ‡ä¸­æ–·è¦ªå’Œæ€§è¨­å®š

---

## ğŸ“Œ ç¬¬ä¸€éƒ¨åˆ†ï¼šä¸­æ–·åŸºç¤

### 1.1 ä»€éº¼æ˜¯ä¸­æ–·ï¼Ÿ

```
ä¸­æ–·æ˜¯ä¸€ç¨®æ©Ÿåˆ¶ï¼Œè®“ç¡¬é«”å¯ä»¥ã€Œæ‰“æ–·ã€CPU æ­£åœ¨åŸ·è¡Œçš„ç¨‹å¼ï¼Œ
å»è™•ç†æ›´ç·Šæ€¥çš„äº‹ä»¶ï¼Œè™•ç†å®Œå¾Œå†å›åˆ°åŸç¨‹å¼ç¹¼çºŒåŸ·è¡Œã€‚

é¡æ¯”ï¼šä½ æ­£åœ¨å¯«ç¨‹å¼ï¼ˆä¸»ç¨‹å¼ï¼‰ï¼Œé›»è©±éŸ¿äº†ï¼ˆä¸­æ–·ç™¼ç”Ÿï¼‰ï¼Œ
æ¥èµ·é›»è©±è™•ç†ï¼ˆISRï¼‰ï¼Œæ›æ‰å¾Œå›ä¾†ç¹¼çºŒå¯«ç¨‹å¼ï¼ˆè¿”å›ï¼‰ã€‚

ç‚ºä»€éº¼éœ€è¦ä¸­æ–·ï¼Ÿ
- è¼ªè©¢ (Polling) æµªè²» CPU æ™‚é–“
- å³æ™‚éŸ¿æ‡‰å¤–éƒ¨äº‹ä»¶
- æé«˜ç³»çµ±æ•ˆç‡
```

### 1.2 ä¸­æ–·é¡å‹

| é¡å‹ | ä¾†æº | è§¸ç™¼æ–¹å¼ | ç¯„ä¾‹ |
|:---|:---|:---|:---|
| ç¡¬é«”ä¸­æ–· | å¤–éƒ¨ç¡¬é«”äº‹ä»¶ | é›»å¹³/é‚Šç·£ | GPIOã€Timerã€UART |
| è»Ÿé«”ä¸­æ–· | ç¨‹å¼æŒ‡ä»¤è§¸ç™¼ | æŒ‡ä»¤ | ç³»çµ±å‘¼å«ã€SVC |
| ä¾‹å¤– (Exception) | CPU åŸ·è¡Œç•°å¸¸ | åŒæ­¥ | é™¤ä»¥é›¶ã€Page Fault |
| NMI | ä¸å¯é®ç½©ä¸­æ–· | é›»å¹³ | ç¡¬é«”æ•…éšœã€çœ‹é–€ç‹— |

### 1.3 é‚Šç·£è§¸ç™¼ vs é›»å¹³è§¸ç™¼

```c
/* é‚Šç·£è§¸ç™¼ (Edge-triggered) */
IRQF_TRIGGER_RISING   /* ä¸Šå‡ç·£ï¼š0 â†’ 1 æ™‚è§¸ç™¼ */
IRQF_TRIGGER_FALLING  /* ä¸‹é™ç·£ï¼š1 â†’ 0 æ™‚è§¸ç™¼ */
/* ç‰¹é»ï¼šåªåœ¨è½‰æ›ç¬é–“è§¸ç™¼ä¸€æ¬¡ï¼Œå¯èƒ½æ¼å¤±ä¸­æ–· */

/* é›»å¹³è§¸ç™¼ (Level-triggered) */
IRQF_TRIGGER_HIGH     /* é«˜é›»å¹³ï¼šä¿æŒ 1 æ™‚æŒçºŒè§¸ç™¼ */
IRQF_TRIGGER_LOW      /* ä½é›»å¹³ï¼šä¿æŒ 0 æ™‚æŒçºŒè§¸ç™¼ */
/* ç‰¹é»ï¼šé›»å¹³ç¶­æŒå°±æŒçºŒè§¸ç™¼ï¼Œå¿…é ˆåœ¨ ISR ä¸­æ¸…é™¤ä¾†æº */

/* é¸æ“‡åŸå‰‡ï¼š
 * - GPIO æŒ‰éˆ•ï¼šé‚Šç·£è§¸ç™¼ï¼ˆé¿å…é‡è¤‡ï¼‰
 * - å…±äº« IRQï¼šé€šå¸¸é›»å¹³è§¸ç™¼
 * - PCIe MSIï¼šé‚Šç·£è§¸ç™¼
 */
```

### 1.4 ä¸­æ–·è™•ç†æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ä¸­æ–·è™•ç†å®Œæ•´æµç¨‹                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  1. ä¸­æ–·ç™¼ç”Ÿï¼ˆç¡¬é«”å‘ Interrupt Controller ç™¼é€ä¿¡è™Ÿï¼‰              â”‚
â”‚     â†“                                                            â”‚
â”‚  2. Interrupt Controller (GIC) è­˜åˆ¥ä¸­æ–·æº                        â”‚
â”‚     â†“                                                            â”‚
â”‚  3. GIC å‘ CPU ç™¼å‡º IRQ/FIQ ä¿¡è™Ÿ                                 â”‚
â”‚     â†“                                                            â”‚
â”‚  4. CPU å®Œæˆç•¶å‰æŒ‡ä»¤                                             â”‚
â”‚     â†“                                                            â”‚
â”‚  5. CPU è‡ªå‹•ä¿å­˜éƒ¨åˆ† Context (PC, PSTATE)                        â”‚
â”‚     â†“                                                            â”‚
â”‚  6. åˆ‡æ›åˆ° Exception Level (EL1)                                 â”‚
â”‚     â†“                                                            â”‚
â”‚  7. è·³è½‰åˆ°ä¸­æ–·å‘é‡è¡¨å°æ‡‰ä½ç½®                                      â”‚
â”‚     â†“                                                            â”‚
â”‚  8. Kernel entry code ä¿å­˜å®Œæ•´ Context                           â”‚
â”‚     â†“                                                            â”‚
â”‚  9. å‘¼å« handle_arch_irq() â†’ GIC driver â†’ __do_IRQ()            â”‚
â”‚     â†“                                                            â”‚
â”‚ 10. å‘¼å« handler (Top-half) â†’ æ’ç¨‹ Bottom-half                   â”‚
â”‚     â†“                                                            â”‚
â”‚ 11. EOI (End of Interrupt) é€šçŸ¥ GIC                              â”‚
â”‚     â†“                                                            â”‚
â”‚ 12. æ¢å¾© Context                                                 â”‚
â”‚     â†“                                                            â”‚
â”‚ 13. è¿”å›è¢«ä¸­æ–·çš„ç¨‹å¼                                             â”‚
â”‚     â†“                                                            â”‚
â”‚ 14. (ç¨å¾Œ) åŸ·è¡Œ Bottom-half                                      â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.5 ARM ä¸­æ–·å‘é‡è¡¨ (ARMv8)

```c
/* ARM64 çš„å‘é‡è¡¨çµæ§‹ */
/*
 * Exception Entry Table (æ¯å€‹ entry 128 bytes)
 *
 * Offset        Exception           åŸ·è¡Œç‹€æ…‹
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 0x000        Synchronous          EL1t (SP_EL0)
 * 0x080        IRQ/vIRQ            
 * 0x100        FIQ/vFIQ            
 * 0x180        SError/vSError      
 * 
 * 0x200        Synchronous          EL1h (SP_EL1) â† æœ€å¸¸ç”¨
 * 0x280        IRQ/vIRQ            
 * 0x300        FIQ/vFIQ            
 * 0x380        SError/vSError      
 *
 * 0x400        Sync from EL0 (64-bit)
 * 0x480        IRQ from EL0 (64-bit)
 * ...
 */

/* Linux çš„å‘é‡è¡¨å®šç¾©ï¼šarch/arm64/kernel/entry.S */
SYM_CODE_START(vectors)
    kernel_ventry   1, t, 64, sync     /* EL1t synchronous */
    kernel_ventry   1, t, 64, irq      /* EL1t IRQ */
    kernel_ventry   1, t, 64, fiq
    kernel_ventry   1, t, 64, error
    
    kernel_ventry   1, h, 64, sync     /* EL1h synchronous */
    kernel_ventry   1, h, 64, irq      /* â† ä¸­æ–·é€²å…¥é» */
    kernel_ventry   1, h, 64, fiq
    kernel_ventry   1, h, 64, error
    /* ... */
SYM_CODE_END(vectors)
```

---

## ğŸ”· ç¬¬äºŒéƒ¨åˆ†ï¼šLinux Kernel ä¸­æ–·æ©Ÿåˆ¶

### 2.1 Top-half vs Bottom-half æ·±å…¥è§£æ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Top-half (ç¡¬ä¸­æ–· / Hardirq)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸ·è¡Œç’°å¢ƒï¼š                                                       â”‚
â”‚    - Interrupt Context                                           â”‚
â”‚    - ç¦ç”¨ç•¶å‰ IRQï¼ˆå¯èƒ½ç¦ç”¨æ‰€æœ‰ä¸­æ–·ï¼‰                             â”‚
â”‚    - ä¸å¯æ¶å                                                      â”‚
â”‚                                                                  â”‚
â”‚  é™åˆ¶ï¼š                                                           â”‚
â”‚    - âŒ ä¸èƒ½ç¡çœ ï¼ˆsleep, scheduleï¼‰                               â”‚
â”‚    - âŒ ä¸èƒ½ä½¿ç”¨ mutex                                            â”‚
â”‚    - âŒ ä¸èƒ½å‘¼å«å¯èƒ½ block çš„å‡½å¼                                 â”‚
â”‚    - âŒ ä¸èƒ½åšå¤§é‡è¨˜æ†¶é«”åˆ†é…ï¼ˆåªèƒ½ GFP_ATOMICï¼‰                    â”‚
â”‚    - âœ… å¯ä»¥ä½¿ç”¨ spinlockï¼ˆä½†è¦å°å¿ƒ deadlockï¼‰                    â”‚
â”‚                                                                  â”‚
â”‚  æ‡‰è©²åšçš„äº‹ï¼š                                                     â”‚
â”‚    - ç¢ºèªä¸­æ–·ä¾†æºï¼ˆæ˜¯å¦æ˜¯æˆ‘çš„ä¸­æ–·ï¼Ÿï¼‰                             â”‚
â”‚    - æ¸…é™¤ç¡¬é«”ä¸­æ–·æ——æ¨™                                             â”‚
â”‚    - è®€å–ç·Šæ€¥è³‡æ–™åˆ° buffer                                        â”‚
â”‚    - æ’ç¨‹ Bottom-half                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Bottom-half (å»¶é²è™•ç†)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ©Ÿåˆ¶é¸æ“‡ï¼š                                                       â”‚
â”‚                                                                  â”‚
â”‚  1. Softirqï¼ˆæœ€åº•å±¤ï¼‰                                            â”‚
â”‚     - å›ºå®šæ•¸é‡ï¼ŒKernel ç·¨è­¯æ™‚å®šç¾©                                 â”‚
â”‚     - Driver é€šå¸¸ä¸ç›´æ¥ä½¿ç”¨                                       â”‚
â”‚     - åœ¨ IRQ è¿”å›æ™‚æˆ– ksoftirqd åŸ·è¡Œ                              â”‚
â”‚                                                                  â”‚
â”‚  2. Taskletï¼ˆå»ºæ§‹åœ¨ Softirq ä¸Šï¼‰                                 â”‚
â”‚     - ä¸èƒ½ç¡çœ                                                     â”‚
â”‚     - ä¸€å€‹ Tasklet åªèƒ½åœ¨ä¸€å€‹ CPU åŸ·è¡Œ                            â”‚
â”‚     - è¼•é‡ã€å¿«é€Ÿ                                                  â”‚
â”‚                                                                  â”‚
â”‚  3. Workqueueï¼ˆProcess Contextï¼‰                                 â”‚
â”‚     - å¯ä»¥ç¡çœ ï¼                                                  â”‚
â”‚     - å¯ä»¥ä½¿ç”¨ mutex                                              â”‚
â”‚     - é©åˆè€—æ™‚æ“ä½œ                                                â”‚
â”‚                                                                  â”‚
â”‚  4. Threaded IRQï¼ˆå°ˆç”¨ Kernel Threadï¼‰                           â”‚
â”‚     - å¯ä»¥ç¡çœ ï¼                                                  â”‚
â”‚     - ç¨‹å¼ç¢¼ç°¡æ½”                                                  â”‚
â”‚     - ç¾ä»£ Driver æ¨è–¦ç”¨æ³•                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Softirq æ·±å…¥

```c
/* Softirq æ˜¯ Kernel å…§éƒ¨çš„åº•å±¤æ©Ÿåˆ¶ */
/* å®šç¾©åœ¨ include/linux/interrupt.h */

enum {
    HI_SOFTIRQ = 0,         /* é«˜å„ªå…ˆæ¬Š tasklet */
    TIMER_SOFTIRQ,          /* Timer */
    NET_TX_SOFTIRQ,         /* ç¶²è·¯ç™¼é€ */
    NET_RX_SOFTIRQ,         /* ç¶²è·¯æ¥æ”¶ */
    BLOCK_SOFTIRQ,          /* Block device */
    IRQ_POLL_SOFTIRQ,       /* IRQ polling */
    TASKLET_SOFTIRQ,        /* Tasklet */
    SCHED_SOFTIRQ,          /* Scheduler */
    HRTIMER_SOFTIRQ,        /* High-resolution timer */
    RCU_SOFTIRQ,            /* RCU */
    NR_SOFTIRQS
};

/* Softirq åŸ·è¡Œæ™‚æ©Ÿï¼š
 * 1. Hardirq è¿”å›æ™‚ï¼ˆirq_exit()ï¼‰
 * 2. æ˜ç¢ºå‘¼å« local_bh_enable()
 * 3. ksoftirqd kernel threadï¼ˆå¦‚æœ softirq å¤ªå¤šï¼‰
 */

/* æŸ¥çœ‹ softirq çµ±è¨ˆ */
$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3
          HI:          0          0          0          0
       TIMER:    1234567    1234568    1234569    1234570
      NET_TX:      12345      12346      12347      12348
      NET_RX:     123456     123457     123458     123459
       ...
```

### 2.3 Tasklet

```c
#include <linux/interrupt.h>

/* Tasklet ç‰¹é»ï¼š
 * - åœ¨ Softirq Context åŸ·è¡Œï¼ˆä¸èƒ½ç¡çœ ï¼‰
 * - åŒä¸€å€‹ Tasklet ä¸æœƒåŒæ™‚åœ¨å¤šå€‹ CPU åŸ·è¡Œï¼ˆè‡ªå‹•åºåˆ—åŒ–ï¼‰
 * - è¼•é‡ç´šï¼Œé©åˆå¿«é€Ÿè™•ç†
 * - Linux 5.9+ é–‹å§‹è¢«èªç‚ºæ˜¯ Deprecatedï¼Œå»ºè­°ç”¨ Threaded IRQ
 */

/* æ–¹æ³• 1ï¼šç·¨è­¯æ™‚å®£å‘Š */
static void my_tasklet_func(unsigned long data)
{
    struct my_device *priv = (struct my_device *)data;
    
    /* è™•ç†å·¥ä½œï¼Œä½†ä¸èƒ½ç¡çœ ï¼ */
    /* ä¸èƒ½ç”¨ mutexï¼Œåªèƒ½ç”¨ spinlock */
    
    spin_lock(&priv->lock);
    /* ... */
    spin_unlock(&priv->lock);
}

static DECLARE_TASKLET(my_tasklet, my_tasklet_func, 0);

/* æ–¹æ³• 2ï¼šåŸ·è¡Œæ™‚åˆå§‹åŒ– */
struct my_device {
    struct tasklet_struct tasklet;
    spinlock_t lock;
};

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    spin_lock_init(&priv->lock);
    
    tasklet_init(&priv->tasklet, my_tasklet_func, (unsigned long)priv);
    
    return 0;
}

static int my_remove(struct platform_device *pdev)
{
    struct my_device *priv = platform_get_drvdata(pdev);
    
    tasklet_kill(&priv->tasklet);  /* ç­‰å¾… tasklet å®Œæˆä¸¦ç¦ç”¨ */
    
    return 0;
}

/* åœ¨ ISR ä¸­æ’ç¨‹ tasklet */
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* Top-halfï¼šå¿«é€Ÿè™•ç† */
    clear_interrupt_flag(priv);
    
    /* æ’ç¨‹ Bottom-half */
    tasklet_schedule(&priv->tasklet);
    
    return IRQ_HANDLED;
}
```

### 2.4 Workqueue

```c
#include <linux/workqueue.h>

/* Workqueue ç‰¹é»ï¼š
 * - åœ¨ Process Context åŸ·è¡Œï¼ˆå¯ä»¥ç¡çœ ï¼ï¼‰
 * - å¯ä»¥ä½¿ç”¨ mutexã€åš I/O æ“ä½œ
 * - é©åˆè€—æ™‚å·¥ä½œ
 * - æœ‰å¤šç¨®æ¨¡å¼ï¼šsystem wqã€dedicated wqã€unbound wq
 */

/* ============ æ–¹æ³• 1ï¼šä½¿ç”¨ System Workqueue ============ */

struct my_device {
    struct work_struct work;
    struct mutex lock;
    int data;
};

static void my_work_func(struct work_struct *work)
{
    struct my_device *priv = container_of(work, struct my_device, work);
    
    /* å¯ä»¥ç¡çœ ï¼å¯ä»¥ä½¿ç”¨ mutexï¼ */
    mutex_lock(&priv->lock);
    
    /* è™•ç†è€—æ™‚å·¥ä½œï¼Œä¾‹å¦‚ I2C è®€å¯« */
    i2c_smbus_read_byte_data(client, reg);
    
    mutex_unlock(&priv->lock);
}

static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    mutex_init(&priv->lock);
    INIT_WORK(&priv->work, my_work_func);
    
    return 0;
}

static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    clear_interrupt_flag(priv);
    schedule_work(&priv->work);  /* æ’ç¨‹åˆ° system workqueue */
    
    return IRQ_HANDLED;
}

/* ============ æ–¹æ³• 2ï¼šä½¿ç”¨ Delayed Work ============ */

struct my_device {
    struct delayed_work dwork;
};

INIT_DELAYED_WORK(&priv->dwork, my_work_func);
schedule_delayed_work(&priv->dwork, msecs_to_jiffies(100));  /* 100ms å¾ŒåŸ·è¡Œ */

/* ============ æ–¹æ³• 3ï¼šå»ºç«‹å°ˆç”¨ Workqueue ============ */

static struct workqueue_struct *my_wq;

my_wq = create_singlethread_workqueue("my_driver_wq");
/* æˆ– */
my_wq = alloc_workqueue("my_wq", WQ_UNBOUND | WQ_HIGHPRI, 0);

queue_work(my_wq, &priv->work);

/* æ¸…ç† */
flush_workqueue(my_wq);
destroy_workqueue(my_wq);
```

### 2.5 Threaded IRQï¼ˆç¾ä»£ Driver æ¨è–¦ï¼‰

```c
/* Threaded IRQ ç‰¹é»ï¼š
 * - Bottom-half åœ¨å°ˆç”¨ Kernel Thread åŸ·è¡Œ
 * - å¯ä»¥ç¡çœ 
 * - ç¨‹å¼ç¢¼æ›´ç°¡æ½”
 * - ç¾ä»£ Driver æ¨è–¦ä½¿ç”¨
 * - RT (Real-Time) Linux å‹å¥½
 */

/* Primary Handler (Top-half) */
static irqreturn_t my_isr_primary(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    u32 status;
    
    /* å¿«é€Ÿç¢ºèªæ˜¯å¦æ˜¯æˆ‘çš„ä¸­æ–· */
    status = readl(priv->base + REG_STATUS);
    if (!(status & MY_IRQ_MASK))
        return IRQ_NONE;  /* ä¸æ˜¯æˆ‘çš„ä¸­æ–· */
    
    /* æ¸…é™¤ä¸­æ–·æ——æ¨™ï¼ˆå¦‚æœéœ€è¦åœ¨ Top-half åšï¼‰ */
    writel(status, priv->base + REG_STATUS);
    
    /* ä¿å­˜ç‹€æ…‹ä¾› Thread handler ä½¿ç”¨ */
    priv->irq_status = status;
    
    return IRQ_WAKE_THREAD;  /* å–šé†’ Thread handler */
}

/* Thread Handler (Bottom-half) */
static irqreturn_t my_isr_thread(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    
    /* å¯ä»¥ç¡çœ ï¼å¯ä»¥ä½¿ç”¨ mutexï¼ */
    mutex_lock(&priv->lock);
    
    /* æ ¹æ“š irq_status è™•ç†ä¸åŒäº‹ä»¶ */
    if (priv->irq_status & IRQ_DATA_READY) {
        process_data(priv);
    }
    if (priv->irq_status & IRQ_ERROR) {
        handle_error(priv);
    }
    
    mutex_unlock(&priv->lock);
    
    return IRQ_HANDLED;
}

/* è¨»å†Š Threaded IRQ */
static int my_probe(struct platform_device *pdev)
{
    struct my_device *priv;
    int irq, ret;
    
    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
    mutex_init(&priv->lock);
    
    irq = platform_get_irq(pdev, 0);
    if (irq < 0)
        return irq;
    
    ret = devm_request_threaded_irq(&pdev->dev, irq,
                                    my_isr_primary,    /* Top-half */
                                    my_isr_thread,     /* Bottom-half */
                                    IRQF_ONESHOT,      /* å¿…é ˆï¼ */
                                    dev_name(&pdev->dev), priv);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ\n");
        return ret;
    }
    
    return 0;
}

/* IRQF_ONESHOT èªªæ˜ï¼š
 * - åœ¨ Thread handler å®Œæˆå‰ä¿æŒ IRQ é®ç½©
 * - é¿å…ä¸­æ–·å†æ¬¡è§¸ç™¼ï¼ˆåœ¨é›»å¹³è§¸ç™¼æ™‚å¾ˆé‡è¦ï¼‰
 * - å°æ–¼ Threaded IRQ å¹¾ä¹ç¸½æ˜¯éœ€è¦
 */
```

### 2.6 Bottom-half æ©Ÿåˆ¶æ¯”è¼ƒ

| ç‰¹æ€§ | Softirq | Tasklet | Workqueue | Threaded IRQ |
|:---|:---|:---|:---|:---|
| Context | Softirq | Softirq | Process | Process |
| å¯ç¡çœ  | âŒ | âŒ | âœ… | âœ… |
| å¯ç”¨ Mutex | âŒ | âŒ | âœ… | âœ… |
| åŒæ™‚å¤š CPU | âœ… (åŒé¡å‹) | âŒ (åŒä¸€å€‹) | âœ… | âŒ (åŒä¸€å€‹) |
| é©ç”¨å ´æ™¯ | ç¶²è·¯/Block | è¼•é‡ driver | è€—æ™‚ I/O | ç¾ä»£ driver |
| è¤‡é›œåº¦ | é«˜ | ä¸­ | ä¸­ | ä½ |
| RT å‹å¥½ | âŒ | âŒ | âœ… | âœ… |

---

## ğŸ”· ç¬¬ä¸‰éƒ¨åˆ†ï¼šä¸­æ–· API è©³è§£

### 3.1 request_irq ç³»åˆ—

```c
/* ============ request_irq (åŸºæœ¬ç‰ˆ) ============ */
int request_irq(unsigned int irq,
                irq_handler_t handler,
                unsigned long flags,
                const char *name,
                void *dev);

/* å¿…é ˆé…å° free_irq */
free_irq(irq, dev);

/* ============ devm_request_irq (æ¨è–¦) ============ */
int devm_request_irq(struct device *dev,
                     unsigned int irq,
                     irq_handler_t handler,
                     unsigned long irqflags,
                     const char *devname,
                     void *dev_id);

/* ä¸éœ€è¦æ‰‹å‹• freeï¼Œdevice ç§»é™¤æ™‚è‡ªå‹•é‡‹æ”¾ */

/* ============ request_threaded_irq ============ */
int request_threaded_irq(unsigned int irq,
                         irq_handler_t handler,      /* Top-halfï¼Œå¯ç‚º NULL */
                         irq_handler_t thread_fn,    /* Bottom-half */
                         unsigned long flags,
                         const char *name,
                         void *dev);

/* ============ devm_request_threaded_irq (æ¨è–¦) ============ */
int devm_request_threaded_irq(struct device *dev,
                              unsigned int irq,
                              irq_handler_t handler,
                              irq_handler_t thread_fn,
                              unsigned long irqflags,
                              const char *devname,
                              void *dev_id);
```

### 3.2 å¸¸ç”¨ Flags

```c
/* è§¸ç™¼é¡å‹ */
IRQF_TRIGGER_NONE         /* ç”±ç¡¬é«”/firmware æ±ºå®š */
IRQF_TRIGGER_RISING       /* ä¸Šå‡ç·£ */
IRQF_TRIGGER_FALLING      /* ä¸‹é™ç·£ */
IRQF_TRIGGER_HIGH         /* é«˜é›»å¹³ */
IRQF_TRIGGER_LOW          /* ä½é›»å¹³ */

/* å…±äº« */
IRQF_SHARED               /* å¤šå€‹ handler å…±ç”¨åŒä¸€ IRQ */

/* Threaded IRQ ç›¸é—œ */
IRQF_ONESHOT              /* åœ¨ thread handler å®Œæˆå‰ä¿æŒé®ç½© */

/* å…¶ä»– */
IRQF_NO_SUSPEND           /* ç³»çµ± suspend æ™‚ä¸ disable */
IRQF_NOBALANCING          /* ç¦æ­¢ IRQ balancing */
IRQF_PERCPU               /* æ¯å€‹ CPU ç¨ç«‹è™•ç† */
```

### 3.3 IRQ API æ¯”è¼ƒ

| API | è‡ªå‹•é‡‹æ”¾ | Top-half | Bottom-half | æ¨è–¦ç”¨é€” |
|:---|:---:|:---:|:---:|:---|
| request_irq | âŒ | âœ… | âŒ | èˆŠ driver |
| devm_request_irq | âœ… | âœ… | âŒ | ç°¡å–®ä¸­æ–· |
| request_threaded_irq | âŒ | âœ…/NULL | âœ… | èˆŠ driver |
| devm_request_threaded_irq | âœ… | âœ…/NULL | âœ… | **ç¾ä»£ driver** |

### 3.4 Interrupt Context åˆ¤æ–·

```c
#include <linux/hardirq.h>
#include <linux/preempt.h>

/* åˆ¤æ–·ç•¶å‰ context */

in_interrupt()     /* åœ¨ä»»ä½•ä¸­æ–· context (hardirq æˆ– softirq) */
in_irq()           /* åœ¨ç¡¬ä¸­æ–· context (Top-half) */
in_softirq()       /* åœ¨ softirq context (åŒ…æ‹¬ tasklet) */
in_task()          /* åœ¨ process context */
in_atomic()        /* ä¸èƒ½ç¡çœ çš„ç‹€æ…‹ */

/* å¯¦éš›ä½¿ç”¨ */
void my_function(void)
{
    if (in_interrupt()) {
        /* ä½¿ç”¨ spinlockï¼Œä¸èƒ½ç¡çœ  */
        spin_lock(&lock);
        /* ... */
        spin_unlock(&lock);
    } else {
        /* å¯ä»¥ä½¿ç”¨ mutex */
        mutex_lock(&mutex);
        /* ... */
        mutex_unlock(&mutex);
    }
}

/* è¨˜æ†¶é«”åˆ†é… */
void *ptr;
if (in_interrupt())
    ptr = kmalloc(size, GFP_ATOMIC);  /* ä¸èƒ½ç¡çœ  */
else
    ptr = kmalloc(size, GFP_KERNEL);  /* å¯ä»¥ç¡çœ  */
```

### 3.5 IRQ Control

```c
/* ç¦ç”¨/å•Ÿç”¨ç‰¹å®š IRQ */
disable_irq(unsigned int irq);       /* ç¦ç”¨ä¸¦ç­‰å¾…ç•¶å‰ handler å®Œæˆ */
disable_irq_nosync(unsigned int irq); /* ç¦ç”¨ï¼Œä¸ç­‰å¾… */
enable_irq(unsigned int irq);

/* ç¦ç”¨/å•Ÿç”¨æœ¬åœ° CPU ä¸­æ–· */
local_irq_disable();
local_irq_enable();

/* ä¿å­˜å’Œæ¢å¾©ï¼ˆæ”¯æ´å·¢ç‹€ï¼‰ */
unsigned long flags;
local_irq_save(flags);
/* ... */
local_irq_restore(flags);

/* Spinlock + ç¦ç”¨ä¸­æ–· */
spin_lock_irqsave(&lock, flags);
/* ... */
spin_unlock_irqrestore(&lock, flags);
```

---

## ğŸ”· ç¬¬å››éƒ¨åˆ†ï¼šGIC æ¶æ§‹ï¼ˆARMï¼‰

### 4.1 GIC æ¦‚è¿°

```
GIC (Generic Interrupt Controller) æ˜¯ ARM è™•ç†å™¨çš„æ¨™æº–ä¸­æ–·æ§åˆ¶å™¨ã€‚

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        GIC æ¶æ§‹ç¸½è¦½                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ Timer   â”‚  â”‚  UART   â”‚  â”‚  GPIO   â”‚  â† å‘¨é‚Šè¨­å‚™              â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                         â”‚
â”‚       â”‚            â”‚            â”‚                               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                    â†“                                            â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚            â”‚  Distributor â”‚  â† æ”¶é›†ã€å„ªå…ˆæ¬Šæ’åºã€åˆ†ç™¼           â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                   â”‚                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚       â†“           â†“           â†“                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚CPU IF 0 â”‚ â”‚CPU IF 1 â”‚ â”‚CPU IF 2 â”‚  â† æ¯ CPU ä¸€å€‹            â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                          â”‚
â”‚       â†“           â†“           â†“                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚  CPU 0  â”‚ â”‚  CPU 1  â”‚ â”‚  CPU 2  â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 GIC ä¸­æ–·é¡å‹

```c
/* GIC å®šç¾©ä¸‰ç¨®ä¸­æ–·é¡å‹ */

/* SGI (Software Generated Interrupt): 0-15 */
/* - ç”¨æ–¼ CPU é–“é€šè¨Š (IPI) */
/* - é€éå¯«å…¥ GICD_SGIR æš«å­˜å™¨è§¸ç™¼ */
/* - ä¾‹å¦‚ï¼šè®“å…¶ä»– CPU åŸ·è¡Œå·¥ä½œã€å–šé†’å…¶ä»– CPU */

/* PPI (Private Peripheral Interrupt): 16-31 */
/* - æ¯å€‹ CPU ç§æœ‰çš„ä¸­æ–· */
/* - ä¾‹å¦‚ï¼šCPU çš„ Local Timerã€PMU */
/* - æ¯å€‹ CPU çœ‹åˆ°çš„æ˜¯åŒä¸€å€‹ IRQ è™Ÿç¢¼ï¼Œä½†ç¨ç«‹è™•ç† */

/* SPI (Shared Peripheral Interrupt): 32-1019 */
/* - å…±äº«çš„å‘¨é‚Šä¸­æ–· */
/* - å¯ä»¥è¢«åˆ†ç™¼åˆ°ä»»ä½• CPU */
/* - ä¾‹å¦‚ï¼šUARTã€SPIã€I2Cã€GPIO */
/* - Device Tree ä¸­é€šå¸¸æŒ‡å®šçš„æ˜¯é€™é¡ */

/* Device Tree ç¯„ä¾‹ */
my_device@40000000 {
    /* GIC_SPI 32 = SPI ä¸­æ–· 32ï¼Œå¯¦éš› IRQ = 32 + 32 = 64 */
    /* IRQ_TYPE_LEVEL_HIGH = é›»å¹³è§¸ç™¼ï¼Œé«˜é›»å¹³ */
    interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
};
```

### 4.3 GICv2 vs GICv3

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      GICv2 æ¶æ§‹                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Peripherals â†’ Distributor â†’ CPU Interfaces â†’ CPUs              â”‚
â”‚                                                                  â”‚
â”‚  - æœ€å¤šæ”¯æ´ 8 å€‹ CPU                                             â”‚
â”‚  - IRQ è™Ÿç¢¼æœ€å¤š 1020                                             â”‚
â”‚  - ç”¨æ–¼ ARMv7/ARMv8 (32-bit mode)                               â”‚
â”‚                                                                  â”‚
â”‚  ä¸»è¦æš«å­˜å™¨ï¼š                                                     â”‚
â”‚    GICD_*: Distributor æš«å­˜å™¨                                    â”‚
â”‚    GICC_*: CPU Interface æš«å­˜å™¨                                  â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      GICv3 æ¶æ§‹                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Peripherals â†’ Distributor â†’ Redistributors â†’ CPU IFs â†’ CPUs    â”‚
â”‚                              (æ¯ CPU ä¸€å€‹)                       â”‚
â”‚                                                                  â”‚
â”‚  æ–°å¢ Redistributorï¼š                                            â”‚
â”‚    - è™•ç† LPI (Locality-specific Peripheral Interrupts)          â”‚
â”‚    - è™•ç† PPI å’Œ SGI çš„è¨­å®š                                      â”‚
â”‚    - æ¯å€‹ CPU æœ‰è‡ªå·±çš„ Redistributor                             â”‚
â”‚                                                                  â”‚
â”‚  æ”¹é€²ï¼š                                                           â”‚
â”‚    - æ”¯æ´æ•¸ç™¾å€‹ CPU                                               â”‚
â”‚    - æ›´å¤š IRQï¼ˆLPI å¯é”æ•¸è¬å€‹ï¼‰                                   â”‚
â”‚    - æ”¯æ´è™›æ“¬åŒ–                                                   â”‚
â”‚    - System Register å­˜å–ï¼ˆæ›¿ä»£ MMIOï¼‰                           â”‚
â”‚                                                                  â”‚
â”‚  ä¸»è¦æš«å­˜å™¨ï¼š                                                     â”‚
â”‚    GICD_*: Distributor                                          â”‚
â”‚    GICR_*: Redistributor                                        â”‚
â”‚    GICC_* / ICC_*_EL1: CPU Interface                            â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.4 ä¸­æ–·è™•ç†æµç¨‹ï¼ˆGIC è¦–è§’ï¼‰

```c
/* 1. å‘¨é‚Šè¨­å‚™è§¸ç™¼ä¸­æ–·ä¿¡è™Ÿ
 * 2. Distributor æ¥æ”¶ä¸­æ–·
 *    - æª¢æŸ¥ä¸­æ–·æ˜¯å¦ enabled (GICD_ISENABLERn)
 *    - ç¢ºå®šå„ªå…ˆæ¬Š (GICD_IPRIORITYRn)
 *    - æ±ºå®šç›®æ¨™ CPU (GICD_ITARGETSRn)
 * 
 * 3. Distributor å°‡ä¸­æ–·ç™¼é€åˆ°ç›®æ¨™ CPU çš„ Interface
 * 
 * 4. CPU Interface å‘ CPU ç™¼å‡º IRQ ä¿¡è™Ÿ
 *    - åªæœ‰ç•¶ä¸­æ–·å„ªå…ˆæ¬Šé«˜æ–¼ Priority Mask (GICC_PMR)
 * 
 * 5. CPU é€²å…¥ç•°å¸¸è™•ç†
 * 
 * 6. CPU è®€å– GICC_IAR (Interrupt Acknowledge Register)
 *    - ç²å– IRQ è™Ÿç¢¼
 *    - ä¸­æ–·è®Šæˆ Active ç‹€æ…‹
 * 
 * 7. CPU åŸ·è¡Œ ISR
 * 
 * 8. CPU å¯«å…¥ GICC_EOIR (End of Interrupt Register)
 *    - ä¸­æ–·è™•ç†å®Œæˆ
 *    - ä¸­æ–·è®Šå› Inactive ç‹€æ…‹
 */
```

### 4.5 ä¸­æ–·è¦ªå’Œæ€§ (IRQ Affinity)

```c
/* è¨­å®šä¸­æ–·ç”±å“ªå€‹ CPU è™•ç† */
#include <linux/interrupt.h>

/* ç¨‹å¼ç¢¼ä¸­è¨­å®š */
cpumask_t mask;
cpumask_clear(&mask);
cpumask_set_cpu(2, &mask);  /* åªè®“ CPU 2 è™•ç† */
int ret = irq_set_affinity(irq, &mask);
if (ret)
    pr_err("Failed to set IRQ affinity\n");

/* åœ¨ /proc ä¸­æŸ¥çœ‹å’Œè¨­å®š */
/* æŸ¥çœ‹ IRQ 33 çš„è¦ªå’Œæ€§ */
$ cat /proc/irq/33/smp_affinity
f  /* è¡¨ç¤º CPU 0-3 éƒ½å¯ä»¥è™•ç† (äºŒé€²ä½ 1111) */

/* è¨­å®šåªè®“ CPU 2 è™•ç† */
$ echo 4 > /proc/irq/33/smp_affinity  /* äºŒé€²ä½ 0100 */

/* æŸ¥çœ‹ç•¶å‰åœ¨å“ªå€‹ CPU è™•ç† */
$ cat /proc/irq/33/smp_affinity_list
2

/* æŸ¥çœ‹ IRQ çµ±è¨ˆ */
$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       
 33:          0          0      12345          0  my_device
```

### 4.6 ç‚ºä»€éº¼è¨­å®š IRQ Affinityï¼Ÿ

```c
/* æ•ˆèƒ½å„ªåŒ–åŸå› ï¼š
 * 
 * 1. Cache Locality
 *    - è®“ IRQ ç¸½æ˜¯åœ¨åŒä¸€å€‹ CPU è™•ç†
 *    - è³‡æ–™å¯ä»¥ä¿ç•™åœ¨è©² CPU çš„ cache
 * 
 * 2. è² è¼‰å‡è¡¡
 *    - å°‡é«˜é »ä¸­æ–·åˆ†æ•£åˆ°ä¸åŒ CPU
 *    - é¿å…å–®ä¸€ CPU éè¼‰
 * 
 * 3. Real-Time éœ€æ±‚
 *    - å°‡ RT ä¸­æ–·ç¶å®šåˆ°å°ˆç”¨ CPU
 *    - æ¸›å°‘å»¶é²è®Šç•°
 * 
 * 4. NUMA è€ƒé‡
 *    - è®“ IRQ åœ¨é è¿‘è£ç½®çš„ NUMA node è™•ç†
 */
```

---

## ğŸ”· ç¬¬äº”éƒ¨åˆ†ï¼šè‡¨ç•Œå€æ®µèˆ‡åŒæ­¥

### 5.1 ISR èˆ‡ä¸»ç¨‹å¼å…±äº«è³‡æ–™

```c
/* Race Condition ç¯„ä¾‹ */
volatile int counter = 0;

void ISR(void) {
    counter++;  /* è®€-æ”¹-å¯«ï¼ŒéåŸå­æ“ä½œï¼ */
}

void main_task(void) {
    counter++;  /* å¯èƒ½åœ¨ ISR åŸ·è¡Œä¸­é–“è¢«æ‰“æ–· */
}

/* å•é¡Œï¼š
 * 1. main_task è®€å– counter = 5
 * 2. ISR ç™¼ç”Ÿï¼Œè®€å– counter = 5
 * 3. ISR åŸ·è¡Œ 5 + 1 = 6ï¼Œå¯«å›
 * 4. main_task ç¹¼çºŒï¼Œ5 + 1 = 6ï¼Œå¯«å›
 * çµæœï¼šæ‡‰è©²æ˜¯ 7ï¼Œä½†å¯¦éš›æ˜¯ 6ï¼
 */
```

### 5.2 ä¿è­·å…±äº«è³‡æ–™çš„æ–¹æ³•

```c
/* æ–¹æ³• 1ï¼šç¦ç”¨ä¸­æ–· */
unsigned long flags;
local_irq_save(flags);
counter++;
local_irq_restore(flags);

/* æ–¹æ³• 2ï¼šSpinlock + ç¦ç”¨ä¸­æ–· (æ¨è–¦) */
spinlock_t lock;
spin_lock_init(&lock);

/* åœ¨ process context */
spin_lock_irqsave(&lock, flags);
counter++;
spin_unlock_irqrestore(&lock, flags);

/* åœ¨ ISR */
spin_lock(&lock);  /* å·²ç¶“åœ¨ä¸­æ–·ä¸­ï¼Œä¸éœ€è¦ save flags */
counter++;
spin_unlock(&lock);

/* æ–¹æ³• 3ï¼šåŸå­æ“ä½œ */
atomic_t atomic_counter = ATOMIC_INIT(0);
atomic_inc(&atomic_counter);
int val = atomic_read(&atomic_counter);
```

### 5.3 volatile é—œéµå­—

```c
/* volatile å‘Šè¨´ç·¨è­¯å™¨ï¼šä¸è¦å„ªåŒ–ï¼Œæ¯æ¬¡éƒ½å¾è¨˜æ†¶é«”è®€å– */

/* éœ€è¦ volatile çš„å ´æ™¯ï¼š
 * 1. ISR å’Œä¸»ç¨‹å¼å…±äº«çš„è®Šæ•¸
 * 2. ç¡¬é«”æš«å­˜å™¨
 * 3. Busy-wait loop
 */

/* ç¯„ä¾‹ï¼šç­‰å¾…ç¡¬é«”å®Œæˆ */
volatile uint32_t *status_reg = (volatile uint32_t *)0x40000000;

while ((*status_reg & BUSY_FLAG) != 0) {
    /* æ²’æœ‰ volatileï¼Œç·¨è­¯å™¨å¯èƒ½å„ªåŒ–æˆï¼š
     * if (*status_reg & BUSY_FLAG) while(1);
     * å› ç‚ºå®ƒèªç‚ºè¿´åœˆå…§æ²’äººæ”¹è®Š status_reg
     */
}

/* æ³¨æ„ï¼švolatile ä¸ä¿è­‰åŸå­æ€§ï¼ */
/* åªä¿è­‰ã€Œæ¯æ¬¡éƒ½è®€å¯«è¨˜æ†¶é«”ã€ï¼Œä¸ä¿è­‰ã€Œè®€-æ”¹-å¯«ã€æ˜¯åŸå­çš„ */
```

### 5.4 Memory Barrier

```c
/* ç¢ºä¿è¨˜æ†¶é«”æ“ä½œçš„é †åº */

/* Linux Kernel æä¾›çš„ Barrier */
mb();   /* Full memory barrier */
rmb();  /* Read memory barrier */
wmb();  /* Write memory barrier */

smp_mb();   /* SMP å®‰å…¨çš„ full barrier */
smp_rmb();  /* SMP å®‰å…¨çš„ read barrier */
smp_wmb();  /* SMP å®‰å…¨çš„ write barrier */

/* ä½¿ç”¨å ´æ™¯ï¼šé€šçŸ¥å…¶ä»– CPU */
void producer(void)
{
    data = 123;       /* å…ˆå¯«å…¥è³‡æ–™ */
    smp_wmb();        /* ç¢ºä¿ data å¯«å…¥å®Œæˆ */
    flag = 1;         /* å†è¨­å®š flag */
}

void consumer(void)
{
    while (!flag);    /* ç­‰å¾… flag */
    smp_rmb();        /* ç¢ºä¿è®€åˆ°æœ€æ–°çš„ data */
    use(data);        /* ä½¿ç”¨è³‡æ–™ */
}
```

---

## ğŸ“ é¢è©¦é¡Œåº«

### Q1: Top-half å’Œ Bottom-half çš„å€åˆ¥ï¼Ÿä»€éº¼æ™‚å€™ç”¨å“ªå€‹ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / è¯ç™¼ç§‘ / æ¯å®¶å…¬å¸

**ç­”æ¡ˆ**ï¼š

| ç‰¹æ€§ | Top-half | Bottom-half |
|:---|:---|:---|
| åŸ·è¡Œæ™‚æ©Ÿ | ç«‹å³ï¼Œä¸­æ–·ç™¼ç”Ÿæ™‚ | ç¨å¾Œï¼Œç”± Kernel æ’ç¨‹ |
| Context | Interrupt Context | Softirq/Process Context |
| å¯å¦ç¡çœ  | âŒ ä¸å¯ä»¥ | Tasklet âŒ, Workqueue/Threaded âœ… |
| å…¸å‹å·¥ä½œ | æ¸…é™¤æ——æ¨™ã€è®€ç·Šæ€¥è³‡æ–™ | è³‡æ–™è™•ç†ã€I/O æ“ä½œ |

**ä½¿ç”¨åŸå‰‡**ï¼š
- Top-half åšæœ€å°‘å¿…è¦çš„äº‹ï¼ˆç¢ºèªä¾†æºã€æ¸…æ——æ¨™ã€æ’ç¨‹ï¼‰
- è€—æ™‚å·¥ä½œæ”¾ Bottom-half
- éœ€è¦ mutex/ç¡çœ  â†’ Workqueue æˆ– Threaded IRQ

---

### Q2: Tasklet vs Workqueue vs Threaded IRQ å¦‚ä½•é¸æ“‡ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šNVIDIA / Google

**ç­”æ¡ˆ**ï¼š

| éœ€æ±‚ | é¸æ“‡ | åŸå›  |
|:---|:---|:---|
| å¿«é€Ÿã€ä¸éœ€ç¡çœ  | Tasklet | Softirq contextï¼Œä½å»¶é² |
| éœ€è¦ mutex/ç¡çœ  | Workqueue | Process context |
| ç¾ä»£ Driver é–‹ç™¼ | Threaded IRQ | ç°¡æ½”ã€RT å‹å¥½ |
| RT Linux | Threaded IRQ | å¯è¢« RT æ’ç¨‹å™¨ç®¡ç† |

**Threaded IRQ å„ªé»**ï¼š
- ç¨‹å¼ç¢¼ç°¡æ½”ï¼ˆä¸éœ€é¡å¤–ç®¡ç† tasklet/workï¼‰
- è‡ªå‹•è™•ç† Top/Bottom-half åˆ†é›¢
- RT Linux å‹å¥½
- Linux æ ¸å¿ƒç¤¾ç¾¤æ¨è–¦

---

### Q3: åœ¨ Interrupt Context ä¸­å¯ä»¥å‘¼å« mutex_lock() å—ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­â­
**å¸¸è¦‹æ–¼**ï¼šæ¯å®¶å…¬å¸

**ç­”æ¡ˆ**ï¼š
**çµ•å°ä¸è¡Œï¼**

åŸå› ï¼š
- mutex_lock() å¯èƒ½ç¡çœ 
- ç¡çœ éœ€è¦ schedule()
- schedule() éœ€è¦å®Œæ•´çš„ Process Context
- Interrupt Context æ²’æœ‰å¯åˆ‡æ›çš„ process

å¾Œæœï¼š
- Kernel åµæ¸¬åˆ°æœƒ BUG() å ±éŒ¯
- èˆŠç‰ˆæœ¬å¯èƒ½ç›´æ¥ system hang

æ›¿ä»£æ–¹æ¡ˆï¼š
- ä½¿ç”¨ spinlock_irqsave()
- ä½¿ç”¨ Workqueue æˆ– Threaded IRQ

---

### Q4: ä»€éº¼æ˜¯ IRQF_ONESHOTï¼Ÿä»€éº¼æ™‚å€™éœ€è¦ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
`IRQF_ONESHOT` è¡¨ç¤ºåœ¨ Thread handler å®Œæˆå‰ä¿æŒä¸­æ–·é®ç½©ã€‚

éœ€è¦çš„æƒ…æ³ï¼š
1. ä½¿ç”¨ Threaded IRQï¼ˆå¹¾ä¹å¿…é ˆï¼‰
2. é›»å¹³è§¸ç™¼çš„ä¸­æ–·
3. ä¸­æ–·æºéœ€è¦åœ¨ Thread handler ä¸­æ‰èƒ½æ¸…é™¤

åŸå› ï¼š
- é›»å¹³è§¸ç™¼çš„ä¸­æ–·ï¼Œåªè¦è§¸ç™¼æ¢ä»¶ç¶­æŒï¼Œå°±æœƒä¸æ–·è§¸ç™¼
- å¦‚æœæ²’æœ‰ ONESHOTï¼ŒTop-half çµæŸå¾Œä¸­æ–·æœƒç«‹å³å†æ¬¡è§¸ç™¼
- Thread handler é‚„æ²’ä¾†å¾—åŠæ¸…é™¤ä¾†æº

---

### Q5: è§£é‡‹ GIC çš„ SGIã€PPIã€SPI

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š

| é¡å‹ | IRQ ç¯„åœ | ç”¨é€” | ç‰¹é» |
|:---|:---|:---|:---|
| SGI | 0-15 | CPU é–“é€šè¨Š | è»Ÿé«”è§¸ç™¼ |
| PPI | 16-31 | CPU ç§æœ‰å‘¨é‚Š | æ¯ CPU ç¨ç«‹ |
| SPI | 32-1019 | å…±äº«å‘¨é‚Š | å¯åˆ†ç™¼åˆ°ä»»ä½• CPU |

Device Tree ç¯„ä¾‹ï¼š
```dts
/* GIC_SPI 32 = IRQ 64 (32 + 32) */
interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
```

---

### Q6: IRQ Affinity è¨­å®šçš„ç›®çš„ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­â­

**ç­”æ¡ˆ**ï¼š
1. **Cache å±€éƒ¨æ€§**ï¼šåŒä¸€ CPU è™•ç†ï¼Œè³‡æ–™ç•™åœ¨ cache
2. **è² è¼‰å‡è¡¡**ï¼šåˆ†æ•£é«˜é »ä¸­æ–·åˆ°å¤šå€‹ CPU
3. **Real-Time**ï¼šRT ä¸­æ–·ç¶å®šå°ˆç”¨ CPU
4. **NUMA**ï¼šIRQ åœ¨é è¿‘è£ç½®çš„ node è™•ç†

è¨­å®šæ–¹å¼ï¼š
```bash
echo 4 > /proc/irq/33/smp_affinity  # åªè®“ CPU 2 è™•ç†
```

---

### Q7: ç‚ºä»€éº¼ ISR è¦ç›¡å¯èƒ½çŸ­ï¼Ÿ

**é›£åº¦**ï¼šâ­â­â­

**ç­”æ¡ˆ**ï¼š
1. ISR åŸ·è¡Œæ™‚ï¼ŒåŒç­‰/è¼ƒä½å„ªå…ˆæ¬Šä¸­æ–·è¢«é˜»æ“‹
2. éé•·å°è‡´ç³»çµ±éŸ¿æ‡‰è®Šæ…¢
3. å¯èƒ½éŒ¯éå…¶ä»–äº‹ä»¶ï¼ˆå°¤å…¶é‚Šç·£è§¸ç™¼ï¼‰
4. Real-time éœ€è¦å¯é æ¸¬çš„å»¶é²
5. ä½”ç”¨ CPU æ™‚é–“ï¼Œå½±éŸ¿å…¶ä»– task

æœ€ä½³å¯¦è¸ï¼š
- Top-half åªåšæœ€å°å¿…è¦å·¥ä½œ
- è€—æ™‚è™•ç†æ”¾ Bottom-half

---

### Q8: é€™æ®µç¨‹å¼ç¢¼æœ‰ä»€éº¼å•é¡Œï¼Ÿ

```c
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    char *buf = kmalloc(1024, GFP_KERNEL);
    
    mutex_lock(&priv->lock);
    /* è™•ç†è³‡æ–™ */
    mutex_unlock(&priv->lock);
    
    kfree(buf);
    return IRQ_HANDLED;
}
```

**é›£åº¦**ï¼šâ­â­â­â­â­

**ç­”æ¡ˆ**ï¼š
**å…©å€‹åš´é‡å•é¡Œ**ï¼š

1. **GFP_KERNEL**ï¼šåœ¨ Interrupt Context ä¸­æœƒç¡çœ 
   - æ‡‰è©²ç”¨ GFP_ATOMIC
   
2. **mutex_lock()**ï¼šåœ¨ Interrupt Context ä¸­ä¸èƒ½ä½¿ç”¨
   - æ‡‰è©²ç”¨ spinlock_irqsave() æˆ–ç§»åˆ° Threaded IRQ

ä¿®æ­£ç‰ˆï¼š
```c
static irqreturn_t my_isr(int irq, void *dev_id)
{
    struct my_device *priv = dev_id;
    unsigned long flags;
    
    spin_lock_irqsave(&priv->lock, flags);
    /* å¿«é€Ÿè™•ç† */
    spin_unlock_irqrestore(&priv->lock, flags);
    
    return IRQ_HANDLED;
}
```

---

## ğŸ“š å»¶ä¼¸é–±è®€

1. **Kernel æ–‡ä»¶**
   - Documentation/core-api/genericirq.rst
   - Documentation/core-api/workqueue.rst

2. **ARM æ–‡ä»¶**
   - ARM GIC Architecture Specification
   - ARM Cortex-A Programmer's Guide

3. **ç·šä¸Šè³‡æº**
   - [Bootlin Interrupt Training](https://bootlin.com/doc/training/linux-kernel/linux-kernel-slides.pdf)

---

## âœ… ç« ç¯€å®Œæˆå ±å‘Š

- æª”æ¡ˆï¼š`/03_åº•å±¤é©…å‹•é–‹ç™¼/ä¸­æ–·è™•ç†.md`
- æ“´å……å¾Œè¡Œæ•¸ï¼šç´„ 1000 è¡Œ
- æ¶µè“‹ï¼š
  - âœ… Top-half / Bottom-half å®Œæ•´æ©Ÿåˆ¶
  - âœ… Softirq / Tasklet / Workqueue / Threaded IRQ è©³è§£èˆ‡æ¯”è¼ƒ
  - âœ… IRQ API å®Œæ•´èªªæ˜ (request_irq / devm_request_threaded_irq)
  - âœ… GIC æ¶æ§‹ï¼ˆGICv2/v3 å€åˆ¥ï¼‰
  - âœ… SGI / PPI / SPI ä¸­æ–·é¡å‹
  - âœ… IRQ Affinity è¨­å®š
  - âœ… è‡¨ç•Œå€æ®µèˆ‡åŒæ­¥ï¼ˆspinlockã€volatileã€memory barrierï¼‰
  - âœ… 8 é“é¢è©¦é¡Œ
