# 🔔 中斷處理（Interrupt）詳解

> 中斷是嵌入式系統的核心概念，幾乎每場韌體面試都會問！

---

## 📌 什麼是中斷？

```
中斷是一種機制，讓硬體或軟體可以「打斷」CPU 正在執行的程式，
去處理更緊急的事件，處理完後再回到原本的程式繼續執行。

類比：
你正在寫程式（主程式），電話響了（中斷發生），
你接起電話處理（中斷服務程式 ISR），
掛掉電話後回來繼續寫程式（返回主程式）。
```

---

## 🔷 中斷的類型

### 1. 硬體中斷（External/Hardware Interrupt）

```
來源：外部硬體事件
範例：
- GPIO pin 狀態改變
- Timer 計時到達
- UART 收到資料
- ADC 轉換完成
- I2C/SPI 傳輸完成
```

### 2. 軟體中斷（Software Interrupt）

```
來源：程式指令觸發
範例：
- 系統呼叫（System Call）
- SVC (Supervisor Call) 指令
- 例外處理
```

### 3. 例外（Exception）

```
來源：CPU 執行過程中的異常情況
範例：
- 除以零
- 非法記憶體存取
- 未定義指令
- Hard Fault（在 ARM Cortex-M 中）
```

---

## 🔷 中斷處理流程

```
┌─────────────────────────────────────────────────────────────┐
│                     中斷處理完整流程                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 中斷發生                                                 │
│     ↓                                                       │
│  2. CPU 完成當前指令                                         │
│     ↓                                                       │
│  3. 保存 Context（程式計數器 PC、暫存器、狀態等）             │
│     ↓                                                       │
│  4. 查詢中斷向量表（Interrupt Vector Table）                  │
│     ↓                                                       │
│  5. 跳轉到對應的 ISR（Interrupt Service Routine）            │
│     ↓                                                       │
│  6. 執行 ISR                                                 │
│     ↓                                                       │
│  7. 恢復 Context                                             │
│     ↓                                                       │
│  8. 回到原程式繼續執行                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔷 中斷向量表（Interrupt Vector Table）

```c
// 中斷向量表是一個陣列，儲存每個中斷對應的 ISR 位址
// 通常放在記憶體最低位址（例如 0x00000000）

// ARM Cortex-M 範例
__attribute__((section(".isr_vector")))
const void (*vector_table[])(void) = {
    (void *)&_estack,           // 0x00: Initial Stack Pointer
    Reset_Handler,              // 0x04: Reset Handler
    NMI_Handler,                // 0x08: NMI
    HardFault_Handler,          // 0x0C: Hard Fault
    // ... 其他系統例外 ...
    SysTick_Handler,            // 0x3C: SysTick
    // 外部中斷
    EXTI0_IRQHandler,           // 0x58: External Interrupt 0
    EXTI1_IRQHandler,           // 0x5C: External Interrupt 1
    // ... 更多中斷 ...
};
```

---

## 🔷 ISR（中斷服務程式）撰寫原則

### ⚠️ ISR 應該要：

```c
// 1. 盡可能短且快速
void EXTI0_IRQHandler(void) {
    // 清除中斷旗標
    EXTI->PR |= (1 << 0);
    
    // 設定旗標，讓主程式處理
    button_pressed = 1;
    
    // 不要在這裡做耗時操作！
}

// 2. 使用 volatile 變數和主程式溝通
volatile int button_pressed = 0;

int main(void) {
    while (1) {
        if (button_pressed) {
            button_pressed = 0;
            handle_button();  // 在主程式做耗時處理
        }
    }
}
```

### ❌ ISR 不應該：

```
1. 執行耗時操作（大量運算、等待迴圈）
2. 呼叫非 reentrant 函式（如 printf、malloc）
3. 存取複雜的資料結構（沒有保護的情況下）
4. 做太多事情
```

### 為什麼 ISR 要短？

```
1. ISR 執行時，相同或更低優先權的中斷被阻擋
2. 過長的 ISR 會導致系統反應變慢
3. 可能錯過其他重要事件

最佳實踐：ISR 只做最必要的事，其他交給主程式
```

---

## 🔷 中斷優先權（Interrupt Priority）

```
┌─────────────────────────────────────────────────────────────┐
│                     中斷優先權概念                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  數字越小，優先權越高                                        │
│                                                             │
│  Priority 0: 最高優先權（通常是 NMI 或系統例外）             │
│  Priority 1: 較高                                           │
│  Priority 2: 中等                                           │
│  Priority 3: 較低                                           │
│  ...                                                        │
│                                                             │
│  高優先權中斷可以打斷低優先權中斷（Nested Interrupt）        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### ARM Cortex-M 的 NVIC

```c
// NVIC (Nested Vectored Interrupt Controller)

// 設定中斷優先權
NVIC_SetPriority(EXTI0_IRQn, 2);

// 啟用中斷
NVIC_EnableIRQ(EXTI0_IRQn);

// 禁用中斷
NVIC_DisableIRQ(EXTI0_IRQn);

// 清除 pending 中斷
NVIC_ClearPendingIRQ(EXTI0_IRQn);
```

---

## 🔷 中斷延遲（Interrupt Latency）

```
中斷延遲 = 從中斷發生到 ISR 開始執行的時間

組成：
1. 中斷識別時間
2. 完成當前指令的時間
3. 保存 Context 的時間
4. 取得 ISR 位址的時間
5. 跳轉到 ISR 的時間

ARM Cortex-M3/M4 的中斷延遲約 12 個 clock cycles
（不含等待更高優先權中斷的時間）
```

---

## 🔷 臨界區段（Critical Section）

### 什麼是臨界區段？為什麼需要禁用中斷？

```
想像這個情境：

主程式正在執行 shared_counter++ 這個操作。
在 CPU 層面，這個「看起來是一行」的操作，其實分成三步：
  1. 從記憶體讀取 shared_counter 的值到暫存器（假設是 10）
  2. 在暫存器中執行 +1（變成 11）
  3. 把暫存器的值寫回記憶體

問題來了！如果在步驟 2 和步驟 3 之間發生中斷呢？

時間軸：
┌─────────────────────────────────────────────────────────────┐
│ 主程式                                                       │
│   1. 讀取 shared_counter = 10                               │
│   2. 暫存器 +1 = 11                                         │
│         ↓ ⚡ 這時候中斷發生！                                 │
│         │                                                    │
│         │  ISR 執行：                                        │
│         │    讀取 shared_counter = 10（還沒被更新！）         │
│         │    暫存器 +1 = 11                                  │
│         │    寫回 shared_counter = 11                        │
│         │  ISR 結束                                          │
│         ↓                                                    │
│   3. 寫回 shared_counter = 11（覆蓋掉 ISR 的結果！）         │
└─────────────────────────────────────────────────────────────┘

結果：明明加了兩次（主程式 +1，ISR +1），shared_counter 卻只變成 11！
      這就是「競爭條件」（Race Condition）。

解決方法：在執行這種「不可被打斷」的操作時，暫時禁用中斷。
這段不可被打斷的程式碼區域，就叫做「臨界區段」。
```

### 基本做法

```c
volatile int shared_counter = 0;

void increment_counter(void) {
    // 進入臨界區段：禁用中斷
    __disable_irq();  // 從這裡開始，中斷不會發生
    
    shared_counter++;  // 安全地存取共享資源
    
    // 離開臨界區段：恢復中斷
    __enable_irq();   // 中斷又可以發生了
}
```

### 更好的做法：保存和恢復中斷狀態

```c
// 為什麼需要「保存狀態」而不是直接 enable？

// 問題情境：巢狀呼叫
void funcA(void) {
    __disable_irq();     // 禁用中斷
    // ... 做一些事 ...
    funcB();             // 呼叫另一個函式
    // ... 做一些事 ...
    __enable_irq();      // 恢復中斷
}

void funcB(void) {
    __disable_irq();     // 禁用中斷
    // ... 做一些事 ...
    __enable_irq();      // ⚠️ 問題！這裡把中斷打開了！
}                        // 但 funcA 還在臨界區段內！

// 正確做法：保存之前的狀態
void safe_increment(void) {
    uint32_t primask = __get_PRIMASK();  // 保存「中斷是否已經被禁用」的狀態
    __disable_irq();                     // 禁用中斷
    
    shared_counter++;                    // 安全操作
    
    __set_PRIMASK(primask);              // 恢復「之前」的狀態
    // 如果之前中斷是開的 → 現在打開
    // 如果之前中斷是關的 → 現在保持關閉
}

// 所以 safe_increment 結束時：
// - 如果呼叫前中斷是開啟的 → primask = 0 → __set_PRIMASK(0) → 中斷開啟 ✓
// - 如果呼叫前中斷是關閉的 → primask = 1 → __set_PRIMASK(1) → 中斷關閉 ✓

// 這樣就不會破壞外層的臨界區段！
```

---

## 🔷 volatile 關鍵字詳解

### 為什麼需要 volatile？

```
volatile 的意思是：「這個變數可能被程式碼以外的因素改變」

編譯器為了優化效能，會把頻繁存取的變數放在暫存器中，
而不是每次都從記憶體讀取。這通常是好事，但在以下情況會出問題：

1. 變數會被 ISR 修改
2. 變數會被另一個 thread 修改  
3. 變數對應到硬體暫存器（硬體會改變它的值）
```

### 沒有 volatile 會發生什麼？

```c
int flag = 0;  // 沒有 volatile

void ISR(void) {
    flag = 1;  // ISR 把 flag 改成 1
}

int main(void) {
    while (flag == 0) {
        // 編譯器分析這段程式碼，發現：
        // 「flag 在這個迴圈裡沒有被修改啊！」
        // 「那我可以優化，只讀一次就好！」
        //
        // 優化後的版本（編譯器內部）：
        // int temp = flag;  // 只讀一次
        // while (temp == 0) { }  // 永遠用 temp，不再讀 flag
        //
        // 結果：即使 ISR 把 flag 改成 1，迴圈還是不會結束！
    }
    printf("這行永遠不會被執行到！\n");
}
```

### 加上 volatile 就正常了

```c
volatile int flag = 0;  // 加上 volatile

void ISR(void) {
    flag = 1;
}

int main(void) {
    while (flag == 0) {
        // volatile 告訴編譯器：
        // 「這個變數可能隨時被改變，不要優化，每次都要從記憶體讀！」
        //
        // 所以每次迴圈都會真正去讀 flag 的值
        // 當 ISR 把 flag 改成 1，迴圈就會結束
    }
    printf("ISR 已經執行，flag 變成 1 了\n");
}
```

### volatile 的使用場景

```c
// 場景 1：ISR 和主程式共享的變數
volatile int sensor_reading = 0;

void SENSOR_ISR(void) {
    sensor_reading = read_sensor();  // ISR 更新
}

int main(void) {
    while (1) {
        if (sensor_reading > 100) {  // 主程式讀取
            trigger_alarm();
        }
    }
}

// 場景 2：硬體暫存器
#define STATUS_REG  (*(volatile uint32_t *)0x40001000)
// 這個位址對應到硬體，硬體會自己改變這個值
// 必須用 volatile，否則編譯器可能只讀一次

while ((STATUS_REG & 0x01) == 0) {
    // 等待硬體把 bit 0 設成 1
    // 如果沒有 volatile，編譯器可能優化成無限迴圈
}

// 場景 3：多執行緒共享變數（不過這種情況通常用 atomic 更好）
volatile int shared_data;
```

### volatile 的常見誤解

```c
// 誤解 1：volatile 不能取代 mutex！
volatile int counter = 0;

// 這個操作還是不安全的：
counter++;  // 仍然是讀-改-寫三步驟，可能被打斷

// volatile 只保證「每次都從記憶體讀」
// 不保證「操作是原子的」

// 誤解 2：不是所有「會被改」的變數都需要 volatile
// 如果變數只在同一段程式碼中被讀寫，不需要 volatile
int local_var = 0;
for (int i = 0; i < 10; i++) {
    local_var += i;  // 這裡不需要 volatile，編譯器知道會被改
}
```

---

## 📝 常見面試問題

**Q1：什麼是中斷？**
```
中斷是一種機制，讓 CPU 可以暫停當前執行的程式，
去處理更緊急的事件（如硬體訊號），處理完後再返回原程式。
這使系統能即時響應外部事件，而不需要一直輪詢（polling）。
```

**Q2：ISR 和一般函式有什麼不同？**
```
1. ISR 由硬體觸發，一般函式由程式呼叫

2. ISR 執行前會「自動」保存 Context，一般函式「部分」保存
   
   詳細說明：
   ┌─────────────────────────────────────────────────────────┐
   │ ISR（中斷服務程式）：                                     │
   │   - CPU 硬體「自動」保存所有暫存器                        │
   │   - 包括 PC、SP、狀態暫存器、通用暫存器等全部              │
   │   - 因為 ISR 可能在「任何時候」被觸發，必須保存完整狀態    │
   │                                                          │
   │ 一般函式：                                                │
   │   - 遵循「呼叫約定」(Calling Convention)：一套標準規則，     │
   │     定義函式間如何傳遞參數及誰負責保護哪些暫存器。          │
   │   - Caller-saved (呼叫者保存)：                             │
   │     暫存器 (如 R0-R3) 可被函式隨意修改。若呼叫者之後還要    │
   │     用，必須在呼叫前自己先存入 Stack。                      │
   │   - Callee-saved (被呼叫者保存)：                           │
   │     暫存器 (如 R4-R11) 必須被保護。函式若要用到它們，必須   │
   │     先存入 Stack 並在返回前恢復原狀。                       │
   │   - 通常只保存「callee-saved」暫存器                      │
   │   - 「caller-saved」暫存器由呼叫者自己負責                 │
   │   - 因為是程式主動呼叫的，編譯器知道要保存什麼             │
   │   - 結論：編譯器已知呼叫發生點，只需保存「必要」的暫存器。    │
   └─────────────────────────────────────────────────────────┘

3. ISR 結束時使用特殊的返回機制（不是普通的 return）
   
   詳細說明：
   ┌─────────────────────────────────────────────────────────┐
   │ 一般函式的 return：                                       │
   │   - 使用 RET 或 BX LR 指令                               │
   │   - 從 stack 取回返回地址，跳回去                         │
   │                                                          │
   │ ISR 的返回：                                              │
   │   - ARM Cortex-M 使用特殊的「Exception Return」機制      │
   │   - 把 LR (Link Register) 設成特殊值如 0xFFFFFFF9        │
   │   - 執行 BX LR 時，CPU 會自動恢復之前保存的 Context       │
   │   - 這個過程叫做「Unstacking」                           │
   │                                                          │
   │ 為什麼不能用普通 return？                                 │
   │   - 普通 return 不會恢復 CPU 的執行模式                   │
   │   - 不會恢復中斷前的完整狀態                              │
   └─────────────────────────────────────────────────────────┘

4. ISR 通常要清除中斷旗標
   
   舉例：
   void EXTI0_IRQHandler(void) {
       // 做一些處理...
       
       // 必須清除中斷旗標！
       EXTI->PR |= (1 << 0);  // 清除 EXTI line 0 的 pending flag
       
       // 如果不清除，中斷會一直被觸發（因為硬體還認為中斷條件成立）
   }

5. ISR 應該盡可能短

6. ISR 中使用的變數需要宣告為 volatile
   （見上面 volatile 詳解）
```

**Q3：什麼是巢狀中斷（Nested Interrupt）？**
```
在 ISR 執行過程中，允許更高優先權的中斷打斷。

例如：
- ISR A (優先權 3) 正在執行
- 中斷 B (優先權 1) 發生
- ISR A 被暫停，開始執行 ISR B
- ISR B 完成後，返回 ISR A
- ISR A 完成後，返回主程式
```

**Q4：為什麼 ISR 中使用的變數要宣告 volatile？**
```c
// 錯誤示範：
int flag = 0;

void ISR(void) {
    flag = 1;
}

int main(void) {
    while (flag == 0) {
        // 編譯器可能優化成無限迴圈，因為它認為 flag 不會改變
    }
}

// 正確示範：
volatile int flag = 0;

void ISR(void) {
    flag = 1;
}

int main(void) {
    while (flag == 0) {
        // 每次都會真正讀取 flag 的值
    }
}
```

**Q5：中斷和輪詢（Polling）的比較？**
```
輪詢（Polling）：
- CPU 不斷檢查事件是否發生
- 浪費 CPU 資源
- 延遲取決於輪詢頻率
- 實作簡單

中斷（Interrupt）：
- 事件發生時通知 CPU
- CPU 可以做其他事
- 響應更即時
- 實作較複雜

適用場景：
- 高頻率事件 → 輪詢可能更好（避免頻繁中斷開銷）
- 低頻率、需快速響應 → 中斷更好
```

---

## ✅ 實作練習

```
1. 研究你使用的 MCU（如 ARM Cortex-M）的中斷機制
2. 閱讀 NVIC 相關暫存器
3. 寫一個 GPIO 外部中斷範例
4. 寫一個 Timer 中斷範例
5. 練習設定不同的中斷優先權
```
